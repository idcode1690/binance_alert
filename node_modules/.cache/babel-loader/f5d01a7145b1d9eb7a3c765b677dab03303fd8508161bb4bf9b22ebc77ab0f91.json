{"ast":null,"code":"import { calculateEma } from '../utils/ema';\n\n// Simple singleton scanner manager to run scans independent of React component lifecycle.\nconst scannerManager = (() => {\n  let running = false;\n  let currentSymbol = null;\n  let progress = {\n    done: 0,\n    total: 0\n  };\n  // load persisted results from localStorage when available so navigation doesn't lose matches\n  let results = [];\n  try {\n    if (typeof window !== 'undefined' && window.localStorage) {\n      const raw = window.localStorage.getItem('scannerResults');\n      if (raw) results = JSON.parse(raw) || [];\n    }\n  } catch (e) {\n    results = [];\n  }\n  let cancel = false;\n  // timestamp when the current scan started (ms since epoch) - persists so UI can show elapsed across pages\n  let scanStartTime = null;\n  // track multiple abort controllers when running requests in parallel\n  let currentAbortControllers = new Set();\n  let listeners = new Set();\n  let getSymbolsFn = null;\n  function notify() {\n    const state = {\n      running,\n      currentSymbol,\n      progress: {\n        ...progress\n      },\n      results: results.slice(),\n      scanStartTime\n    };\n    for (const cb of listeners) {\n      try {\n        cb(state);\n      } catch (e) {}\n    }\n    // persist results after notifying\n    try {\n      if (typeof window !== 'undefined' && window.localStorage) {\n        window.localStorage.setItem('scannerResults', JSON.stringify(results.slice(0, 200)));\n      }\n    } catch (e) {}\n  }\n  function onUpdate(cb) {\n    listeners.add(cb);\n    return () => listeners.delete(cb);\n  }\n  function setGetSymbols(fn) {\n    getSymbolsFn = fn;\n  }\n  function sleep(ms) {\n    return new Promise(r => setTimeout(r, ms));\n  }\n\n  // EMA helper disabled: project currently runs with EMA calculations removed/stubbed\n  // Return an array of nulls matching the input length so callers behave safely\n  // without producing matches. Re-implement when restoring EMA logic.\n  // calculateEma is provided by shared utils (`src/utils/ema.js`)\n\n  async function start(type, opts = {}) {\n    if (running) return;\n    if (typeof getSymbolsFn !== 'function') throw new Error('scannerManager: getSymbolsFn not set');\n    // initialize run state\n    running = true;\n    cancel = false;\n    results = [];\n    progress = {\n      done: 0,\n      total: 0\n    };\n    currentSymbol = null;\n    scanStartTime = Date.now();\n    notify();\n    const list = (await Promise.resolve(getSymbolsFn())) || [];\n    // accept options: interval (e.g., '5m' or number of minutes), emaShort, emaLong\n    let interval = opts && typeof opts.interval !== 'undefined' ? opts.interval : '5m';\n    if (typeof interval === 'number' || typeof interval === 'string' && /^\\d+$/.test(interval)) interval = `${interval}m`;\n    const emaShort = opts && typeof opts.emaShort !== 'undefined' ? parseInt(opts.emaShort, 10) : 26;\n    const emaLong = opts && typeof opts.emaLong !== 'undefined' ? parseInt(opts.emaLong, 10) : 200;\n    const filtered = Array.isArray(list) ? list.filter(s => typeof s === 'string' && /USDT$/i.test(s)) : [];\n    progress.total = filtered.length;\n    notify();\n    const endpointBase = 'https://fapi.binance.com/fapi/v1/klines';\n\n    // concurrency controls: default to a faster parallelism for quicker scans\n    // These defaults can be overridden via opts when calling start()\n    // Adjusted defaults to slow the scanner a bit so a full pass is ~30s on typical symbol counts.\n    // Make defaults conservative to avoid triggering API rate-limit warnings\n    const concurrencyDefault = opts && typeof opts.concurrency === 'number' ? Math.max(1, opts.concurrency) : 2;\n    const batchDelayBase = opts && typeof opts.batchDelay === 'number' ? Math.max(0, opts.batchDelay) : 600; // ms between batches (slower default)\n    // mutable runtime controls (auto-tuner will adjust these)\n    let concurrencyCurrent = concurrencyDefault;\n    let batchDelayCurrent = batchDelayBase;\n    // cap maxConcurrency to the starting concurrency by default to prevent aggressive ramp-up\n    const maxConcurrency = opts && typeof opts.maxConcurrency === 'number' ? Math.max(1, opts.maxConcurrency) : concurrencyDefault;\n    // backoff/ramp state\n    let backoffCount = 0;\n    let consecutiveSuccesses = 0;\n    const successThreshold = opts && typeof opts.rampSuccessThreshold === 'number' ? Math.max(1, opts.rampSuccessThreshold) : 3;\n    const minBatchDelay = opts && typeof opts.minBatchDelay === 'number' ? Math.max(200, opts.minBatchDelay) : 300;\n\n    // helper to process one symbol; catches errors and always resolves\n    const processSymbol = async sym => {\n      if (cancel) return;\n      currentSymbol = sym;\n      notify();\n      const url = `${endpointBase}?symbol=${encodeURIComponent(sym)}&interval=${encodeURIComponent(interval)}&limit=1000`;\n      let localAbort = null;\n      try {\n        try {\n          localAbort = new AbortController();\n        } catch (e) {\n          localAbort = null;\n        }\n        if (localAbort) currentAbortControllers.add(localAbort);\n        const r = await fetch(url, localAbort ? {\n          signal: localAbort.signal\n        } : undefined);\n        if (!r.ok) {\n          if (r.status === 429) {\n            // increase backoff pressure and reduce concurrency\n            backoffCount += 1;\n            consecutiveSuccesses = 0;\n            concurrencyCurrent = Math.max(1, Math.floor(concurrencyCurrent * 0.6));\n            batchDelayCurrent = Math.min(30000, Math.floor(batchDelayCurrent * 1.6));\n            const base = 1000;\n            const backoffMs = Math.min(30000, Math.floor(base * Math.pow(2, Math.min(backoffCount, 6))) + Math.floor(Math.random() * 1000));\n            try {\n              await sleep(backoffMs);\n            } catch (e) {}\n          }\n          return;\n        }\n        const data = await r.json();\n        // success: reduce backoff pressure and allow gentle ramp-up\n        backoffCount = Math.max(0, backoffCount - 1);\n        consecutiveSuccesses += 1;\n        if (consecutiveSuccesses >= successThreshold) {\n          consecutiveSuccesses = 0;\n          if (concurrencyCurrent < maxConcurrency) {\n            concurrencyCurrent = concurrencyCurrent + 1;\n          }\n          batchDelayCurrent = Math.max(minBatchDelay, Math.floor(batchDelayCurrent * 0.85));\n        }\n        const closes = Array.isArray(data) ? data.map(d => parseFloat(d[4])) : [];\n        const needed = Math.max(emaShort, emaLong) + 10;\n        if (!Array.isArray(closes) || closes.length < needed) {\n          return;\n        }\n        const emaShortArr = calculateEma(closes, emaShort);\n        const emaLongArr = calculateEma(closes, emaLong);\n        const lastIdx = closes.length - 1;\n        const prevIdx = lastIdx - 1;\n        const prevShort = emaShortArr[prevIdx];\n        const prevLong = emaLongArr[prevIdx];\n        const lastShort = emaShortArr[lastIdx];\n        const lastLong = emaLongArr[lastIdx];\n        let matched = false;\n        if (typeof prevShort === 'number' && typeof prevLong === 'number' && typeof lastShort === 'number' && typeof lastLong === 'number') {\n          if (type === 'golden') {\n            if (prevShort <= prevLong && lastShort > lastLong) matched = true;\n          } else if (type === 'dead') {\n            if (prevShort >= prevLong && lastShort < lastLong) matched = true;\n          }\n        }\n        if (matched) {\n          const ev = {\n            id: `${sym}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,\n            symbol: sym,\n            lastShort,\n            lastLong,\n            time: new Date().toLocaleString(),\n            interval,\n            emaShort,\n            emaLong\n          };\n          results.unshift(ev);\n          // cap stored results to reasonable size (avoid unbounded growth)\n          if (results.length > 500) results = results.slice(0, 500);\n          notify();\n        }\n      } catch (e) {\n        if (e && e.name === 'AbortError') {\n          // expected when stopping\n        } else {\n          // ignore other fetch errors\n        }\n      } finally {\n        // cleanup local abort controller\n        if (localAbort) currentAbortControllers.delete(localAbort);\n        progress.done += 1;\n        notify();\n      }\n    };\n    // run in batches with a mutable concurrency controlled by the auto-tuner\n    let i = 0;\n    try {\n      while (i < filtered.length) {\n        if (cancel) break;\n        const currentConcurrency = Math.max(1, Math.floor(concurrencyCurrent));\n        const batch = filtered.slice(i, i + currentConcurrency);\n        if (!batch || batch.length === 0) break;\n        await Promise.all(batch.map(sym => processSymbol(sym)));\n        if (cancel) break;\n        i += batch.length;\n        if (i < filtered.length) {\n          const jitter = Math.floor(Math.random() * Math.min(300, Math.max(20, Math.floor(batchDelayCurrent * 0.5))));\n          const delay = Math.max(0, batchDelayCurrent + jitter);\n          await sleep(delay);\n        }\n      }\n    } catch (err) {\n      // log unexpected errors but don't leave scanner in running state\n      try {\n        console.error('scannerManager.start error', err && err.message ? err.message : err);\n      } catch (e) {}\n    } finally {\n      // cleanup any remaining abort controllers\n      try {\n        for (const c of currentAbortControllers) {\n          try {\n            c.abort();\n          } catch (e) {}\n        }\n      } catch (e) {}\n      currentAbortControllers.clear();\n      running = false;\n      currentSymbol = null;\n      cancel = false;\n      scanStartTime = null;\n      notify();\n    }\n  }\n  function stop() {\n    // signal cancellation and abort any in-flight fetch\n    cancel = true;\n    try {\n      // abort any tracked controllers\n      for (const c of currentAbortControllers) {\n        try {\n          if (c && typeof c.abort === 'function') c.abort();\n        } catch (e) {}\n      }\n      currentAbortControllers.clear();\n    } catch (e) {}\n    running = false;\n    currentSymbol = null;\n    scanStartTime = null;\n    notify();\n  }\n  function getState() {\n    return {\n      running,\n      currentSymbol,\n      progress: {\n        ...progress\n      },\n      results: results.slice(),\n      scanStartTime\n    };\n  }\n  function removeResult(id) {\n    if (!id) return;\n    results = results.filter(r => r.id !== id);\n    notify();\n  }\n  function clearResults() {\n    results = [];\n    notify();\n  }\n  return {\n    onUpdate,\n    setGetSymbols,\n    start,\n    stop,\n    getState,\n    removeResult,\n    clearResults\n  };\n})();\nexport default scannerManager;","map":{"version":3,"names":["calculateEma","scannerManager","running","currentSymbol","progress","done","total","results","window","localStorage","raw","getItem","JSON","parse","e","cancel","scanStartTime","currentAbortControllers","Set","listeners","getSymbolsFn","notify","state","slice","cb","setItem","stringify","onUpdate","add","delete","setGetSymbols","fn","sleep","ms","Promise","r","setTimeout","start","type","opts","Error","Date","now","list","resolve","interval","test","emaShort","parseInt","emaLong","filtered","Array","isArray","filter","s","length","endpointBase","concurrencyDefault","concurrency","Math","max","batchDelayBase","batchDelay","concurrencyCurrent","batchDelayCurrent","maxConcurrency","backoffCount","consecutiveSuccesses","successThreshold","rampSuccessThreshold","minBatchDelay","processSymbol","sym","url","encodeURIComponent","localAbort","AbortController","fetch","signal","undefined","ok","status","floor","min","base","backoffMs","pow","random","data","json","closes","map","d","parseFloat","needed","emaShortArr","emaLongArr","lastIdx","prevIdx","prevShort","prevLong","lastShort","lastLong","matched","ev","id","toString","symbol","time","toLocaleString","unshift","name","i","currentConcurrency","batch","all","jitter","delay","err","console","error","message","c","abort","clear","stop","getState","removeResult","clearResults"],"sources":["C:/Users/e1it3/Desktop/program/binance_alert/src/lib/scannerManager.js"],"sourcesContent":["import { calculateEma } from '../utils/ema';\r\n\r\n// Simple singleton scanner manager to run scans independent of React component lifecycle.\r\nconst scannerManager = (() => {\r\n  let running = false;\r\n  let currentSymbol = null;\r\n  let progress = { done: 0, total: 0 };\r\n  // load persisted results from localStorage when available so navigation doesn't lose matches\r\n  let results = [];\r\n  try {\r\n    if (typeof window !== 'undefined' && window.localStorage) {\r\n      const raw = window.localStorage.getItem('scannerResults');\r\n      if (raw) results = JSON.parse(raw) || [];\r\n    }\r\n  } catch (e) {\r\n    results = [];\r\n  }\r\n  let cancel = false;\r\n  // timestamp when the current scan started (ms since epoch) - persists so UI can show elapsed across pages\r\n  let scanStartTime = null;\r\n  // track multiple abort controllers when running requests in parallel\r\n  let currentAbortControllers = new Set();\r\n  let listeners = new Set();\r\n  let getSymbolsFn = null;\r\n\r\n  function notify() {\r\n    const state = { running, currentSymbol, progress: { ...progress }, results: results.slice(), scanStartTime };\r\n    for (const cb of listeners) {\r\n      try { cb(state); } catch (e) {}\r\n    }\r\n    // persist results after notifying\r\n    try {\r\n      if (typeof window !== 'undefined' && window.localStorage) {\r\n        window.localStorage.setItem('scannerResults', JSON.stringify(results.slice(0, 200)));\r\n      }\r\n    } catch (e) {}\r\n  }\r\n\r\n  function onUpdate(cb) { listeners.add(cb); return () => listeners.delete(cb); }\r\n\r\n  function setGetSymbols(fn) { getSymbolsFn = fn; }\r\n\r\n  function sleep(ms) { return new Promise((r) => setTimeout(r, ms)); }\r\n\r\n  // EMA helper disabled: project currently runs with EMA calculations removed/stubbed\r\n  // Return an array of nulls matching the input length so callers behave safely\r\n  // without producing matches. Re-implement when restoring EMA logic.\r\n  // calculateEma is provided by shared utils (`src/utils/ema.js`)\r\n\r\n  async function start(type, opts = {}) {\r\n    if (running) return;\r\n    if (typeof getSymbolsFn !== 'function') throw new Error('scannerManager: getSymbolsFn not set');\r\n    // initialize run state\r\n    running = true;\r\n    cancel = false;\r\n    results = [];\r\n    progress = { done: 0, total: 0 };\r\n    currentSymbol = null;\r\n    scanStartTime = Date.now();\r\n    notify();\r\n    const list = (await Promise.resolve(getSymbolsFn())) || [];\r\n    // accept options: interval (e.g., '5m' or number of minutes), emaShort, emaLong\r\n    let interval = (opts && typeof opts.interval !== 'undefined') ? opts.interval : '5m';\r\n    if (typeof interval === 'number' || (typeof interval === 'string' && /^\\d+$/.test(interval))) interval = `${interval}m`;\r\n    const emaShort = (opts && typeof opts.emaShort !== 'undefined') ? parseInt(opts.emaShort, 10) : 26;\r\n    const emaLong = (opts && typeof opts.emaLong !== 'undefined') ? parseInt(opts.emaLong, 10) : 200;\r\n    const filtered = (Array.isArray(list) ? list.filter(s => typeof s === 'string' && /USDT$/i.test(s)) : []);\r\n    progress.total = filtered.length; notify();\r\n    const endpointBase = 'https://fapi.binance.com/fapi/v1/klines';\r\n\r\n  // concurrency controls: default to a faster parallelism for quicker scans\r\n  // These defaults can be overridden via opts when calling start()\r\n  // Adjusted defaults to slow the scanner a bit so a full pass is ~30s on typical symbol counts.\r\n  // Make defaults conservative to avoid triggering API rate-limit warnings\r\n  const concurrencyDefault = (opts && typeof opts.concurrency === 'number') ? Math.max(1, opts.concurrency) : 2;\r\n  const batchDelayBase = (opts && typeof opts.batchDelay === 'number') ? Math.max(0, opts.batchDelay) : 600; // ms between batches (slower default)\r\n  // mutable runtime controls (auto-tuner will adjust these)\r\n  let concurrencyCurrent = concurrencyDefault;\r\n  let batchDelayCurrent = batchDelayBase;\r\n  // cap maxConcurrency to the starting concurrency by default to prevent aggressive ramp-up\r\n  const maxConcurrency = (opts && typeof opts.maxConcurrency === 'number') ? Math.max(1, opts.maxConcurrency) : concurrencyDefault;\r\n  // backoff/ramp state\r\n  let backoffCount = 0;\r\n  let consecutiveSuccesses = 0;\r\n  const successThreshold = (opts && typeof opts.rampSuccessThreshold === 'number') ? Math.max(1, opts.rampSuccessThreshold) : 3;\r\n  const minBatchDelay = (opts && typeof opts.minBatchDelay === 'number') ? Math.max(200, opts.minBatchDelay) : 300;\r\n\r\n  // helper to process one symbol; catches errors and always resolves\r\n    const processSymbol = async (sym) => {\r\n      if (cancel) return;\r\n      currentSymbol = sym; notify();\r\n      const url = `${endpointBase}?symbol=${encodeURIComponent(sym)}&interval=${encodeURIComponent(interval)}&limit=1000`;\r\n      let localAbort = null;\r\n      try {\r\n        try { localAbort = new AbortController(); } catch (e) { localAbort = null; }\r\n        if (localAbort) currentAbortControllers.add(localAbort);\r\n        const r = await fetch(url, localAbort ? { signal: localAbort.signal } : undefined);\r\n        if (!r.ok) {\r\n          if (r.status === 429) {\r\n            // increase backoff pressure and reduce concurrency\r\n            backoffCount += 1;\r\n            consecutiveSuccesses = 0;\r\n            concurrencyCurrent = Math.max(1, Math.floor(concurrencyCurrent * 0.6));\r\n            batchDelayCurrent = Math.min(30000, Math.floor(batchDelayCurrent * 1.6));\r\n            const base = 1000;\r\n            const backoffMs = Math.min(30000, Math.floor(base * Math.pow(2, Math.min(backoffCount, 6))) + Math.floor(Math.random() * 1000));\r\n            try { await sleep(backoffMs); } catch (e) {}\r\n          }\r\n          return;\r\n        }\r\n        const data = await r.json();\r\n        // success: reduce backoff pressure and allow gentle ramp-up\r\n        backoffCount = Math.max(0, backoffCount - 1);\r\n        consecutiveSuccesses += 1;\r\n        if (consecutiveSuccesses >= successThreshold) {\r\n          consecutiveSuccesses = 0;\r\n          if (concurrencyCurrent < maxConcurrency) {\r\n            concurrencyCurrent = concurrencyCurrent + 1;\r\n          }\r\n          batchDelayCurrent = Math.max(minBatchDelay, Math.floor(batchDelayCurrent * 0.85));\r\n        }\r\n        const closes = (Array.isArray(data) ? data.map(d => parseFloat(d[4])) : []);\r\n        const needed = Math.max(emaShort, emaLong) + 10;\r\n        if (!Array.isArray(closes) || closes.length < needed) { return; }\r\n        const emaShortArr = calculateEma(closes, emaShort);\r\n        const emaLongArr = calculateEma(closes, emaLong);\r\n        const lastIdx = closes.length - 1;\r\n        const prevIdx = lastIdx - 1;\r\n        const prevShort = emaShortArr[prevIdx];\r\n        const prevLong = emaLongArr[prevIdx];\r\n        const lastShort = emaShortArr[lastIdx];\r\n        const lastLong = emaLongArr[lastIdx];\r\n        let matched = false;\r\n        if (typeof prevShort === 'number' && typeof prevLong === 'number' && typeof lastShort === 'number' && typeof lastLong === 'number') {\r\n          if (type === 'golden') { if (prevShort <= prevLong && lastShort > lastLong) matched = true; }\r\n          else if (type === 'dead') { if (prevShort >= prevLong && lastShort < lastLong) matched = true; }\r\n        }\r\n        if (matched) {\r\n          const ev = { id: `${sym}-${Date.now()}-${Math.random().toString(36).slice(2,8)}`, symbol: sym, lastShort, lastLong, time: new Date().toLocaleString(), interval, emaShort, emaLong };\r\n          results.unshift(ev);\r\n          // cap stored results to reasonable size (avoid unbounded growth)\r\n          if (results.length > 500) results = results.slice(0, 500);\r\n          notify();\r\n        }\r\n      } catch (e) {\r\n        if (e && e.name === 'AbortError') {\r\n          // expected when stopping\r\n        } else {\r\n          // ignore other fetch errors\r\n        }\r\n      } finally {\r\n        // cleanup local abort controller\r\n        if (localAbort) currentAbortControllers.delete(localAbort);\r\n        progress.done += 1; notify();\r\n      }\r\n    };\r\n    // run in batches with a mutable concurrency controlled by the auto-tuner\r\n    let i = 0;\r\n    try {\r\n      while (i < filtered.length) {\r\n        if (cancel) break;\r\n        const currentConcurrency = Math.max(1, Math.floor(concurrencyCurrent));\r\n        const batch = filtered.slice(i, i + currentConcurrency);\r\n        if (!batch || batch.length === 0) break;\r\n        await Promise.all(batch.map(sym => processSymbol(sym)));\r\n        if (cancel) break;\r\n        i += batch.length;\r\n        if (i < filtered.length) {\r\n          const jitter = Math.floor(Math.random() * Math.min(300, Math.max(20, Math.floor(batchDelayCurrent * 0.5))));\r\n          const delay = Math.max(0, batchDelayCurrent + jitter);\r\n          await sleep(delay);\r\n        }\r\n      }\r\n    } catch (err) {\r\n      // log unexpected errors but don't leave scanner in running state\r\n      try { console.error('scannerManager.start error', err && err.message ? err.message : err); } catch (e) {}\r\n    } finally {\r\n      // cleanup any remaining abort controllers\r\n      try { for (const c of currentAbortControllers) { try { c.abort(); } catch (e) {} } } catch (e) {}\r\n      currentAbortControllers.clear();\r\n      running = false; currentSymbol = null; cancel = false; scanStartTime = null; notify();\r\n    }\r\n  }\r\n\r\n  function stop() {\r\n    // signal cancellation and abort any in-flight fetch\r\n    cancel = true;\r\n    try {\r\n      // abort any tracked controllers\r\n      for (const c of currentAbortControllers) {\r\n        try { if (c && typeof c.abort === 'function') c.abort(); } catch (e) {}\r\n      }\r\n      currentAbortControllers.clear();\r\n    } catch (e) {}\r\n    running = false; currentSymbol = null; scanStartTime = null; notify();\r\n  }\r\n\r\n  function getState() { return { running, currentSymbol, progress: { ...progress }, results: results.slice(), scanStartTime }; }\r\n\r\n  function removeResult(id) {\r\n    if (!id) return;\r\n    results = results.filter(r => r.id !== id);\r\n    notify();\r\n  }\r\n\r\n  function clearResults() {\r\n    results = [];\r\n    notify();\r\n  }\r\n\r\n  return { onUpdate, setGetSymbols, start, stop, getState, removeResult, clearResults };\r\n})();\r\n\r\nexport default scannerManager;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}