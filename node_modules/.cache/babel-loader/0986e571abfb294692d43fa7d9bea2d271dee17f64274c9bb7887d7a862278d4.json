{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useState, useCallback } from 'react';\nimport { calculateInitialEMA, updateEMA } from '../utils/ema';\n\n// Feature flag: if true, update EMA preview from aggTrade (higher-frequency trade prices).\n// Default is false for consistency with closed-candle EMA calculations. Set\n// REACT_APP_EMA_USE_TRADES=true in your environment to enable trade-based preview updates.\nconst USE_TRADE_UPDATES = (process.env.REACT_APP_EMA_USE_TRADES || '').toString().toLowerCase() === 'true';\n\n// Hook options: { symbol }\nexport default function useEmaCross({\n  symbol = 'BTCUSDT',\n  autoConnect = true,\n  debug = false\n} = {}) {\n  _s();\n  const [ema9, setEma9] = useState(null);\n  const [ema26, setEma26] = useState(null);\n  const [lastPrice, setLastPrice] = useState(null);\n  const [cross, setCross] = useState(null); // preview (live) cross\n  const [confirmedCross, setConfirmedCross] = useState(null); // only updated on closed candles (confirmed)\n  const [confirmedSource, setConfirmedSource] = useState(null); // 'ws' | 'poll' | 'init'\n  const [connected, setConnected] = useState(false);\n  const [status, setStatus] = useState('idle');\n  const [lastCandleClosed, setLastCandleClosed] = useState(false);\n  const [activeSymbol, setActiveSymbol] = useState(null); // which symbol the hook has initialized/connected for\n\n  const wsRef = useRef(null);\n  const prevCrossRef = useRef(null);\n  const prevConfirmedRef = useRef(null);\n  const ema9Ref = useRef(null);\n  const ema26Ref = useRef(null);\n  // confirmed EMAs updated only on closed candles (kline.x === true) or polling\n  const ema9ConfirmedRef = useRef(null);\n  const ema26ConfirmedRef = useRef(null);\n  const reconnectAttemptsRef = useRef(0);\n  const reconnectTimerRef = useRef(null);\n  const currentSymbolRef = useRef(null);\n  // previous versions tracked only currentSymbolRef; avoid extra wsSymbolRef to reduce\n  // transient mismatches. Keep filtering simple and based on currentSymbolRef.\n  const lastProcessedCloseRef = useRef(null); // timestamp (ms) of last processed closed candle\n  const pollingTimerRef = useRef(null);\n  const fetchAndInit = useCallback(async (target = symbol) => {\n    try {\n      const t = (target || symbol).toString();\n      setStatus('fetching historical klines');\n      const norm = t.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\n      // Helper: fetch paginated klines from Binance (limit 1000 per request)\n      // We'll request backward pages (most recent first) until we have enough candles.\n      // Allow configuring desired history via env var REACT_APP_EMA_HISTORY, default to 5000.\n      // A larger history reduces differences vs. charting platforms which compute EMA over long histories.\n      const desired = parseInt(process.env.REACT_APP_EMA_HISTORY || '5000', 10);\n      const fetchKlinesPaginated = async (symbolNorm, interval = '1m', desiredCount = desired) => {\n        const all = [];\n        let keepFetching = true;\n        // fetch most recent chunk first\n        let endTime = undefined; // undefined -> latest\n        while (keepFetching && all.length < desiredCount) {\n          const params = new URLSearchParams();\n          params.set('symbol', symbolNorm);\n          params.set('interval', interval);\n          params.set('limit', '1000');\n          if (endTime) params.set('endTime', String(endTime));\n          const url = `https://fapi.binance.com/fapi/v1/klines?${params.toString()}`;\n          const res = await fetch(url);\n          if (!res.ok) throw new Error(`Failed to fetch klines: ${res.status}`);\n          const data = await res.json();\n          if (!Array.isArray(data) || data.length === 0) break;\n          all.push(...data);\n          if (data.length < 1000) {\n            keepFetching = false; // no more history\n          } else {\n            const firstOpen = data[0] && data[0][0];\n            if (!firstOpen) break;\n            endTime = firstOpen - 1;\n          }\n          // safety cap to avoid infinite loop\n          if (all.length > desiredCount * 5) break;\n        }\n        // sort by openTime chronological oldest->newest\n        all.sort((a, b) => a[0] - b[0]);\n        const closes = all.map(k => parseFloat(k[4]));\n        const lastCloseTime = all.length ? all[all.length - 1][6] : null;\n        // if we have more than desiredCount, take the last desiredCount (most recent)\n        return {\n          closes: closes.slice(Math.max(0, closes.length - desiredCount)),\n          lastCloseTime\n        };\n      };\n      const {\n        closes,\n        lastCloseTime\n      } = await fetchKlinesPaginated(norm, '1m');\n      if (closes.length < 26) throw new Error('Not enough historical candles to initialize EMA26');\n\n      // Use the close history to compute EMA9 and EMA26\n      // Compute EMA across the full returned history (older->newer) instead of slicing a small window.\n      // This reduces differences vs. charting platforms which compute EMA over long histories.\n      const initEma9 = calculateInitialEMA(closes, 9);\n      const initEma26 = calculateInitialEMA(closes, 26);\n      if (debug) {\n        try {\n          console.debug('[useEmaCross] initial EMAs', {\n            initEma9: initEma9,\n            initEma26: initEma26,\n            symbol: norm\n          });\n        } catch (e) {}\n      }\n\n      // initialize both preview and confirmed EMAs from historical closes\n      ema9Ref.current = initEma9;\n      ema26Ref.current = initEma26;\n      ema9ConfirmedRef.current = initEma9;\n      ema26ConfirmedRef.current = initEma26;\n      // record which symbol these EMAs correspond to\n      currentSymbolRef.current = norm;\n      setActiveSymbol(norm);\n      // record last processed closed candle time (closeTime at index 6)\n      try {\n        lastProcessedCloseRef.current = lastCloseTime || null;\n      } catch (e) {\n        lastProcessedCloseRef.current = null;\n      }\n      setEma9(initEma9);\n      setEma26(initEma26);\n      setLastPrice(closes[closes.length - 1]);\n      setStatus('initialized');\n      // set initial cross\n      const initialCross = initEma9 > initEma26 ? 'bull' : 'bear';\n      prevCrossRef.current = initialCross;\n      setCross(initialCross);\n      prevConfirmedRef.current = initialCross;\n      setConfirmedCross(initialCross);\n      setConfirmedSource('init');\n    } catch (err) {\n      setStatus(`init error: ${err.message}`);\n      console.error(err);\n    }\n  }, [symbol, debug]);\n  const connect = useCallback(async overrideSymbol => {\n    const targetSymbol = (overrideSymbol || symbol).toString();\n    const targetNorm = targetSymbol.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\n    // if a websocket exists for same symbol, no-op and set wsSymbolRef\n    // no wsSymbolRef in this simpler flow; we'll rely on currentSymbolRef to indicate\n    // the symbol we're initialized for.\n    if (wsRef.current) {\n      if (currentSymbolRef.current === targetNorm) return;\n      try {\n        wsRef.current.close();\n      } catch (e) {}\n      wsRef.current = null;\n    }\n    // Ensure EMA is initialized for the target symbol before connecting\n    try {\n      if (currentSymbolRef.current !== targetNorm || ema9Ref.current == null || ema26Ref.current == null) {\n        await fetchAndInit(targetNorm);\n      }\n    } catch (err) {\n      setStatus(`init error: ${err.message}`);\n      return;\n    }\n    setStatus('connecting websocket');\n    // Use combined stream: kline_1m + aggTrade for higher-frequency trade updates\n    const klineStream = `${targetNorm.toLowerCase()}@kline_1m`;\n    const tradeStream = `${targetNorm.toLowerCase()}@aggTrade`;\n    const streams = `${klineStream}/${tradeStream}`;\n    // use Binance Futures (USDT-M) websocket (fstream) combined stream\n    const url = `wss://fstream.binance.com/stream?streams=${streams}`;\n    console.log('Connecting websocket for', targetSymbol, 'url=', url);\n    const ws = new WebSocket(url);\n    wsRef.current = ws;\n    ws.onopen = () => {\n      // reset backoff attempts on successful open\n      reconnectAttemptsRef.current = 0;\n      if (reconnectTimerRef.current) {\n        clearTimeout(reconnectTimerRef.current);\n        reconnectTimerRef.current = null;\n      }\n      // stop polling if it was started while socket was down\n      if (pollingTimerRef.current) {\n        clearInterval(pollingTimerRef.current);\n        pollingTimerRef.current = null;\n      }\n      // record the normalized symbol this socket is for\n      currentSymbolRef.current = targetNorm;\n      setActiveSymbol(targetNorm);\n      if (debug) console.log('[useEmaCross] websocket open for', targetNorm);\n      setConnected(true);\n      setStatus('connected');\n      if (debug) console.debug('[useEmaCross] onopen currentSymbolRef=', currentSymbolRef.current, 'activeSymbol=', targetNorm);\n    };\n    ws.onmessage = ev => {\n      try {\n        const payloadWrapper = JSON.parse(ev.data);\n        if (debug) console.debug('[useEmaCross] raw message', payloadWrapper, 'currentSymbolRef=', currentSymbolRef.current);\n        // combined stream returns { stream, data }\n        const payload = payloadWrapper.data || payloadWrapper;\n\n        // determine the source symbol for this message (if available)\n        let sourceSymbol = null;\n        try {\n          if (payload && payload.s) sourceSymbol = payload.s.toString().toUpperCase();else if (payloadWrapper && payloadWrapper.stream) {\n            const streamName = payloadWrapper.stream.toString(); // e.g. trxusdt@aggTrade\n            sourceSymbol = streamName.split('@')[0].toUpperCase();\n          }\n        } catch (e) {\n          sourceSymbol = null;\n        }\n\n        // Strict filtering: require a determinable source symbol and ensure it matches\n        // the symbol we initialized for (currentSymbolRef). If missing or mismatched,\n        // drop the message to avoid mixing data from different symbols.\n        try {\n          const expected = (currentSymbolRef.current || '').toString().toUpperCase();\n          if (!sourceSymbol) {\n            if (debug) console.debug('[useEmaCross] dropping message with no sourceSymbol', {\n              payloadWrapper\n            });\n            return;\n          }\n          if (!expected || sourceSymbol !== expected) {\n            if (debug) console.debug('[useEmaCross] dropping message for different symbol', {\n              incoming: sourceSymbol,\n              expected\n            });\n            return;\n          }\n        } catch (e) {\n          // If symbol checks throw, drop the message to be conservative\n          if (debug) console.error('[useEmaCross] error during symbol validation', e);\n          return;\n        }\n\n        // aggTrade messages have event type 'aggTrade' and price in p\n        if (debug) {\n          try {\n            const streamName = payloadWrapper.stream || payload.e || 'unknown';\n            console.log('[useEmaCross] incoming', {\n              stream: streamName,\n              sourceSymbol,\n              event: payload.e || null\n            });\n          } catch (e) {}\n        }\n        if (payload.e === 'aggTrade') {\n          // Trade-based preview updates are optional. By default they are disabled\n          // to keep 1m EMA behavior consistent with closed-candle EMAs (safer for\n          // cross detection). Enable with REACT_APP_EMA_USE_TRADES=true.\n          const price = parseFloat(payload.p);\n          if (debug) console.debug('[useEmaCross] aggTrade price=', price);\n          // always update lastPrice so UI shows latest trade\n          setLastPrice(price);\n          if (!USE_TRADE_UPDATES) {\n            // trade updates disabled: don't modify EMA preview here\n            if (debug) console.debug('[useEmaCross] skipping trade-based EMA update (disabled by flag)');\n            return;\n          }\n          if (ema9Ref.current == null || ema26Ref.current == null) return;\n\n          // update EMA using trade price to provide higher-frequency preview\n          const newEma9 = updateEMA(ema9Ref.current, price, 9);\n          const newEma26 = updateEMA(ema26Ref.current, price, 26);\n          // preview EMAs only\n          ema9Ref.current = newEma9;\n          ema26Ref.current = newEma26;\n          setEma9(newEma9);\n          setEma26(newEma26);\n          const newCross = newEma9 > newEma26 ? 'bull' : 'bear';\n          if (prevCrossRef.current !== newCross) {\n            prevCrossRef.current = newCross;\n            setCross(newCross);\n            if (debug) console.debug('[useEmaCross] preview cross changed (aggTrade) ->', newCross, {\n              newEma9,\n              newEma26\n            });\n          }\n        }\n\n        // kline messages contain a 'k' object\n        if (payload.k) {\n          if (debug) console.debug('[useEmaCross] kline payload x=', payload.k.x, 'close=', payload.k.c);\n          const k = payload.k;\n          const close = parseFloat(k.c);\n          setLastPrice(close);\n          setLastCandleClosed(Boolean(k.x));\n          if (ema9Ref.current == null || ema26Ref.current == null) return;\n\n          // update EMA using kline close\n          // For partial candle: update preview EMA only\n          if (!k.x) {\n            const newEma9 = updateEMA(ema9Ref.current, close, 9);\n            const newEma26 = updateEMA(ema26Ref.current, close, 26);\n            ema9Ref.current = newEma9;\n            ema26Ref.current = newEma26;\n            setEma9(newEma9);\n            setEma26(newEma26);\n            if (debug) console.debug('[useEmaCross] partial kline preview updated', {\n              newEma9,\n              newEma26\n            });\n          } else {\n            // closed candle: update confirmed EMAs only (and sync preview to confirmed)\n            if (ema9ConfirmedRef.current == null || ema26ConfirmedRef.current == null) {\n              // defensive: fall back to preview if confirmed not initialized\n              ema9ConfirmedRef.current = ema9Ref.current;\n              ema26ConfirmedRef.current = ema26Ref.current;\n            }\n            const newEma9c = updateEMA(ema9ConfirmedRef.current, close, 9);\n            const newEma26c = updateEMA(ema26ConfirmedRef.current, close, 26);\n            ema9ConfirmedRef.current = newEma9c;\n            ema26ConfirmedRef.current = newEma26c;\n            // sync preview to confirmed after closed candle to avoid drift\n            ema9Ref.current = newEma9c;\n            ema26Ref.current = newEma26c;\n            setEma9(newEma9c);\n            setEma26(newEma26c);\n          }\n\n          // compute preview (live) cross from preview EMAs\n          const previewCross = ema9Ref.current != null && ema26Ref.current != null ? ema9Ref.current > ema26Ref.current ? 'bull' : 'bear' : null;\n          if (previewCross && prevCrossRef.current !== previewCross) {\n            prevCrossRef.current = previewCross;\n            setCross(previewCross);\n            if (debug) console.debug('[useEmaCross] preview cross changed (kline) ->', previewCross, {\n              ema9: ema9Ref.current,\n              ema26: ema26Ref.current\n            });\n          }\n          // If candle is closed (k.x === true) and it's a new closed candle, update processed time and set confirmed cross\n          if (Boolean(k.x)) {\n            try {\n              const closeTime = k.T || k.t || null; // k.T is close time in ms\n              if (closeTime && (!lastProcessedCloseRef.current || closeTime > lastProcessedCloseRef.current)) {\n                lastProcessedCloseRef.current = closeTime;\n                // compute confirmed cross using confirmed EMA refs (fallback to previewCross)\n                const confirmedNewCross = ema9ConfirmedRef.current != null && ema26ConfirmedRef.current != null ? ema9ConfirmedRef.current > ema26ConfirmedRef.current ? 'bull' : 'bear' : previewCross;\n                if (prevConfirmedRef.current !== confirmedNewCross) {\n                  prevConfirmedRef.current = confirmedNewCross;\n                  setConfirmedCross(confirmedNewCross);\n                  setConfirmedSource('ws');\n                  if (debug) console.debug('[useEmaCross] confirmed cross updated (kline close) ->', confirmedNewCross, {\n                    ema9c: ema9ConfirmedRef.current,\n                    ema26c: ema26ConfirmedRef.current\n                  });\n                }\n              }\n            } catch (e) {\n              // If an error occurs while processing the closed candle, do NOT\n              // mark the cross as confirmed based on a partial/preview value.\n              // This avoids turning a preview cross into a confirmed one when\n              // we couldn't safely compute confirmed EMAs.\n              if (debug) console.error('[useEmaCross] error computing confirmed cross for closed candle', e);\n            }\n          } else {\n            // partial candle: preview already updated above\n          }\n        }\n      } catch (err) {\n        console.error('ws message parse error', err);\n      }\n    };\n    ws.onerror = e => {\n      console.error('ws error', e);\n      setStatus('websocket error');\n      // close to trigger backoff reconnect\n      try {\n        ws.close();\n      } catch (err) {}\n    };\n    ws.onclose = () => {\n      setConnected(false);\n      setStatus('websocket closed');\n      wsRef.current = null;\n      // keep currentSymbolRef so reconnect/backoff logic can prefer the\n      // same symbol. Do not prematurely clear it here; disconnect()\n      // will clear refs when the user explicitly disconnects or when\n      // a new symbol init occurs.\n      if (debug) console.debug('[useEmaCross] websocket closed for', currentSymbolRef.current);\n      // start polling for closed candles while websocket is down\n      try {\n        if (!pollingTimerRef.current) {\n          pollingTimerRef.current = setInterval(async () => {\n            try {\n              // prefer polling for the last symbol we were tracking; fall back\n              // to the prop symbol if none available\n              const symRaw = currentSymbolRef.current || symbol || '';\n              const sym = (symRaw || '').replace(/[^A-Za-z0-9]/g, '').toUpperCase();\n              if (!sym) return;\n              const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${sym}&interval=1m&limit=10`;\n              const res = await fetch(url);\n              if (!res.ok) return;\n              const data = await res.json();\n              if (debug) console.debug('[useEmaCross] polling fetched kline count=', Array.isArray(data) ? data.length : 0, 'for', sym);\n              // iterate candles in chronological order and process any closed candles newer than lastProcessedCloseRef\n              const newClosed = [];\n              for (const k of data) {\n                const closeTime = k[6];\n                if (closeTime && (!lastProcessedCloseRef.current || closeTime > lastProcessedCloseRef.current)) {\n                  newClosed.push(k);\n                }\n              }\n              if (newClosed.length > 0) {\n                // sort by closeTime asc\n                newClosed.sort((a, b) => a[6] - b[6]);\n                for (const k of newClosed) {\n                  const close = parseFloat(k[4]);\n                  // update EMAs using closed candle\n                  if (ema9Ref.current == null || ema26Ref.current == null) continue;\n                  // update confirmed EMAs using closed candle (polling)\n                  if (ema9ConfirmedRef.current == null || ema26ConfirmedRef.current == null) {\n                    ema9ConfirmedRef.current = ema9Ref.current;\n                    ema26ConfirmedRef.current = ema26Ref.current;\n                  }\n                  const newEma9c = updateEMA(ema9ConfirmedRef.current, close, 9);\n                  const newEma26c = updateEMA(ema26ConfirmedRef.current, close, 26);\n                  ema9ConfirmedRef.current = newEma9c;\n                  ema26ConfirmedRef.current = newEma26c;\n                  // sync preview to confirmed\n                  ema9Ref.current = newEma9c;\n                  ema26Ref.current = newEma26c;\n                  setEma9(newEma9c);\n                  setEma26(newEma26c);\n                  const newCross = newEma9c > newEma26c ? 'bull' : 'bear';\n                  if (prevConfirmedRef.current !== newCross) {\n                    prevConfirmedRef.current = newCross;\n                    setConfirmedCross(newCross);\n                    setConfirmedSource('poll');\n                  }\n                  lastProcessedCloseRef.current = k[6];\n                  setLastPrice(parseFloat(k[4]));\n                  setLastCandleClosed(true);\n                }\n              }\n            } catch (e) {\n              // ignore polling errors\n            }\n          }, 10 * 1000); // poll every 10s\n        }\n      } catch (e) {}\n      // exponential backoff reconnect with jitter\n      const attempt = reconnectAttemptsRef.current || 0;\n      const base = 1000; // 1s\n      const delay = Math.min(30000, base * Math.pow(2, attempt));\n      const jitter = Math.floor(Math.random() * 1000);\n      reconnectAttemptsRef.current = attempt + 1;\n      reconnectTimerRef.current = setTimeout(() => {\n        reconnectTimerRef.current = null;\n        if (!wsRef.current) {\n          // prefer reconnecting to the currently requested symbol if available\n          const target = currentSymbolRef.current || symbol;\n          try {\n            connect(target);\n          } catch (e) {\n            connect(target);\n          }\n        }\n      }, delay + jitter);\n    };\n  }, [symbol, fetchAndInit, debug]);\n  const disconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n    setConnected(false);\n    setStatus('disconnected');\n    setActiveSymbol(null);\n    if (pollingTimerRef.current) {\n      clearInterval(pollingTimerRef.current);\n      pollingTimerRef.current = null;\n    }\n    // clear reconnect attempts/timers\n    try {\n      reconnectAttemptsRef.current = 0;\n      if (reconnectTimerRef.current) {\n        clearTimeout(reconnectTimerRef.current);\n        reconnectTimerRef.current = null;\n      }\n    } catch (e) {}\n  }, []);\n  useEffect(() => {\n    // initialize on mount (or when symbol changes)\n    // Reset current state immediately so previous symbol's values don't show while new symbol initializes\n    try {\n      // close any existing websocket\n      if (wsRef.current) {\n        try {\n          wsRef.current.close();\n        } catch (e) {}\n        wsRef.current = null;\n      }\n\n      // clear reconnect timers and attempts\n      if (reconnectTimerRef.current) {\n        clearTimeout(reconnectTimerRef.current);\n        reconnectTimerRef.current = null;\n      }\n      reconnectAttemptsRef.current = 0;\n\n      // reset refs and state for EMA and cross\n      prevCrossRef.current = null;\n      currentSymbolRef.current = null;\n      ema9Ref.current = null;\n      ema26Ref.current = null;\n      setActiveSymbol(null);\n      setEma9(null);\n      setEma26(null);\n      setLastPrice(null);\n      setCross(null);\n      setLastCandleClosed(false);\n      setConnected(false);\n      setStatus('reloading');\n    } catch (e) {}\n    // fetch history for the (new) symbol and initialize\n    fetchAndInit();\n    // cleanup on unmount\n    return () => {\n      if (wsRef.current) wsRef.current.close();\n      if (pollingTimerRef.current) {\n        clearInterval(pollingTimerRef.current);\n        pollingTimerRef.current = null;\n      }\n    };\n  }, [fetchAndInit]);\n\n  // auto connect after initialization if requested\n  useEffect(() => {\n    if (status === 'initialized' && autoConnect) {\n      // call connect once after initialization\n      connect();\n    }\n    // only run when status or autoConnect changes\n  }, [status, autoConnect, connect]);\n  return {\n    ema9,\n    ema26,\n    lastPrice,\n    lastCandleClosed,\n    cross,\n    confirmedCross,\n    confirmedSource,\n    connected,\n    status,\n    connect,\n    disconnect,\n    activeSymbol\n  };\n}\n_s(useEmaCross, \"5fa1Pyht9/jfdcUVNOlrSNo45XE=\");","map":{"version":3,"names":["useEffect","useRef","useState","useCallback","calculateInitialEMA","updateEMA","USE_TRADE_UPDATES","process","env","REACT_APP_EMA_USE_TRADES","toString","toLowerCase","useEmaCross","symbol","autoConnect","debug","_s","ema9","setEma9","ema26","setEma26","lastPrice","setLastPrice","cross","setCross","confirmedCross","setConfirmedCross","confirmedSource","setConfirmedSource","connected","setConnected","status","setStatus","lastCandleClosed","setLastCandleClosed","activeSymbol","setActiveSymbol","wsRef","prevCrossRef","prevConfirmedRef","ema9Ref","ema26Ref","ema9ConfirmedRef","ema26ConfirmedRef","reconnectAttemptsRef","reconnectTimerRef","currentSymbolRef","lastProcessedCloseRef","pollingTimerRef","fetchAndInit","target","t","norm","replace","toUpperCase","desired","parseInt","REACT_APP_EMA_HISTORY","fetchKlinesPaginated","symbolNorm","interval","desiredCount","all","keepFetching","endTime","undefined","length","params","URLSearchParams","set","String","url","res","fetch","ok","Error","data","json","Array","isArray","push","firstOpen","sort","a","b","closes","map","k","parseFloat","lastCloseTime","slice","Math","max","initEma9","initEma26","console","e","current","initialCross","err","message","error","connect","overrideSymbol","targetSymbol","targetNorm","close","klineStream","tradeStream","streams","log","ws","WebSocket","onopen","clearTimeout","clearInterval","onmessage","ev","payloadWrapper","JSON","parse","payload","sourceSymbol","s","stream","streamName","split","expected","incoming","event","price","p","newEma9","newEma26","newCross","x","c","Boolean","newEma9c","newEma26c","previewCross","closeTime","T","confirmedNewCross","ema9c","ema26c","onerror","onclose","setInterval","symRaw","sym","newClosed","attempt","base","delay","min","pow","jitter","floor","random","setTimeout","disconnect"],"sources":["C:/Users/e1it3/Desktop/program/binance_alert/src/hooks/useEmaCross.js"],"sourcesContent":["import { useEffect, useRef, useState, useCallback } from 'react';\r\nimport { calculateInitialEMA, updateEMA } from '../utils/ema';\r\n\r\n// Feature flag: if true, update EMA preview from aggTrade (higher-frequency trade prices).\r\n// Default is false for consistency with closed-candle EMA calculations. Set\r\n// REACT_APP_EMA_USE_TRADES=true in your environment to enable trade-based preview updates.\r\nconst USE_TRADE_UPDATES = (process.env.REACT_APP_EMA_USE_TRADES || '').toString().toLowerCase() === 'true';\r\n\r\n// Hook options: { symbol }\r\nexport default function useEmaCross({ symbol = 'BTCUSDT', autoConnect = true, debug = false } = {}) {\r\n  const [ema9, setEma9] = useState(null);\r\n  const [ema26, setEma26] = useState(null);\r\n  const [lastPrice, setLastPrice] = useState(null);\r\n  const [cross, setCross] = useState(null); // preview (live) cross\r\n  const [confirmedCross, setConfirmedCross] = useState(null); // only updated on closed candles (confirmed)\r\n  const [confirmedSource, setConfirmedSource] = useState(null); // 'ws' | 'poll' | 'init'\r\n  const [connected, setConnected] = useState(false);\r\n  const [status, setStatus] = useState('idle');\r\n  const [lastCandleClosed, setLastCandleClosed] = useState(false);\r\n  const [activeSymbol, setActiveSymbol] = useState(null); // which symbol the hook has initialized/connected for\r\n\r\n  const wsRef = useRef(null);\r\n  const prevCrossRef = useRef(null);\r\n  const prevConfirmedRef = useRef(null);\r\n  const ema9Ref = useRef(null);\r\n  const ema26Ref = useRef(null);\r\n  // confirmed EMAs updated only on closed candles (kline.x === true) or polling\r\n  const ema9ConfirmedRef = useRef(null);\r\n  const ema26ConfirmedRef = useRef(null);\r\n  const reconnectAttemptsRef = useRef(0);\r\n  const reconnectTimerRef = useRef(null);\r\n  const currentSymbolRef = useRef(null);\r\n  // previous versions tracked only currentSymbolRef; avoid extra wsSymbolRef to reduce\r\n  // transient mismatches. Keep filtering simple and based on currentSymbolRef.\r\n  const lastProcessedCloseRef = useRef(null); // timestamp (ms) of last processed closed candle\r\n  const pollingTimerRef = useRef(null);\r\n\r\n  const fetchAndInit = useCallback(async (target = symbol) => {\r\n    try {\r\n      const t = (target || symbol).toString();\r\n      setStatus('fetching historical klines');\r\n      const norm = t.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n      // Helper: fetch paginated klines from Binance (limit 1000 per request)\r\n      // We'll request backward pages (most recent first) until we have enough candles.\r\n  // Allow configuring desired history via env var REACT_APP_EMA_HISTORY, default to 5000.\r\n  // A larger history reduces differences vs. charting platforms which compute EMA over long histories.\r\n  const desired = parseInt(process.env.REACT_APP_EMA_HISTORY || '5000', 10);\r\n      const fetchKlinesPaginated = async (symbolNorm, interval = '1m', desiredCount = desired) => {\r\n        const all = [];\r\n        let keepFetching = true;\r\n        // fetch most recent chunk first\r\n        let endTime = undefined; // undefined -> latest\r\n        while (keepFetching && all.length < desiredCount) {\r\n          const params = new URLSearchParams();\r\n          params.set('symbol', symbolNorm);\r\n          params.set('interval', interval);\r\n          params.set('limit', '1000');\r\n          if (endTime) params.set('endTime', String(endTime));\r\n          const url = `https://fapi.binance.com/fapi/v1/klines?${params.toString()}`;\r\n          const res = await fetch(url);\r\n          if (!res.ok) throw new Error(`Failed to fetch klines: ${res.status}`);\r\n          const data = await res.json();\r\n          if (!Array.isArray(data) || data.length === 0) break;\r\n          all.push(...data);\r\n          if (data.length < 1000) {\r\n            keepFetching = false; // no more history\r\n          } else {\r\n            const firstOpen = data[0] && data[0][0];\r\n            if (!firstOpen) break;\r\n            endTime = firstOpen - 1;\r\n          }\r\n          // safety cap to avoid infinite loop\r\n          if (all.length > desiredCount * 5) break;\r\n        }\r\n        // sort by openTime chronological oldest->newest\r\n        all.sort((a, b) => a[0] - b[0]);\r\n        const closes = all.map((k) => parseFloat(k[4]));\r\n        const lastCloseTime = all.length ? all[all.length - 1][6] : null;\r\n        // if we have more than desiredCount, take the last desiredCount (most recent)\r\n        return { closes: closes.slice(Math.max(0, closes.length - desiredCount)), lastCloseTime };\r\n      };\r\n\r\n      const { closes, lastCloseTime } = await fetchKlinesPaginated(norm, '1m');\r\n\r\n      if (closes.length < 26) throw new Error('Not enough historical candles to initialize EMA26');\r\n\r\n  // Use the close history to compute EMA9 and EMA26\r\n  // Compute EMA across the full returned history (older->newer) instead of slicing a small window.\r\n  // This reduces differences vs. charting platforms which compute EMA over long histories.\r\n  const initEma9 = calculateInitialEMA(closes, 9);\r\n  const initEma26 = calculateInitialEMA(closes, 26);\r\n\r\n  if (debug) {\r\n    try { console.debug('[useEmaCross] initial EMAs', { initEma9: initEma9, initEma26: initEma26, symbol: norm }); } catch (e) {}\r\n  }\r\n\r\n    // initialize both preview and confirmed EMAs from historical closes\r\n    ema9Ref.current = initEma9;\r\n    ema26Ref.current = initEma26;\r\n    ema9ConfirmedRef.current = initEma9;\r\n    ema26ConfirmedRef.current = initEma26;\r\n      // record which symbol these EMAs correspond to\r\n      currentSymbolRef.current = norm;\r\n      setActiveSymbol(norm);\r\n  // record last processed closed candle time (closeTime at index 6)\r\n  try { lastProcessedCloseRef.current = lastCloseTime || null; } catch (e) { lastProcessedCloseRef.current = null; }\r\n    setEma9(initEma9);\r\n    setEma26(initEma26);\r\n    setLastPrice(closes[closes.length - 1]);\r\n      setStatus('initialized');\r\n      // set initial cross\r\n    const initialCross = initEma9 > initEma26 ? 'bull' : 'bear';\r\n      prevCrossRef.current = initialCross;\r\n  setCross(initialCross);\r\n  prevConfirmedRef.current = initialCross;\r\n  setConfirmedCross(initialCross);\r\n  setConfirmedSource('init');\r\n    } catch (err) {\r\n      setStatus(`init error: ${err.message}`);\r\n      console.error(err);\r\n    }\r\n  }, [symbol, debug]);\r\n\r\n  const connect = useCallback(async (overrideSymbol) => {\r\n  const targetSymbol = (overrideSymbol || symbol).toString();\r\n  const targetNorm = targetSymbol.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n    // if a websocket exists for same symbol, no-op and set wsSymbolRef\r\n    // no wsSymbolRef in this simpler flow; we'll rely on currentSymbolRef to indicate\r\n    // the symbol we're initialized for.\r\n    if (wsRef.current) {\r\n      if (currentSymbolRef.current === targetNorm) return;\r\n      try { wsRef.current.close(); } catch (e) {}\r\n      wsRef.current = null;\r\n    }\r\n    // Ensure EMA is initialized for the target symbol before connecting\r\n    try {\r\n      if (currentSymbolRef.current !== targetNorm || ema9Ref.current == null || ema26Ref.current == null) {\r\n        await fetchAndInit(targetNorm);\r\n      }\r\n    } catch (err) {\r\n      setStatus(`init error: ${err.message}`);\r\n      return;\r\n    }\r\n\r\n    setStatus('connecting websocket');\r\n    // Use combined stream: kline_1m + aggTrade for higher-frequency trade updates\r\n  const klineStream = `${targetNorm.toLowerCase()}@kline_1m`;\r\n  const tradeStream = `${targetNorm.toLowerCase()}@aggTrade`;\r\n    const streams = `${klineStream}/${tradeStream}`;\r\n  // use Binance Futures (USDT-M) websocket (fstream) combined stream\r\n  const url = `wss://fstream.binance.com/stream?streams=${streams}`;\r\n  console.log('Connecting websocket for', targetSymbol, 'url=', url); \r\n  const ws = new WebSocket(url);\r\n    wsRef.current = ws;\r\n\r\n    ws.onopen = () => {\r\n      // reset backoff attempts on successful open\r\n      reconnectAttemptsRef.current = 0;\r\n      if (reconnectTimerRef.current) {\r\n        clearTimeout(reconnectTimerRef.current);\r\n        reconnectTimerRef.current = null;\r\n      }\r\n      // stop polling if it was started while socket was down\r\n      if (pollingTimerRef.current) {\r\n        clearInterval(pollingTimerRef.current);\r\n        pollingTimerRef.current = null;\r\n      }\r\n      // record the normalized symbol this socket is for\r\n      currentSymbolRef.current = targetNorm;\r\n      setActiveSymbol(targetNorm);\r\n      if (debug) console.log('[useEmaCross] websocket open for', targetNorm);\r\n      setConnected(true);\r\n      setStatus('connected');\r\n      if (debug) console.debug('[useEmaCross] onopen currentSymbolRef=', currentSymbolRef.current, 'activeSymbol=', targetNorm);\r\n    };\r\n\r\n    ws.onmessage = (ev) => {\r\n      try {\r\n        const payloadWrapper = JSON.parse(ev.data);\r\n        if (debug) console.debug('[useEmaCross] raw message', payloadWrapper, 'currentSymbolRef=', currentSymbolRef.current);\r\n        // combined stream returns { stream, data }\r\n        const payload = payloadWrapper.data || payloadWrapper;\r\n\r\n        // determine the source symbol for this message (if available)\r\n        let sourceSymbol = null;\r\n        try {\r\n          if (payload && payload.s) sourceSymbol = payload.s.toString().toUpperCase();\r\n          else if (payloadWrapper && payloadWrapper.stream) {\r\n            const streamName = payloadWrapper.stream.toString(); // e.g. trxusdt@aggTrade\r\n            sourceSymbol = streamName.split('@')[0].toUpperCase();\r\n          }\r\n        } catch (e) { sourceSymbol = null; }\r\n\r\n        // Strict filtering: require a determinable source symbol and ensure it matches\r\n        // the symbol we initialized for (currentSymbolRef). If missing or mismatched,\r\n        // drop the message to avoid mixing data from different symbols.\r\n        try {\r\n          const expected = (currentSymbolRef.current || '').toString().toUpperCase();\r\n          if (!sourceSymbol) {\r\n            if (debug) console.debug('[useEmaCross] dropping message with no sourceSymbol', { payloadWrapper });\r\n            return;\r\n          }\r\n          if (!expected || sourceSymbol !== expected) {\r\n            if (debug) console.debug('[useEmaCross] dropping message for different symbol', { incoming: sourceSymbol, expected });\r\n            return;\r\n          }\r\n        } catch (e) {\r\n          // If symbol checks throw, drop the message to be conservative\r\n          if (debug) console.error('[useEmaCross] error during symbol validation', e);\r\n          return;\r\n        }\r\n        \r\n\r\n        // aggTrade messages have event type 'aggTrade' and price in p\r\n        if (debug) {\r\n          try {\r\n            const streamName = payloadWrapper.stream || payload.e || 'unknown';\r\n            console.log('[useEmaCross] incoming', { stream: streamName, sourceSymbol, event: payload.e || null });\r\n          } catch (e) {}\r\n        }\r\n        if (payload.e === 'aggTrade') {\r\n          // Trade-based preview updates are optional. By default they are disabled\r\n          // to keep 1m EMA behavior consistent with closed-candle EMAs (safer for\r\n          // cross detection). Enable with REACT_APP_EMA_USE_TRADES=true.\r\n          const price = parseFloat(payload.p);\r\n          if (debug) console.debug('[useEmaCross] aggTrade price=', price);\r\n          // always update lastPrice so UI shows latest trade\r\n          setLastPrice(price);\r\n\r\n          if (!USE_TRADE_UPDATES) {\r\n            // trade updates disabled: don't modify EMA preview here\r\n            if (debug) console.debug('[useEmaCross] skipping trade-based EMA update (disabled by flag)');\r\n            return;\r\n          }\r\n\r\n          if (ema9Ref.current == null || ema26Ref.current == null) return;\r\n\r\n          // update EMA using trade price to provide higher-frequency preview\r\n          const newEma9 = updateEMA(ema9Ref.current, price, 9);\r\n          const newEma26 = updateEMA(ema26Ref.current, price, 26);\r\n          // preview EMAs only\r\n          ema9Ref.current = newEma9;\r\n          ema26Ref.current = newEma26;\r\n          setEma9(newEma9);\r\n          setEma26(newEma26);\r\n\r\n          const newCross = newEma9 > newEma26 ? 'bull' : 'bear';\r\n          if (prevCrossRef.current !== newCross) {\r\n            prevCrossRef.current = newCross;\r\n            setCross(newCross);\r\n            if (debug) console.debug('[useEmaCross] preview cross changed (aggTrade) ->', newCross, { newEma9, newEma26 });\r\n          }\r\n        }\r\n\r\n        // kline messages contain a 'k' object\r\n        if (payload.k) {\r\n          if (debug) console.debug('[useEmaCross] kline payload x=', payload.k.x, 'close=', payload.k.c);\r\n          const k = payload.k;\r\n          const close = parseFloat(k.c);\r\n          setLastPrice(close);\r\n          setLastCandleClosed(Boolean(k.x));\r\n\r\n          if (ema9Ref.current == null || ema26Ref.current == null) return;\r\n\r\n          // update EMA using kline close\r\n          // For partial candle: update preview EMA only\r\n            if (!k.x) {\r\n            const newEma9 = updateEMA(ema9Ref.current, close, 9);\r\n            const newEma26 = updateEMA(ema26Ref.current, close, 26);\r\n            ema9Ref.current = newEma9;\r\n            ema26Ref.current = newEma26;\r\n            setEma9(newEma9);\r\n            setEma26(newEma26);\r\n              if (debug) console.debug('[useEmaCross] partial kline preview updated', { newEma9, newEma26 });\r\n          } else {\r\n            // closed candle: update confirmed EMAs only (and sync preview to confirmed)\r\n            if (ema9ConfirmedRef.current == null || ema26ConfirmedRef.current == null) {\r\n              // defensive: fall back to preview if confirmed not initialized\r\n              ema9ConfirmedRef.current = ema9Ref.current;\r\n              ema26ConfirmedRef.current = ema26Ref.current;\r\n            }\r\n            const newEma9c = updateEMA(ema9ConfirmedRef.current, close, 9);\r\n            const newEma26c = updateEMA(ema26ConfirmedRef.current, close, 26);\r\n            ema9ConfirmedRef.current = newEma9c;\r\n            ema26ConfirmedRef.current = newEma26c;\r\n            // sync preview to confirmed after closed candle to avoid drift\r\n            ema9Ref.current = newEma9c;\r\n            ema26Ref.current = newEma26c;\r\n            setEma9(newEma9c);\r\n            setEma26(newEma26c);\r\n          }\r\n\r\n            // compute preview (live) cross from preview EMAs\r\n          const previewCross = (ema9Ref.current != null && ema26Ref.current != null) ? (ema9Ref.current > ema26Ref.current ? 'bull' : 'bear') : null;\r\n          if (previewCross && prevCrossRef.current !== previewCross) {\r\n            prevCrossRef.current = previewCross;\r\n            setCross(previewCross);\r\n            if (debug) console.debug('[useEmaCross] preview cross changed (kline) ->', previewCross, { ema9: ema9Ref.current, ema26: ema26Ref.current });\r\n          }\r\n          // If candle is closed (k.x === true) and it's a new closed candle, update processed time and set confirmed cross\r\n          if (Boolean(k.x)) {\r\n            try {\r\n              const closeTime = k.T || k.t || null; // k.T is close time in ms\r\n              if (closeTime && (!lastProcessedCloseRef.current || closeTime > lastProcessedCloseRef.current)) {\r\n                lastProcessedCloseRef.current = closeTime;\r\n                // compute confirmed cross using confirmed EMA refs (fallback to previewCross)\r\n                const confirmedNewCross = (ema9ConfirmedRef.current != null && ema26ConfirmedRef.current != null) ? (ema9ConfirmedRef.current > ema26ConfirmedRef.current ? 'bull' : 'bear') : previewCross;\r\n                if (prevConfirmedRef.current !== confirmedNewCross) {\r\n                  prevConfirmedRef.current = confirmedNewCross;\r\n                  setConfirmedCross(confirmedNewCross);\r\n                  setConfirmedSource('ws');\r\n                  if (debug) console.debug('[useEmaCross] confirmed cross updated (kline close) ->', confirmedNewCross, { ema9c: ema9ConfirmedRef.current, ema26c: ema26ConfirmedRef.current });\r\n                }\r\n              }\r\n            } catch (e) {\r\n              // If an error occurs while processing the closed candle, do NOT\r\n              // mark the cross as confirmed based on a partial/preview value.\r\n              // This avoids turning a preview cross into a confirmed one when\r\n              // we couldn't safely compute confirmed EMAs.\r\n              if (debug) console.error('[useEmaCross] error computing confirmed cross for closed candle', e);\r\n            }\r\n          } else {\r\n            // partial candle: preview already updated above\r\n          }\r\n        }\r\n      } catch (err) {\r\n        console.error('ws message parse error', err);\r\n      }\r\n    };\r\n\r\n    ws.onerror = (e) => {\r\n      console.error('ws error', e);\r\n      setStatus('websocket error');\r\n      // close to trigger backoff reconnect\r\n      try { ws.close(); } catch (err) {}\r\n    };\r\n\r\n    ws.onclose = () => {\r\n      setConnected(false);\r\n      setStatus('websocket closed');\r\n      wsRef.current = null;\r\n      // keep currentSymbolRef so reconnect/backoff logic can prefer the\r\n      // same symbol. Do not prematurely clear it here; disconnect()\r\n      // will clear refs when the user explicitly disconnects or when\r\n      // a new symbol init occurs.\r\n  if (debug) console.debug('[useEmaCross] websocket closed for', currentSymbolRef.current);\r\n      // start polling for closed candles while websocket is down\r\n      try {\r\n        if (!pollingTimerRef.current) {\r\n          pollingTimerRef.current = setInterval(async () => {\r\n            try {\r\n              // prefer polling for the last symbol we were tracking; fall back\r\n              // to the prop symbol if none available\r\n              const symRaw = currentSymbolRef.current || symbol || '';\r\n              const sym = (symRaw || '').replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n              if (!sym) return;\r\n              const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${sym}&interval=1m&limit=10`;\r\n              const res = await fetch(url);\r\n              if (!res.ok) return;\r\n              const data = await res.json();\r\n              if (debug) console.debug('[useEmaCross] polling fetched kline count=', Array.isArray(data) ? data.length : 0, 'for', sym);\r\n              // iterate candles in chronological order and process any closed candles newer than lastProcessedCloseRef\r\n              const newClosed = [];\r\n              for (const k of data) {\r\n                const closeTime = k[6];\r\n                if (closeTime && (!lastProcessedCloseRef.current || closeTime > lastProcessedCloseRef.current)) {\r\n                  newClosed.push(k);\r\n                }\r\n              }\r\n              if (newClosed.length > 0) {\r\n                // sort by closeTime asc\r\n                newClosed.sort((a, b) => a[6] - b[6]);\r\n                  for (const k of newClosed) {\r\n                    const close = parseFloat(k[4]);\r\n                    // update EMAs using closed candle\r\n                    if (ema9Ref.current == null || ema26Ref.current == null) continue;\r\n                    // update confirmed EMAs using closed candle (polling)\r\n                    if (ema9ConfirmedRef.current == null || ema26ConfirmedRef.current == null) {\r\n                      ema9ConfirmedRef.current = ema9Ref.current;\r\n                      ema26ConfirmedRef.current = ema26Ref.current;\r\n                    }\r\n                    const newEma9c = updateEMA(ema9ConfirmedRef.current, close, 9);\r\n                    const newEma26c = updateEMA(ema26ConfirmedRef.current, close, 26);\r\n                    ema9ConfirmedRef.current = newEma9c;\r\n                    ema26ConfirmedRef.current = newEma26c;\r\n                    // sync preview to confirmed\r\n                    ema9Ref.current = newEma9c;\r\n                    ema26Ref.current = newEma26c;\r\n                    setEma9(newEma9c);\r\n                    setEma26(newEma26c);\r\n                    const newCross = newEma9c > newEma26c ? 'bull' : 'bear';\r\n                      if (prevConfirmedRef.current !== newCross) {\r\n                        prevConfirmedRef.current = newCross;\r\n                          setConfirmedCross(newCross);\r\n                          setConfirmedSource('poll');\r\n                      }\r\n                    lastProcessedCloseRef.current = k[6];\r\n                    setLastPrice(parseFloat(k[4]));\r\n                    setLastCandleClosed(true);\r\n                  }\r\n              }\r\n            } catch (e) {\r\n              // ignore polling errors\r\n            }\r\n          }, 10 * 1000); // poll every 10s\r\n        }\r\n      } catch (e) {}\r\n      // exponential backoff reconnect with jitter\r\n      const attempt = reconnectAttemptsRef.current || 0;\r\n      const base = 1000; // 1s\r\n      const delay = Math.min(30000, base * Math.pow(2, attempt));\r\n      const jitter = Math.floor(Math.random() * 1000);\r\n      reconnectAttemptsRef.current = attempt + 1;\r\n      reconnectTimerRef.current = setTimeout(() => {\r\n        reconnectTimerRef.current = null;\r\n        if (!wsRef.current) {\r\n          // prefer reconnecting to the currently requested symbol if available\r\n          const target = currentSymbolRef.current || symbol;\r\n          try { connect(target); } catch (e) { connect(target); }\r\n        }\r\n      }, delay + jitter);\r\n    };\r\n  }, [symbol, fetchAndInit, debug]);\r\n\r\n  const disconnect = useCallback(() => {\r\n    if (wsRef.current) {\r\n      wsRef.current.close();\r\n      wsRef.current = null;\r\n    }\r\n    setConnected(false);\r\n    setStatus('disconnected');\r\n    setActiveSymbol(null);\r\n    if (pollingTimerRef.current) {\r\n      clearInterval(pollingTimerRef.current);\r\n      pollingTimerRef.current = null;\r\n    }\r\n    // clear reconnect attempts/timers\r\n    try {\r\n      reconnectAttemptsRef.current = 0;\r\n      if (reconnectTimerRef.current) {\r\n        clearTimeout(reconnectTimerRef.current);\r\n        reconnectTimerRef.current = null;\r\n      }\r\n    } catch (e) {}\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    // initialize on mount (or when symbol changes)\r\n    // Reset current state immediately so previous symbol's values don't show while new symbol initializes\r\n    try {\r\n      // close any existing websocket\r\n      if (wsRef.current) {\r\n        try { wsRef.current.close(); } catch (e) {}\r\n        wsRef.current = null;\r\n      }\r\n\r\n      // clear reconnect timers and attempts\r\n      if (reconnectTimerRef.current) {\r\n        clearTimeout(reconnectTimerRef.current);\r\n        reconnectTimerRef.current = null;\r\n      }\r\n      reconnectAttemptsRef.current = 0;\r\n\r\n      // reset refs and state for EMA and cross\r\n    prevCrossRef.current = null;\r\n    currentSymbolRef.current = null;\r\n    ema9Ref.current = null;\r\n    ema26Ref.current = null;\r\n  setActiveSymbol(null);\r\n    setEma9(null);\r\n    setEma26(null);\r\n      setLastPrice(null);\r\n      setCross(null);\r\n      setLastCandleClosed(false);\r\n      setConnected(false);\r\n      setStatus('reloading');\r\n    } catch (e) {}\r\n    // fetch history for the (new) symbol and initialize\r\n    fetchAndInit();\r\n    // cleanup on unmount\r\n    return () => {\r\n      if (wsRef.current) wsRef.current.close();\r\n      if (pollingTimerRef.current) {\r\n        clearInterval(pollingTimerRef.current);\r\n        pollingTimerRef.current = null;\r\n      }\r\n    };\r\n  }, [fetchAndInit]);\r\n\r\n  // auto connect after initialization if requested\r\n  useEffect(() => {\r\n    if (status === 'initialized' && autoConnect) {\r\n      // call connect once after initialization\r\n      connect();\r\n    }\r\n    // only run when status or autoConnect changes\r\n  }, [status, autoConnect, connect]);\r\n\r\n  return {\r\n    ema9,\r\n    ema26,\r\n    lastPrice,\r\n    lastCandleClosed,\r\n    cross,\r\n    confirmedCross,\r\n    confirmedSource,\r\n    connected,\r\n    status,\r\n    connect,\r\n    disconnect,\r\n    activeSymbol,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}