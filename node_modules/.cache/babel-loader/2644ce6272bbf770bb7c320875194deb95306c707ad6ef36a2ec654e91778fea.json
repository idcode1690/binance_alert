{"ast":null,"code":"import{calculateInitialEMA,updateEMA}from'./ema';// Small helper sleep\nfunction sleep(ms){return new Promise(r=>setTimeout(r,ms));}// Normalize symbol\nfunction normSym(s){return(s||'').toString().replace(/[^A-Za-z0-9]/g,'').toUpperCase();}// Scan a single symbol for a cross between shortPeriod and longPeriod on the given interval\n// Returns { symbol, crossed: true/false, direction: 'bull'|'bear'|null, price, when, error }\nexport async function scanSymbolForCross(symbol){let{interval='5m',shortPeriod=26,longPeriod=200,limit=500}=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const s=normSym(symbol);if(!s)return{symbol,error:'invalid symbol'};try{const url=\"https://fapi.binance.com/fapi/v1/klines?symbol=\".concat(s,\"&interval=\").concat(interval,\"&limit=\").concat(limit);const res=await fetch(url);if(!res.ok)return{symbol:s,error:\"klines fetch failed \".concat(res.status)};const data=await res.json();const closes=(data||[]).map(k=>parseFloat(k[4]));if(!Array.isArray(closes)||closes.length<longPeriod+1){return{symbol:s,error:\"not enough candles (\".concat(closes.length,\") for long period \").concat(longPeriod)};}// compute EMA before last closed candle (use closes up to second-last)\nconst before=closes.slice(0,-1);const lastClose=closes[closes.length-1];const emaShortBefore=calculateInitialEMA(before.slice(-Math.max(before.length,longPeriod+10)),shortPeriod);const emaLongBefore=calculateInitialEMA(before.slice(-Math.max(before.length,longPeriod+10)),longPeriod);// if calculateInitialEMA can't compute because not enough length, fall back to full before\n// but calculateInitialEMA already expects array length >= period\nconst emaShortAfter=updateEMA(emaShortBefore,lastClose,shortPeriod);const emaLongAfter=updateEMA(emaLongBefore,lastClose,longPeriod);const crossBefore=emaShortBefore>emaLongBefore?'bull':'bear';const crossAfter=emaShortAfter>emaLongAfter?'bull':'bear';const crossed=crossBefore!==crossAfter;const direction=crossed?crossAfter:null;const when=data&&data.length>0?new Date(data[data.length-1][6]).toISOString():new Date().toISOString();return{symbol:s,crossed,direction,price:lastClose,when};}catch(err){return{symbol:s,error:String(err)};}}// Run a sequential scan over symbols with delay between requests to avoid rate limits.\n// onUpdate is called per-symbol with the result object; returns a controller with stop().\nexport function startScanner(symbols){let{interval='5m',shortPeriod=26,longPeriod=200,limit=500,delayMs=500}=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let onUpdate=arguments.length>2?arguments[2]:undefined;let stopped=false;async function runOnce(){for(const raw of symbols){if(stopped)break;const s=normSym(raw);const res=await scanSymbolForCross(s,{interval,shortPeriod,longPeriod,limit});try{onUpdate&&onUpdate(res);}catch(e){}// delay to avoid bursting requests (rate limit protection)\nif(stopped)break;await sleep(delayMs);}}let loopPromise=null;async function loop(){while(!stopped){await runOnce();// after one full pass, wait a bit before next full pass\nfor(let i=0;i<10&&!stopped;i++){await sleep(1000);}}}loopPromise=loop();return{stop(){stopped=true;},isStopped(){return stopped;},promise:loopPromise};}","map":{"version":3,"names":["calculateInitialEMA","updateEMA","sleep","ms","Promise","r","setTimeout","normSym","s","toString","replace","toUpperCase","scanSymbolForCross","symbol","interval","shortPeriod","longPeriod","limit","arguments","length","undefined","error","url","concat","res","fetch","ok","status","data","json","closes","map","k","parseFloat","Array","isArray","before","slice","lastClose","emaShortBefore","Math","max","emaLongBefore","emaShortAfter","emaLongAfter","crossBefore","crossAfter","crossed","direction","when","Date","toISOString","price","err","String","startScanner","symbols","delayMs","onUpdate","stopped","runOnce","raw","e","loopPromise","loop","i","stop","isStopped","promise"],"sources":["C:/Users/e1it3/Desktop/program/binance_alert/src/utils/scanner.js"],"sourcesContent":["import { calculateInitialEMA, updateEMA } from './ema';\r\n\r\n// Small helper sleep\r\nfunction sleep(ms) {\r\n  return new Promise((r) => setTimeout(r, ms));\r\n}\r\n\r\n// Normalize symbol\r\nfunction normSym(s) {\r\n  return (s || '').toString().replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n}\r\n\r\n// Scan a single symbol for a cross between shortPeriod and longPeriod on the given interval\r\n// Returns { symbol, crossed: true/false, direction: 'bull'|'bear'|null, price, when, error }\r\nexport async function scanSymbolForCross(symbol, { interval = '5m', shortPeriod = 26, longPeriod = 200, limit = 500 } = {}) {\r\n  const s = normSym(symbol);\r\n  if (!s) return { symbol, error: 'invalid symbol' };\r\n  try {\r\n    const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${s}&interval=${interval}&limit=${limit}`;\r\n    const res = await fetch(url);\r\n    if (!res.ok) return { symbol: s, error: `klines fetch failed ${res.status}` };\r\n    const data = await res.json();\r\n    const closes = (data || []).map((k) => parseFloat(k[4]));\r\n    if (!Array.isArray(closes) || closes.length < longPeriod + 1) {\r\n      return { symbol: s, error: `not enough candles (${closes.length}) for long period ${longPeriod}` };\r\n    }\r\n\r\n    // compute EMA before last closed candle (use closes up to second-last)\r\n    const before = closes.slice(0, -1);\r\n    const lastClose = closes[closes.length - 1];\r\n\r\n    const emaShortBefore = calculateInitialEMA(before.slice(-Math.max(before.length, longPeriod + 10)), shortPeriod);\r\n    const emaLongBefore = calculateInitialEMA(before.slice(-Math.max(before.length, longPeriod + 10)), longPeriod);\r\n\r\n    // if calculateInitialEMA can't compute because not enough length, fall back to full before\r\n    // but calculateInitialEMA already expects array length >= period\r\n\r\n    const emaShortAfter = updateEMA(emaShortBefore, lastClose, shortPeriod);\r\n    const emaLongAfter = updateEMA(emaLongBefore, lastClose, longPeriod);\r\n\r\n    const crossBefore = emaShortBefore > emaLongBefore ? 'bull' : 'bear';\r\n    const crossAfter = emaShortAfter > emaLongAfter ? 'bull' : 'bear';\r\n\r\n    const crossed = crossBefore !== crossAfter;\r\n    const direction = crossed ? crossAfter : null;\r\n    const when = (data && data.length > 0) ? new Date(data[data.length - 1][6]).toISOString() : new Date().toISOString();\r\n\r\n    return { symbol: s, crossed, direction, price: lastClose, when };\r\n  } catch (err) {\r\n    return { symbol: s, error: String(err) };\r\n  }\r\n}\r\n\r\n// Run a sequential scan over symbols with delay between requests to avoid rate limits.\r\n// onUpdate is called per-symbol with the result object; returns a controller with stop().\r\nexport function startScanner(symbols, { interval = '5m', shortPeriod = 26, longPeriod = 200, limit = 500, delayMs = 500 } = {}, onUpdate) {\r\n  let stopped = false;\r\n\r\n  async function runOnce() {\r\n    for (const raw of symbols) {\r\n      if (stopped) break;\r\n      const s = normSym(raw);\r\n      const res = await scanSymbolForCross(s, { interval, shortPeriod, longPeriod, limit });\r\n      try { onUpdate && onUpdate(res); } catch (e) {}\r\n      // delay to avoid bursting requests (rate limit protection)\r\n      if (stopped) break;\r\n      await sleep(delayMs);\r\n    }\r\n  }\r\n\r\n  let loopPromise = null;\r\n  async function loop() {\r\n    while (!stopped) {\r\n      await runOnce();\r\n      // after one full pass, wait a bit before next full pass\r\n      for (let i = 0; i < 10 && !stopped; i++) {\r\n        await sleep(1000);\r\n      }\r\n    }\r\n  }\r\n\r\n  loopPromise = loop();\r\n\r\n  return {\r\n    stop() { stopped = true; },\r\n    isStopped() { return stopped; },\r\n    promise: loopPromise,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}