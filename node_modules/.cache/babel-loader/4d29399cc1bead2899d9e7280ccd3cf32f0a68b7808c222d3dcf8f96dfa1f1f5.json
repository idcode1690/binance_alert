{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useState, useCallback } from 'react';\nimport { calculateInitialEMA, updateEMA } from '../utils/ema';\n\n// Hook options: { symbol }\nexport default function useEmaCross({\n  symbol = 'BTCUSDT',\n  autoConnect = true,\n  debug = false,\n  interval = '1m',\n  emaShort = 9,\n  emaLong = 26,\n  confirmClosedCandles = 1\n} = {}) {\n  _s();\n  const [ema9, setEma9] = useState(null);\n  const [ema26, setEma26] = useState(null);\n  const [lastPrice, setLastPrice] = useState(null);\n  // lastTick represents the most recent trade/partial-candle price (live preview).\n  // lastPrice remains reserved for the most recent CLOSED candle price and is\n  // used when emitting confirmed alerts/notifications.\n  // eslint-disable-next-line no-unused-vars\n  const [lastTick, setLastTick] = useState(null);\n\n  // when debug is enabled, log lastTick updates so the variable is visibly used\n  // inside this module (and also helpful for debugging live preview values).\n  useEffect(() => {\n    try {\n      if (debug && typeof lastTick !== 'undefined' && lastTick !== null) {\n        // lightweight debug output\n        // eslint-disable-next-line no-console\n        console.debug('[useEmaCross] lastTick', lastTick);\n      }\n    } catch (e) {}\n  }, [lastTick, debug]);\n  const [cross, setCross] = useState(null); // preview (live) cross\n  const [confirmedCross, setConfirmedCross] = useState(null); // only updated on closed candles (confirmed)\n  const [confirmedSource, setConfirmedSource] = useState(null); // 'ws' | 'poll' | 'init'\n  const [connected, setConnected] = useState(false);\n  const [status, setStatus] = useState('idle');\n  const [lastCandleClosed, setLastCandleClosed] = useState(false);\n  const [activeSymbol, setActiveSymbol] = useState(null); // which symbol the hook has initialized/connected for\n\n  const wsRef = useRef(null);\n  const prevCrossRef = useRef(null);\n  const prevConfirmedRef = useRef(null);\n  const candidateConfirmedRef = useRef(null);\n  const candidateCountRef = useRef(0);\n  const ema9Ref = useRef(null);\n  const ema26Ref = useRef(null);\n  // confirmed EMAs updated only on closed candles (kline.x === true) or polling\n  const ema9ConfirmedRef = useRef(null);\n  const ema26ConfirmedRef = useRef(null);\n  const reconnectAttemptsRef = useRef(0);\n  const reconnectTimerRef = useRef(null);\n  const currentSymbolRef = useRef(null);\n  const lastProcessedCloseRef = useRef(null); // timestamp (ms) of last processed closed candle\n  const pollingTimerRef = useRef(null);\n\n  // Normalize interval strings for Binance API compatibility.\n  // Binance accepts tokens like '1m','3m','5m','15m','30m','1h','2h','4h', etc.\n  // The app sometimes passes numeric minute strings like '240m' or '240';\n  // convert minute multiples of 60 to '4h' style tokens so REST requests don't 400.\n  const normalizeIntervalForBinance = raw => {\n    try {\n      let s = String(raw || '').trim();\n      if (!s) return s;\n      s = s.toLowerCase();\n      const allowed = new Set(['1m', '3m', '5m', '15m', '30m', '1h', '2h', '4h', '6h', '8h', '12h', '1d', '3d', '1w', '1m']);\n      if (allowed.has(s)) return s;\n      // plain number like '240' -> minutes\n      const numMatch = s.match(/^([0-9]+)$/);\n      if (numMatch) {\n        const n = Number(numMatch[1]);\n        if (n % 60 === 0) return `${n / 60}h`;\n        return `${n}m`;\n      }\n      // matches like '240m'\n      const mMatch = s.match(/^([0-9]+)m$/);\n      if (mMatch) {\n        const n = Number(mMatch[1]);\n        if (n % 60 === 0) return `${n / 60}h`;\n        return `${n}m`;\n      }\n      // matches like '4h'\n      const hMatch = s.match(/^([0-9]+)h$/);\n      if (hMatch) return `${Number(hMatch[1])}h`;\n      return s;\n    } catch (e) {\n      return String(raw);\n    }\n  };\n  const getBinanceInterval = () => normalizeIntervalForBinance(interval);\n  const fetchAndInit = useCallback(async (target = symbol) => {\n    try {\n      const t = (target || symbol).toString();\n      setStatus('fetching historical klines');\n      const norm = t.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\n      // use Binance Futures (USDT-M) REST endpoint for klines; interval is configurable\n      // normalize interval to Binance-accepted token (e.g., convert '240m' -> '4h')\n      const bi = getBinanceInterval();\n      // request up to 1000 candles to provide long historical context for EMA calculations\n      const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${norm}&interval=${bi}&limit=1000`;\n      const res = await fetch(url);\n      if (!res.ok) throw new Error(`Failed to fetch klines: ${res.status}`);\n      const data = await res.json();\n      // kline array: [ openTime, open, high, low, close, ... ]\n      const closes = data.map(k => parseFloat(k[4]));\n      if (closes.length < emaLong) throw new Error(`Not enough historical candles to initialize EMA${emaLong}`);\n\n      // Determine sensible history windows for initial EMA calculation\n      const shortWindow = Math.max(emaShort * 10, 100);\n      const longWindow = Math.max(emaLong * 12, 300);\n\n      // Use the close history to compute EMA short/long\n      if (debug) console.debug('[useEmaCross] fetchAndInit params', {\n        symbol: norm,\n        interval,\n        emaShort,\n        emaLong,\n        shortWindow,\n        longWindow,\n        closesLength: closes.length\n      });\n      const initEma9 = calculateInitialEMA(closes.slice(-shortWindow), emaShort);\n      const initEma26 = calculateInitialEMA(closes.slice(-longWindow), emaLong);\n\n      // initialize both preview and confirmed EMAs from historical closes\n      ema9Ref.current = initEma9;\n      ema26Ref.current = initEma26;\n      ema9ConfirmedRef.current = initEma9;\n      ema26ConfirmedRef.current = initEma26;\n      // record which symbol these EMAs correspond to\n      currentSymbolRef.current = norm;\n      setActiveSymbol(norm);\n      // record last processed closed candle time (closeTime at index 6)\n      try {\n        lastProcessedCloseRef.current = data[data.length - 1][6];\n      } catch (e) {\n        lastProcessedCloseRef.current = null;\n      }\n      setEma9(initEma9);\n      setEma26(initEma26);\n      setLastPrice(closes[closes.length - 1]);\n      setStatus('initialized');\n      // set initial cross\n      const initialCross = initEma9 > initEma26 ? 'bull' : 'bear';\n      if (debug) console.debug('[useEmaCross] initial EMAs', {\n        initEma9,\n        initEma26,\n        initialCross\n      });\n      prevCrossRef.current = initialCross;\n      setCross(initialCross);\n      prevConfirmedRef.current = initialCross;\n      setConfirmedCross(initialCross);\n      setConfirmedSource('init');\n    } catch (err) {\n      setStatus(`init error: ${err.message}`);\n      console.error(err);\n    }\n  }, [symbol, interval, emaShort, emaLong, debug]);\n  const connect = useCallback(async overrideSymbol => {\n    const targetSymbol = (overrideSymbol || symbol).toString();\n    const targetNorm = targetSymbol.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\n    // if a websocket exists for same symbol, no-op\n    if (wsRef.current) {\n      if (currentSymbolRef.current === targetNorm) return;\n      // do NOT close the existing socket here; create a new socket and let the\n      // new socket's onopen handler replace/close the old socket to avoid a\n      // brief disconnected state in the UI.\n    }\n    // Ensure EMA is initialized for the target symbol before connecting\n    try {\n      const targetNorm = targetSymbol.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\n      if (currentSymbolRef.current !== targetNorm || ema9Ref.current == null || ema26Ref.current == null) {\n        await fetchAndInit(targetNorm);\n      }\n    } catch (err) {\n      setStatus(`init error: ${err.message}`);\n      return;\n    }\n    setStatus('connecting websocket');\n    // Use combined stream: kline interval (configurable) + aggTrade for higher-frequency trade updates\n    const klineStream = `${targetNorm.toLowerCase()}@kline_${getBinanceInterval()}`;\n    const tradeStream = `${targetNorm.toLowerCase()}@aggTrade`;\n    const streams = `${klineStream}/${tradeStream}`;\n    // use Binance Futures (USDT-M) websocket (fstream) combined stream\n    const url = `wss://fstream.binance.com/stream?streams=${streams}`;\n    console.log('Connecting websocket for', targetSymbol, 'url=', url);\n    const ws = new WebSocket(url);\n    // Do not overwrite wsRef.current immediately. Create a new socket and only replace the\n    // existing one after the new socket successfully opens. This allows a seamless symbol\n    // switch without briefly showing disconnected state in the UI.\n    const oldWs = wsRef.current;\n    ws.onopen = () => {\n      // mark as successful open\n      reconnectAttemptsRef.current = 0;\n      if (reconnectTimerRef.current) {\n        clearTimeout(reconnectTimerRef.current);\n        reconnectTimerRef.current = null;\n      }\n      // stop polling if it was started while socket was down\n      if (pollingTimerRef.current) {\n        clearInterval(pollingTimerRef.current);\n        pollingTimerRef.current = null;\n      }\n\n      // If there was a previous socket, mark it as replaced so its onclose handler\n      // skips reconnect logic, then close it.\n      try {\n        if (oldWs) {\n          oldWs.__replaced = true;\n          try {\n            oldWs.close();\n          } catch (e) {}\n        }\n      } catch (e) {}\n\n      // now adopt the new socket as the active socket\n      wsRef.current = ws;\n      currentSymbolRef.current = targetNorm;\n      setActiveSymbol(targetNorm);\n      if (debug) console.log('[useEmaCross] websocket open for', targetNorm);\n      setConnected(true);\n      setStatus('connected');\n    };\n    ws.onmessage = ev => {\n      try {\n        const payloadWrapper = JSON.parse(ev.data);\n        // combined stream returns { stream, data }\n        const payload = payloadWrapper.data || payloadWrapper;\n\n        // determine the source symbol for this message (if available)\n        let sourceSymbol = null;\n        try {\n          if (payload && payload.s) sourceSymbol = payload.s.toString().toUpperCase();else if (payloadWrapper && payloadWrapper.stream) {\n            const streamName = payloadWrapper.stream.toString(); // e.g. trxusdt@aggTrade\n            sourceSymbol = streamName.split('@')[0].toUpperCase();\n          }\n        } catch (e) {\n          sourceSymbol = null;\n        }\n\n        // If the message is not for the currently-initialized symbol, ignore it.\n        // NOTE: previously we only ignored messages when currentSymbolRef was set;\n        // that left a small window during symbol switches where messages could be\n        // processed while currentSymbolRef was null. Be stricter: if the message\n        // contains a source symbol it must match the initialized symbol, otherwise\n        // ignore it.\n        if (sourceSymbol) {\n          if (!currentSymbolRef.current || currentSymbolRef.current.toString().toUpperCase() !== sourceSymbol.toString().toUpperCase()) {\n            return; // ignore messages from other symbols or while switching\n          }\n        }\n\n        // aggTrade messages have event type 'aggTrade' and price in p\n        if (debug) {\n          try {\n            const streamName = payloadWrapper.stream || payload.e || 'unknown';\n            console.log('[useEmaCross] incoming', {\n              stream: streamName,\n              sourceSymbol,\n              event: payload.e || null\n            });\n          } catch (e) {}\n        }\n        if (payload.e === 'aggTrade') {\n          const price = parseFloat(payload.p);\n          // update live tick price only; do NOT overwrite the last closed price\n          // which should be used for confirmed alerts.\n          setLastTick(price);\n          if (ema9Ref.current == null || ema26Ref.current == null) return;\n\n          // update EMA using trade price to provide higher-frequency preview\n          const newEma9 = updateEMA(ema9Ref.current, price, emaShort);\n          const newEma26 = updateEMA(ema26Ref.current, price, emaLong);\n          // preview EMAs only\n          ema9Ref.current = newEma9;\n          ema26Ref.current = newEma26;\n          setEma9(newEma9);\n          setEma26(newEma26);\n\n          // Do not update `cross` from trade ticks — keep cross decision tied to closed candles.\n        }\n\n        // kline messages contain a 'k' object\n        if (payload.k) {\n          if (debug) console.log('[useEmaCross] kline payload x=', payload.k.x, 'close=', payload.k.c);\n          const k = payload.k;\n          const close = parseFloat(k.c);\n          // for partial candles, update live tick display; for closed candles\n          // update the confirmed lastPrice (closed price) which will be used\n          // for confirmedCross/notifications.\n          setLastTick(close);\n          setLastCandleClosed(Boolean(k.x));\n\n          // candidate cross detected for this kline (set when closed candle processed)\n          let detectedCross = null;\n          if (ema9Ref.current == null || ema26Ref.current == null) return;\n\n          // update EMA using kline close\n          // For partial candle: update preview EMA only\n          if (!k.x) {\n            const newEma9 = updateEMA(ema9Ref.current, close, emaShort);\n            const newEma26 = updateEMA(ema26Ref.current, close, emaLong);\n            ema9Ref.current = newEma9;\n            ema26Ref.current = newEma26;\n            setEma9(newEma9);\n            setEma26(newEma26);\n          } else {\n            // closed candle: update confirmed EMAs only (and sync preview to confirmed)\n            if (ema9ConfirmedRef.current == null || ema26ConfirmedRef.current == null) {\n              // defensive: fall back to preview if confirmed not initialized\n              ema9ConfirmedRef.current = ema9Ref.current;\n              ema26ConfirmedRef.current = ema26Ref.current;\n            }\n            const prevShort = typeof ema9ConfirmedRef.current === 'number' ? ema9ConfirmedRef.current : null;\n            const prevLong = typeof ema26ConfirmedRef.current === 'number' ? ema26ConfirmedRef.current : null;\n            const newEma9c = updateEMA(ema9ConfirmedRef.current, close, emaShort);\n            const newEma26c = updateEMA(ema26ConfirmedRef.current, close, emaLong);\n            // update confirmed refs\n            ema9ConfirmedRef.current = newEma9c;\n            ema26ConfirmedRef.current = newEma26c;\n            // sync preview to confirmed after closed candle to avoid drift\n            ema9Ref.current = newEma9c;\n            ema26Ref.current = newEma26c;\n            setEma9(newEma9c);\n            setEma26(newEma26c);\n            // closed candle: also record the closed price as the authoritative lastPrice\n            setLastPrice(close);\n            // Determine whether an actual cross occurred between the previous confirmed\n            // EMAs and the newly computed confirmed EMAs. A cross is defined as a\n            // sign change: prevShort <= prevLong && newShort > newLong => golden\n            // prevShort >= prevLong && newShort < newLong => dead\n            detectedCross = null;\n            try {\n              if (prevShort != null && prevLong != null) {\n                if (prevShort <= prevLong && newEma9c > newEma26c) detectedCross = 'bull';else if (prevShort >= prevLong && newEma9c < newEma26c) detectedCross = 'bear';else detectedCross = null; // no crossing event\n              }\n            } catch (e) {\n              detectedCross = null;\n            }\n          }\n\n          // Do not update `cross` for preview/partial candles here; cross will be\n          // determined and updated only when a candle is closed (confirmed).\n          // If candle is closed (k.x === true) and it's a new closed candle, update processed time and set confirmed cross\n          if (Boolean(k.x)) {\n            try {\n              const closeTime = k.T || k.t || null; // k.T is close time in ms\n              if (closeTime && (!lastProcessedCloseRef.current || closeTime > lastProcessedCloseRef.current)) {\n                lastProcessedCloseRef.current = closeTime;\n                // compute confirmed cross using confirmed EMA refs (fallback to preview values)\n                // Only consider a confirmed cross when we detect an actual crossing event\n                // between the previous confirmed EMAs and the newly computed confirmed EMAs.\n                if (debug) console.debug('[useEmaCross] closed candle detected', {\n                  closeTime,\n                  close,\n                  ema9Confirmed: ema9ConfirmedRef.current,\n                  ema26Confirmed: ema26ConfirmedRef.current,\n                  ema9Preview: ema9Ref.current,\n                  ema26Preview: ema26Ref.current,\n                  detectedCross\n                });\n                // If we didn't detect an explicit sign-change event, fall back to\n                // comparing the current confirmed EMAs. This ensures confirmedCross\n                // updates on closed candles even when previous values are not set\n                // or edge-cases occur during initialization.\n                let candidate = detectedCross;\n                if (candidate == null) {\n                  if (ema9ConfirmedRef.current != null && ema26ConfirmedRef.current != null) {\n                    candidate = ema9ConfirmedRef.current > ema26ConfirmedRef.current ? 'bull' : 'bear';\n                  }\n                }\n                if (candidate != null) {\n                  if (candidateConfirmedRef.current === candidate) {\n                    candidateCountRef.current = (candidateCountRef.current || 0) + 1;\n                  } else {\n                    candidateConfirmedRef.current = candidate;\n                    candidateCountRef.current = 1;\n                  }\n                  if (debug) console.debug('[useEmaCross] candidateConfirmed state', {\n                    candidateConfirmed: candidateConfirmedRef.current,\n                    candidateCount: candidateCountRef.current,\n                    required: confirmClosedCandles\n                  });\n                  if (candidateCountRef.current >= confirmClosedCandles) {\n                    if (prevConfirmedRef.current !== candidate) {\n                      prevConfirmedRef.current = candidate;\n                      setConfirmedCross(candidate);\n                      setConfirmedSource('ws');\n                      // also update public `cross` so UI reflects the closed-candle decision\n                      if (prevCrossRef.current !== candidate) {\n                        prevCrossRef.current = candidate;\n                        setCross(candidate);\n                      }\n                    }\n                  }\n                } else {\n                  // No crossing event: reset candidate tracking so we only detect real cross events\n                  candidateConfirmedRef.current = null;\n                  candidateCountRef.current = 0;\n                }\n              }\n            } catch (e) {\n              // fallback: if we couldn't compute confirmed EMAs, fall back to\n              // preview EMAs (if available) to set a confirmed-like value.\n              const fallback = ema9Ref.current != null && ema26Ref.current != null ? ema9Ref.current > ema26Ref.current ? 'bull' : 'bear' : null;\n              if (fallback && prevConfirmedRef.current !== fallback) {\n                prevConfirmedRef.current = fallback;\n                setConfirmedCross(fallback);\n                setConfirmedSource('ws');\n              }\n            }\n          } else {\n            // partial candle: preview already updated above\n          }\n        }\n      } catch (err) {\n        console.error('ws message parse error', err);\n      }\n    };\n    ws.onerror = e => {\n      // if this socket was intentionally replaced by a new one, ignore errors\n      if (ws.__replaced) {\n        if (debug) console.log('[useEmaCross] ignored error on replaced socket');\n        return;\n      }\n      console.error('ws error', e);\n      setStatus('websocket error');\n      // close to trigger backoff reconnect\n      try {\n        ws.close();\n      } catch (err) {}\n    };\n    ws.onclose = () => {\n      // if this socket was intentionally replaced by a new one, skip close handling\n      if (ws.__replaced) {\n        if (debug) console.log('[useEmaCross] websocket was replaced; skipping onclose handling');\n        return;\n      }\n      setConnected(false);\n      setStatus('websocket closed');\n      wsRef.current = null;\n      if (debug) console.log('[useEmaCross] websocket closed');\n\n      // capture intended reconnect target now (before we nullify refs)\n      const reconnectTarget = currentSymbolRef.current || symbol;\n      // clear active symbol immediately for UI, but keep reconnectTarget for retries\n      setActiveSymbol(null);\n\n      // start polling for closed candles while websocket is down\n      try {\n        if (!pollingTimerRef.current) {\n          pollingTimerRef.current = setInterval(async () => {\n            try {\n              const sym = (reconnectTarget || symbol || '').replace(/[^A-Za-z0-9]/g, '').toUpperCase();\n              if (!sym) return;\n              const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${sym}&interval=${getBinanceInterval()}&limit=10`;\n              const res = await fetch(url);\n              if (!res.ok) return;\n              const data = await res.json();\n              // iterate candles in chronological order and process any closed candles newer than lastProcessedCloseRef\n              const newClosed = [];\n              for (const k of data) {\n                const closeTime = k[6];\n                if (closeTime && (!lastProcessedCloseRef.current || closeTime > lastProcessedCloseRef.current)) {\n                  newClosed.push(k);\n                }\n              }\n              if (newClosed.length > 0) {\n                // sort by closeTime asc\n                newClosed.sort((a, b) => a[6] - b[6]);\n                for (const k of newClosed) {\n                  const close = parseFloat(k[4]);\n                  // update EMAs using closed candle\n                  if (ema9Ref.current == null || ema26Ref.current == null) continue;\n                  // update confirmed EMAs using closed candle (polling)\n                  if (ema9ConfirmedRef.current == null || ema26ConfirmedRef.current == null) {\n                    ema9ConfirmedRef.current = ema9Ref.current;\n                    ema26ConfirmedRef.current = ema26Ref.current;\n                  }\n                  const prevShort = typeof ema9ConfirmedRef.current === 'number' ? ema9ConfirmedRef.current : null;\n                  const prevLong = typeof ema26ConfirmedRef.current === 'number' ? ema26ConfirmedRef.current : null;\n                  const newEma9c = updateEMA(ema9ConfirmedRef.current, close, emaShort);\n                  const newEma26c = updateEMA(ema26ConfirmedRef.current, close, emaLong);\n                  ema9ConfirmedRef.current = newEma9c;\n                  ema26ConfirmedRef.current = newEma26c;\n                  // sync preview to confirmed\n                  ema9Ref.current = newEma9c;\n                  ema26Ref.current = newEma26c;\n                  setEma9(newEma9c);\n                  setEma26(newEma26c);\n                  // detect actual crossing event between previous confirmed EMAs and new confirmed EMAs\n                  let detectedCross = null;\n                  try {\n                    if (prevShort != null && prevLong != null) {\n                      if (prevShort <= prevLong && newEma9c > newEma26c) detectedCross = 'bull';else if (prevShort >= prevLong && newEma9c < newEma26c) detectedCross = 'bear';else detectedCross = null;\n                    }\n                  } catch (e) {\n                    detectedCross = null;\n                  }\n                  if (detectedCross != null) {\n                    if (candidateConfirmedRef.current === detectedCross) {\n                      candidateCountRef.current = (candidateCountRef.current || 0) + 1;\n                    } else {\n                      candidateConfirmedRef.current = detectedCross;\n                      candidateCountRef.current = 1;\n                    }\n                    if (candidateCountRef.current >= confirmClosedCandles) {\n                      if (prevConfirmedRef.current !== detectedCross) {\n                        prevConfirmedRef.current = detectedCross;\n                        setConfirmedCross(detectedCross);\n                        setConfirmedSource('poll');\n                        if (prevCrossRef.current !== detectedCross) {\n                          prevCrossRef.current = detectedCross;\n                          setCross(detectedCross);\n                        }\n                      }\n                    }\n                  } else {\n                    candidateConfirmedRef.current = null;\n                    candidateCountRef.current = 0;\n                  }\n                  lastProcessedCloseRef.current = k[6];\n                  // polling provides closed-candle prices, so update authoritative lastPrice\n                  setLastPrice(parseFloat(k[4]));\n                  setLastCandleClosed(true);\n                }\n              }\n            } catch (e) {\n              // ignore polling errors\n            }\n          }, 10 * 1000); // poll every 10s\n        }\n      } catch (e) {}\n\n      // exponential backoff reconnect with jitter\n      const attempt = reconnectAttemptsRef.current || 0;\n      const base = 1000; // 1s\n      const delay = Math.min(30000, base * Math.pow(2, attempt));\n      const jitter = Math.floor(Math.random() * 1000);\n      reconnectAttemptsRef.current = attempt + 1;\n      reconnectTimerRef.current = setTimeout(() => {\n        reconnectTimerRef.current = null;\n        if (!wsRef.current) {\n          // prefer reconnecting to the captured target\n          const target = reconnectTarget || symbol;\n          try {\n            connect(target);\n          } catch (e) {\n            connect(target);\n          }\n        }\n      }, delay + jitter);\n\n      // finally clear the currentSymbolRef to reflect that socket is closed\n      currentSymbolRef.current = null;\n    };\n  }, [symbol, fetchAndInit, debug, interval, emaShort, emaLong, confirmClosedCandles]);\n  const disconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n    setConnected(false);\n    setStatus('disconnected');\n    setActiveSymbol(null);\n    if (pollingTimerRef.current) {\n      clearInterval(pollingTimerRef.current);\n      pollingTimerRef.current = null;\n    }\n    // clear reconnect attempts/timers\n    try {\n      reconnectAttemptsRef.current = 0;\n      if (reconnectTimerRef.current) {\n        clearTimeout(reconnectTimerRef.current);\n        reconnectTimerRef.current = null;\n      }\n    } catch (e) {}\n  }, []);\n  useEffect(() => {\n    // initialize on mount (or when symbol changes)\n    // Reset EMA/cross state for the new symbol, but do NOT forcibly close the existing websocket\n    // to avoid a visible disconnect during a symbol switch. We keep the socket open until the\n    // new connection is established by `connect` (which will replace the old socket).\n    try {\n      // clear reconnect timers and attempts\n      if (reconnectTimerRef.current) {\n        clearTimeout(reconnectTimerRef.current);\n        reconnectTimerRef.current = null;\n      }\n      reconnectAttemptsRef.current = 0;\n\n      // reset refs and state for EMA and cross (prepare for new seed)\n      prevCrossRef.current = null;\n      currentSymbolRef.current = null;\n      ema9Ref.current = null;\n      ema26Ref.current = null;\n      // also clear confirmed/candidate tracking to avoid leaking state between symbols\n      ema9ConfirmedRef.current = null;\n      ema26ConfirmedRef.current = null;\n      prevConfirmedRef.current = null;\n      candidateConfirmedRef.current = null;\n      candidateCountRef.current = 0;\n      lastProcessedCloseRef.current = null;\n      setEma9(null);\n      setEma26(null);\n      setLastPrice(null);\n      setCross(null);\n      setConfirmedCross(null);\n      setLastCandleClosed(false);\n      // Set status to reloading while we fetch/init for the new symbol; do NOT set connected=false here,\n      // so the UI remains 'connected' until the replacement socket opens (smoother UX).\n      setStatus('reloading');\n    } catch (e) {}\n    // fetch history for the (new) symbol and initialize\n    fetchAndInit();\n    // cleanup on unmount\n    return () => {\n      if (wsRef.current) wsRef.current.close();\n      if (pollingTimerRef.current) {\n        clearInterval(pollingTimerRef.current);\n        pollingTimerRef.current = null;\n      }\n    };\n  }, [fetchAndInit]);\n\n  // auto connect after initialization if requested\n  useEffect(() => {\n    if (status === 'initialized' && autoConnect) {\n      // call connect once after initialization\n      connect();\n    }\n    // only run when status or autoConnect changes\n  }, [status, autoConnect, connect]);\n  return {\n    ema9,\n    ema26,\n    lastPrice,\n    lastTick,\n    lastCandleClosed,\n    cross,\n    confirmedCross,\n    confirmedSource,\n    connected,\n    status,\n    connect,\n    disconnect,\n    activeSymbol\n  };\n}\n_s(useEmaCross, \"a4eAubxbflOFr8w3WVW1M3nMptk=\");","map":{"version":3,"names":["useEffect","useRef","useState","useCallback","calculateInitialEMA","updateEMA","useEmaCross","symbol","autoConnect","debug","interval","emaShort","emaLong","confirmClosedCandles","_s","ema9","setEma9","ema26","setEma26","lastPrice","setLastPrice","lastTick","setLastTick","console","e","cross","setCross","confirmedCross","setConfirmedCross","confirmedSource","setConfirmedSource","connected","setConnected","status","setStatus","lastCandleClosed","setLastCandleClosed","activeSymbol","setActiveSymbol","wsRef","prevCrossRef","prevConfirmedRef","candidateConfirmedRef","candidateCountRef","ema9Ref","ema26Ref","ema9ConfirmedRef","ema26ConfirmedRef","reconnectAttemptsRef","reconnectTimerRef","currentSymbolRef","lastProcessedCloseRef","pollingTimerRef","normalizeIntervalForBinance","raw","s","String","trim","toLowerCase","allowed","Set","has","numMatch","match","n","Number","mMatch","hMatch","getBinanceInterval","fetchAndInit","target","t","toString","norm","replace","toUpperCase","bi","url","res","fetch","ok","Error","data","json","closes","map","k","parseFloat","length","shortWindow","Math","max","longWindow","closesLength","initEma9","slice","initEma26","current","initialCross","err","message","error","connect","overrideSymbol","targetSymbol","targetNorm","klineStream","tradeStream","streams","log","ws","WebSocket","oldWs","onopen","clearTimeout","clearInterval","__replaced","close","onmessage","ev","payloadWrapper","JSON","parse","payload","sourceSymbol","stream","streamName","split","event","price","p","newEma9","newEma26","x","c","Boolean","detectedCross","prevShort","prevLong","newEma9c","newEma26c","closeTime","T","ema9Confirmed","ema26Confirmed","ema9Preview","ema26Preview","candidate","candidateConfirmed","candidateCount","required","fallback","onerror","onclose","reconnectTarget","setInterval","sym","newClosed","push","sort","a","b","attempt","base","delay","min","pow","jitter","floor","random","setTimeout","disconnect"],"sources":["C:/Users/e1it3/Desktop/program/binance_alert/src/hooks/useEmaCross.js"],"sourcesContent":["import { useEffect, useRef, useState, useCallback } from 'react';\r\nimport { calculateInitialEMA, updateEMA } from '../utils/ema';\r\n\r\n// Hook options: { symbol }\r\nexport default function useEmaCross({ symbol = 'BTCUSDT', autoConnect = true, debug = false, interval = '1m', emaShort = 9, emaLong = 26, confirmClosedCandles = 1 } = {}) {\r\n  const [ema9, setEma9] = useState(null);\r\n  const [ema26, setEma26] = useState(null);\r\n  const [lastPrice, setLastPrice] = useState(null);\r\n  // lastTick represents the most recent trade/partial-candle price (live preview).\r\n  // lastPrice remains reserved for the most recent CLOSED candle price and is\r\n  // used when emitting confirmed alerts/notifications.\r\n  // eslint-disable-next-line no-unused-vars\r\n  const [lastTick, setLastTick] = useState(null);\r\n\r\n  // when debug is enabled, log lastTick updates so the variable is visibly used\r\n  // inside this module (and also helpful for debugging live preview values).\r\n  useEffect(() => {\r\n    try {\r\n      if (debug && typeof lastTick !== 'undefined' && lastTick !== null) {\r\n        // lightweight debug output\r\n        // eslint-disable-next-line no-console\r\n        console.debug('[useEmaCross] lastTick', lastTick);\r\n      }\r\n    } catch (e) {}\r\n  }, [lastTick, debug]);\r\n  const [cross, setCross] = useState(null); // preview (live) cross\r\n  const [confirmedCross, setConfirmedCross] = useState(null); // only updated on closed candles (confirmed)\r\n  const [confirmedSource, setConfirmedSource] = useState(null); // 'ws' | 'poll' | 'init'\r\n  const [connected, setConnected] = useState(false);\r\n  const [status, setStatus] = useState('idle');\r\n  const [lastCandleClosed, setLastCandleClosed] = useState(false);\r\n  const [activeSymbol, setActiveSymbol] = useState(null); // which symbol the hook has initialized/connected for\r\n\r\n  const wsRef = useRef(null);\r\n  const prevCrossRef = useRef(null);\r\n  const prevConfirmedRef = useRef(null);\r\n  const candidateConfirmedRef = useRef(null);\r\n  const candidateCountRef = useRef(0);\r\n  const ema9Ref = useRef(null);\r\n  const ema26Ref = useRef(null);\r\n  // confirmed EMAs updated only on closed candles (kline.x === true) or polling\r\n  const ema9ConfirmedRef = useRef(null);\r\n  const ema26ConfirmedRef = useRef(null);\r\n  const reconnectAttemptsRef = useRef(0);\r\n  const reconnectTimerRef = useRef(null);\r\n  const currentSymbolRef = useRef(null);\r\n  const lastProcessedCloseRef = useRef(null); // timestamp (ms) of last processed closed candle\r\n  const pollingTimerRef = useRef(null);\r\n\r\n  // Normalize interval strings for Binance API compatibility.\r\n  // Binance accepts tokens like '1m','3m','5m','15m','30m','1h','2h','4h', etc.\r\n  // The app sometimes passes numeric minute strings like '240m' or '240';\r\n  // convert minute multiples of 60 to '4h' style tokens so REST requests don't 400.\r\n  const normalizeIntervalForBinance = (raw) => {\r\n    try {\r\n      let s = String(raw || '').trim();\r\n      if (!s) return s;\r\n      s = s.toLowerCase();\r\n      const allowed = new Set(['1m','3m','5m','15m','30m','1h','2h','4h','6h','8h','12h','1d','3d','1w','1m']);\r\n      if (allowed.has(s)) return s;\r\n      // plain number like '240' -> minutes\r\n      const numMatch = s.match(/^([0-9]+)$/);\r\n      if (numMatch) {\r\n        const n = Number(numMatch[1]);\r\n        if (n % 60 === 0) return `${n/60}h`;\r\n        return `${n}m`;\r\n      }\r\n      // matches like '240m'\r\n      const mMatch = s.match(/^([0-9]+)m$/);\r\n      if (mMatch) {\r\n        const n = Number(mMatch[1]);\r\n        if (n % 60 === 0) return `${n/60}h`;\r\n        return `${n}m`;\r\n      }\r\n      // matches like '4h'\r\n      const hMatch = s.match(/^([0-9]+)h$/);\r\n      if (hMatch) return `${Number(hMatch[1])}h`;\r\n      return s;\r\n    } catch (e) { return String(raw); }\r\n  };\r\n\r\n  const getBinanceInterval = () => normalizeIntervalForBinance(interval);\r\n\r\n  const fetchAndInit = useCallback(async (target = symbol) => {\r\n    try {\r\n      const t = (target || symbol).toString();\r\n      setStatus('fetching historical klines');\r\n      const norm = t.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n  // use Binance Futures (USDT-M) REST endpoint for klines; interval is configurable\r\n  // normalize interval to Binance-accepted token (e.g., convert '240m' -> '4h')\r\n  const bi = getBinanceInterval();\r\n  // request up to 1000 candles to provide long historical context for EMA calculations\r\n  const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${norm}&interval=${bi}&limit=1000`;\r\n    const res = await fetch(url);\r\n      if (!res.ok) throw new Error(`Failed to fetch klines: ${res.status}`);\r\n      const data = await res.json();\r\n      // kline array: [ openTime, open, high, low, close, ... ]\r\n  const closes = data.map((k) => parseFloat(k[4]));\r\n\r\n  if (closes.length < emaLong) throw new Error(`Not enough historical candles to initialize EMA${emaLong}`);\r\n\r\n    // Determine sensible history windows for initial EMA calculation\r\n    const shortWindow = Math.max(emaShort * 10, 100);\r\n    const longWindow = Math.max(emaLong * 12, 300);\r\n\r\n  // Use the close history to compute EMA short/long\r\n  if (debug) console.debug('[useEmaCross] fetchAndInit params', { symbol: norm, interval, emaShort, emaLong, shortWindow, longWindow, closesLength: closes.length });\r\n  const initEma9 = calculateInitialEMA(closes.slice(-shortWindow), emaShort);\r\n  const initEma26 = calculateInitialEMA(closes.slice(-longWindow), emaLong);\r\n\r\n  // initialize both preview and confirmed EMAs from historical closes\r\n  ema9Ref.current = initEma9;\r\n  ema26Ref.current = initEma26;\r\n  ema9ConfirmedRef.current = initEma9;\r\n  ema26ConfirmedRef.current = initEma26;\r\n      // record which symbol these EMAs correspond to\r\n      currentSymbolRef.current = norm;\r\n      setActiveSymbol(norm);\r\n      // record last processed closed candle time (closeTime at index 6)\r\n      try { lastProcessedCloseRef.current = data[data.length - 1][6]; } catch (e) { lastProcessedCloseRef.current = null; }\r\n    setEma9(initEma9);\r\n    setEma26(initEma26);\r\n    setLastPrice(closes[closes.length - 1]);\r\n      setStatus('initialized');\r\n      // set initial cross\r\n    const initialCross = initEma9 > initEma26 ? 'bull' : 'bear';\r\n    if (debug) console.debug('[useEmaCross] initial EMAs', { initEma9, initEma26, initialCross });\r\n      prevCrossRef.current = initialCross;\r\n  setCross(initialCross);\r\n  prevConfirmedRef.current = initialCross;\r\n  setConfirmedCross(initialCross);\r\n  setConfirmedSource('init');\r\n    } catch (err) {\r\n      setStatus(`init error: ${err.message}`);\r\n      console.error(err);\r\n    }\r\n  }, [symbol, interval, emaShort, emaLong, debug]);\r\n\r\n  const connect = useCallback(async (overrideSymbol) => {\r\n    const targetSymbol = (overrideSymbol || symbol).toString();\r\n    const targetNorm = targetSymbol.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n    // if a websocket exists for same symbol, no-op\r\n    if (wsRef.current) {\r\n      if (currentSymbolRef.current === targetNorm) return;\r\n      // do NOT close the existing socket here; create a new socket and let the\r\n      // new socket's onopen handler replace/close the old socket to avoid a\r\n      // brief disconnected state in the UI.\r\n    }\r\n    // Ensure EMA is initialized for the target symbol before connecting\r\n    try {\r\n      const targetNorm = targetSymbol.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n      if (currentSymbolRef.current !== targetNorm || ema9Ref.current == null || ema26Ref.current == null) {\r\n        await fetchAndInit(targetNorm);\r\n      }\r\n    } catch (err) {\r\n      setStatus(`init error: ${err.message}`);\r\n      return;\r\n    }\r\n\r\n    setStatus('connecting websocket');\r\n    // Use combined stream: kline interval (configurable) + aggTrade for higher-frequency trade updates\r\n    const klineStream = `${targetNorm.toLowerCase()}@kline_${getBinanceInterval()}`;\r\n  const tradeStream = `${targetNorm.toLowerCase()}@aggTrade`;\r\n    const streams = `${klineStream}/${tradeStream}`;\r\n  // use Binance Futures (USDT-M) websocket (fstream) combined stream\r\n  const url = `wss://fstream.binance.com/stream?streams=${streams}`;\r\n  console.log('Connecting websocket for', targetSymbol, 'url=', url);\r\n  const ws = new WebSocket(url);\r\n    // Do not overwrite wsRef.current immediately. Create a new socket and only replace the\r\n    // existing one after the new socket successfully opens. This allows a seamless symbol\r\n    // switch without briefly showing disconnected state in the UI.\r\n  const oldWs = wsRef.current;\r\n\r\n    ws.onopen = () => {\r\n      // mark as successful open\r\n      reconnectAttemptsRef.current = 0;\r\n      if (reconnectTimerRef.current) {\r\n        clearTimeout(reconnectTimerRef.current);\r\n        reconnectTimerRef.current = null;\r\n      }\r\n      // stop polling if it was started while socket was down\r\n      if (pollingTimerRef.current) {\r\n        clearInterval(pollingTimerRef.current);\r\n        pollingTimerRef.current = null;\r\n      }\r\n\r\n      // If there was a previous socket, mark it as replaced so its onclose handler\r\n      // skips reconnect logic, then close it.\r\n      try {\r\n        if (oldWs) {\r\n          oldWs.__replaced = true;\r\n          try { oldWs.close(); } catch (e) {}\r\n        }\r\n      } catch (e) {}\r\n\r\n      // now adopt the new socket as the active socket\r\n      wsRef.current = ws;\r\n      currentSymbolRef.current = targetNorm;\r\n      setActiveSymbol(targetNorm);\r\n      if (debug) console.log('[useEmaCross] websocket open for', targetNorm);\r\n  setConnected(true);\r\n  setStatus('connected');\r\n    };\r\n\r\n    ws.onmessage = (ev) => {\r\n      try {\r\n        const payloadWrapper = JSON.parse(ev.data);\r\n        // combined stream returns { stream, data }\r\n        const payload = payloadWrapper.data || payloadWrapper;\r\n\r\n        // determine the source symbol for this message (if available)\r\n        let sourceSymbol = null;\r\n        try {\r\n          if (payload && payload.s) sourceSymbol = payload.s.toString().toUpperCase();\r\n          else if (payloadWrapper && payloadWrapper.stream) {\r\n            const streamName = payloadWrapper.stream.toString(); // e.g. trxusdt@aggTrade\r\n            sourceSymbol = streamName.split('@')[0].toUpperCase();\r\n          }\r\n        } catch (e) { sourceSymbol = null; }\r\n\r\n        // If the message is not for the currently-initialized symbol, ignore it.\r\n        // NOTE: previously we only ignored messages when currentSymbolRef was set;\r\n        // that left a small window during symbol switches where messages could be\r\n        // processed while currentSymbolRef was null. Be stricter: if the message\r\n        // contains a source symbol it must match the initialized symbol, otherwise\r\n        // ignore it.\r\n        if (sourceSymbol) {\r\n          if (!currentSymbolRef.current || currentSymbolRef.current.toString().toUpperCase() !== sourceSymbol.toString().toUpperCase()) {\r\n            return; // ignore messages from other symbols or while switching\r\n          }\r\n        }\r\n\r\n        // aggTrade messages have event type 'aggTrade' and price in p\r\n        if (debug) {\r\n          try {\r\n            const streamName = payloadWrapper.stream || payload.e || 'unknown';\r\n            console.log('[useEmaCross] incoming', { stream: streamName, sourceSymbol, event: payload.e || null });\r\n          } catch (e) {}\r\n        }\r\n        if (payload.e === 'aggTrade') {\r\n          const price = parseFloat(payload.p);\r\n          // update live tick price only; do NOT overwrite the last closed price\r\n          // which should be used for confirmed alerts.\r\n          setLastTick(price);\r\n\r\n          if (ema9Ref.current == null || ema26Ref.current == null) return;\r\n\r\n          // update EMA using trade price to provide higher-frequency preview\r\n          const newEma9 = updateEMA(ema9Ref.current, price, emaShort);\r\n          const newEma26 = updateEMA(ema26Ref.current, price, emaLong);\r\n          // preview EMAs only\r\n          ema9Ref.current = newEma9;\r\n          ema26Ref.current = newEma26;\r\n          setEma9(newEma9);\r\n          setEma26(newEma26);\r\n\r\n          // Do not update `cross` from trade ticks — keep cross decision tied to closed candles.\r\n        }\r\n\r\n        // kline messages contain a 'k' object\r\n        if (payload.k) {\r\n          if (debug) console.log('[useEmaCross] kline payload x=', payload.k.x, 'close=', payload.k.c);\r\n          const k = payload.k;\r\n          const close = parseFloat(k.c);\r\n          // for partial candles, update live tick display; for closed candles\r\n          // update the confirmed lastPrice (closed price) which will be used\r\n          // for confirmedCross/notifications.\r\n          setLastTick(close);\r\n          setLastCandleClosed(Boolean(k.x));\r\n\r\n          // candidate cross detected for this kline (set when closed candle processed)\r\n          let detectedCross = null;\r\n\r\n          if (ema9Ref.current == null || ema26Ref.current == null) return;\r\n\r\n          // update EMA using kline close\r\n          // For partial candle: update preview EMA only\r\n          if (!k.x) {\r\n            const newEma9 = updateEMA(ema9Ref.current, close, emaShort);\r\n            const newEma26 = updateEMA(ema26Ref.current, close, emaLong);\r\n            ema9Ref.current = newEma9;\r\n            ema26Ref.current = newEma26;\r\n            setEma9(newEma9);\r\n            setEma26(newEma26);\r\n            } else {\r\n            // closed candle: update confirmed EMAs only (and sync preview to confirmed)\r\n            if (ema9ConfirmedRef.current == null || ema26ConfirmedRef.current == null) {\r\n              // defensive: fall back to preview if confirmed not initialized\r\n              ema9ConfirmedRef.current = ema9Ref.current;\r\n              ema26ConfirmedRef.current = ema26Ref.current;\r\n            }\r\n            const prevShort = (typeof ema9ConfirmedRef.current === 'number') ? ema9ConfirmedRef.current : null;\r\n            const prevLong = (typeof ema26ConfirmedRef.current === 'number') ? ema26ConfirmedRef.current : null;\r\n            const newEma9c = updateEMA(ema9ConfirmedRef.current, close, emaShort);\r\n            const newEma26c = updateEMA(ema26ConfirmedRef.current, close, emaLong);\r\n            // update confirmed refs\r\n            ema9ConfirmedRef.current = newEma9c;\r\n            ema26ConfirmedRef.current = newEma26c;\r\n            // sync preview to confirmed after closed candle to avoid drift\r\n            ema9Ref.current = newEma9c;\r\n            ema26Ref.current = newEma26c;\r\n            setEma9(newEma9c);\r\n            setEma26(newEma26c);\r\n            // closed candle: also record the closed price as the authoritative lastPrice\r\n            setLastPrice(close);\r\n            // Determine whether an actual cross occurred between the previous confirmed\r\n            // EMAs and the newly computed confirmed EMAs. A cross is defined as a\r\n            // sign change: prevShort <= prevLong && newShort > newLong => golden\r\n            // prevShort >= prevLong && newShort < newLong => dead\r\n            detectedCross = null;\r\n            try {\r\n              if (prevShort != null && prevLong != null) {\r\n                if (prevShort <= prevLong && newEma9c > newEma26c) detectedCross = 'bull';\r\n                else if (prevShort >= prevLong && newEma9c < newEma26c) detectedCross = 'bear';\r\n                else detectedCross = null; // no crossing event\r\n              }\r\n            } catch (e) { detectedCross = null; }\r\n          }\r\n\r\n          // Do not update `cross` for preview/partial candles here; cross will be\r\n          // determined and updated only when a candle is closed (confirmed).\r\n          // If candle is closed (k.x === true) and it's a new closed candle, update processed time and set confirmed cross\r\n          if (Boolean(k.x)) {\r\n            try {\r\n              const closeTime = k.T || k.t || null; // k.T is close time in ms\r\n              if (closeTime && (!lastProcessedCloseRef.current || closeTime > lastProcessedCloseRef.current)) {\r\n                lastProcessedCloseRef.current = closeTime;\r\n                // compute confirmed cross using confirmed EMA refs (fallback to preview values)\r\n                // Only consider a confirmed cross when we detect an actual crossing event\r\n                // between the previous confirmed EMAs and the newly computed confirmed EMAs.\r\n                if (debug) console.debug('[useEmaCross] closed candle detected', { closeTime, close, ema9Confirmed: ema9ConfirmedRef.current, ema26Confirmed: ema26ConfirmedRef.current, ema9Preview: ema9Ref.current, ema26Preview: ema26Ref.current, detectedCross });\r\n                // If we didn't detect an explicit sign-change event, fall back to\r\n                // comparing the current confirmed EMAs. This ensures confirmedCross\r\n                // updates on closed candles even when previous values are not set\r\n                // or edge-cases occur during initialization.\r\n                let candidate = detectedCross;\r\n                if (candidate == null) {\r\n                  if (ema9ConfirmedRef.current != null && ema26ConfirmedRef.current != null) {\r\n                    candidate = (ema9ConfirmedRef.current > ema26ConfirmedRef.current) ? 'bull' : 'bear';\r\n                  }\r\n                }\r\n                if (candidate != null) {\r\n                  if (candidateConfirmedRef.current === candidate) {\r\n                    candidateCountRef.current = (candidateCountRef.current || 0) + 1;\r\n                  } else {\r\n                    candidateConfirmedRef.current = candidate;\r\n                    candidateCountRef.current = 1;\r\n                  }\r\n                  if (debug) console.debug('[useEmaCross] candidateConfirmed state', { candidateConfirmed: candidateConfirmedRef.current, candidateCount: candidateCountRef.current, required: confirmClosedCandles });\r\n                  if (candidateCountRef.current >= confirmClosedCandles) {\r\n                    if (prevConfirmedRef.current !== candidate) {\r\n                      prevConfirmedRef.current = candidate;\r\n                      setConfirmedCross(candidate);\r\n                      setConfirmedSource('ws');\r\n                      // also update public `cross` so UI reflects the closed-candle decision\r\n                      if (prevCrossRef.current !== candidate) {\r\n                        prevCrossRef.current = candidate;\r\n                        setCross(candidate);\r\n                      }\r\n                    }\r\n                  }\r\n                } else {\r\n                  // No crossing event: reset candidate tracking so we only detect real cross events\r\n                  candidateConfirmedRef.current = null;\r\n                  candidateCountRef.current = 0;\r\n                }\r\n                \r\n              }\r\n              } catch (e) {\r\n              // fallback: if we couldn't compute confirmed EMAs, fall back to\r\n              // preview EMAs (if available) to set a confirmed-like value.\r\n              const fallback = (ema9Ref.current != null && ema26Ref.current != null) ? (ema9Ref.current > ema26Ref.current ? 'bull' : 'bear') : null;\r\n              if (fallback && prevConfirmedRef.current !== fallback) {\r\n                prevConfirmedRef.current = fallback;\r\n                setConfirmedCross(fallback);\r\n                setConfirmedSource('ws');\r\n              }\r\n            }\r\n          } else {\r\n            // partial candle: preview already updated above\r\n          }\r\n        }\r\n      } catch (err) {\r\n        console.error('ws message parse error', err);\r\n      }\r\n    };\r\n\r\n    ws.onerror = (e) => {\r\n      // if this socket was intentionally replaced by a new one, ignore errors\r\n      if (ws.__replaced) {\r\n        if (debug) console.log('[useEmaCross] ignored error on replaced socket');\r\n        return;\r\n      }\r\n      console.error('ws error', e);\r\n      setStatus('websocket error');\r\n      // close to trigger backoff reconnect\r\n      try { ws.close(); } catch (err) {}\r\n    };\r\n\r\n    ws.onclose = () => {\r\n      // if this socket was intentionally replaced by a new one, skip close handling\r\n      if (ws.__replaced) {\r\n        if (debug) console.log('[useEmaCross] websocket was replaced; skipping onclose handling');\r\n        return;\r\n      }\r\n      setConnected(false);\r\n      setStatus('websocket closed');\r\n      wsRef.current = null;\r\n      if (debug) console.log('[useEmaCross] websocket closed');\r\n\r\n      // capture intended reconnect target now (before we nullify refs)\r\n      const reconnectTarget = currentSymbolRef.current || symbol;\r\n      // clear active symbol immediately for UI, but keep reconnectTarget for retries\r\n      setActiveSymbol(null);\r\n\r\n      // start polling for closed candles while websocket is down\r\n      try {\r\n        if (!pollingTimerRef.current) {\r\n              pollingTimerRef.current = setInterval(async () => {\r\n            try {\r\n              const sym = (reconnectTarget || symbol || '').replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n              if (!sym) return;\r\n                  const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${sym}&interval=${getBinanceInterval()}&limit=10`;\r\n              const res = await fetch(url);\r\n              if (!res.ok) return;\r\n              const data = await res.json();\r\n              // iterate candles in chronological order and process any closed candles newer than lastProcessedCloseRef\r\n              const newClosed = [];\r\n              for (const k of data) {\r\n                const closeTime = k[6];\r\n                if (closeTime && (!lastProcessedCloseRef.current || closeTime > lastProcessedCloseRef.current)) {\r\n                  newClosed.push(k);\r\n                }\r\n              }\r\n                if (newClosed.length > 0) {\r\n                // sort by closeTime asc\r\n                newClosed.sort((a, b) => a[6] - b[6]);\r\n                  for (const k of newClosed) {\r\n                  const close = parseFloat(k[4]);\r\n                  // update EMAs using closed candle\r\n                  if (ema9Ref.current == null || ema26Ref.current == null) continue;\r\n                  // update confirmed EMAs using closed candle (polling)\r\n                  if (ema9ConfirmedRef.current == null || ema26ConfirmedRef.current == null) {\r\n                    ema9ConfirmedRef.current = ema9Ref.current;\r\n                    ema26ConfirmedRef.current = ema26Ref.current;\r\n                  }\r\n                  const prevShort = (typeof ema9ConfirmedRef.current === 'number') ? ema9ConfirmedRef.current : null;\r\n                  const prevLong = (typeof ema26ConfirmedRef.current === 'number') ? ema26ConfirmedRef.current : null;\r\n                  const newEma9c = updateEMA(ema9ConfirmedRef.current, close, emaShort);\r\n                  const newEma26c = updateEMA(ema26ConfirmedRef.current, close, emaLong);\r\n                  ema9ConfirmedRef.current = newEma9c;\r\n                  ema26ConfirmedRef.current = newEma26c;\r\n                  // sync preview to confirmed\r\n                  ema9Ref.current = newEma9c;\r\n                  ema26Ref.current = newEma26c;\r\n                  setEma9(newEma9c);\r\n                  setEma26(newEma26c);\r\n                  // detect actual crossing event between previous confirmed EMAs and new confirmed EMAs\r\n                  let detectedCross = null;\r\n                  try {\r\n                    if (prevShort != null && prevLong != null) {\r\n                      if (prevShort <= prevLong && newEma9c > newEma26c) detectedCross = 'bull';\r\n                      else if (prevShort >= prevLong && newEma9c < newEma26c) detectedCross = 'bear';\r\n                      else detectedCross = null;\r\n                    }\r\n                  } catch (e) { detectedCross = null; }\r\n                  if (detectedCross != null) {\r\n                    if (candidateConfirmedRef.current === detectedCross) {\r\n                      candidateCountRef.current = (candidateCountRef.current || 0) + 1;\r\n                    } else {\r\n                      candidateConfirmedRef.current = detectedCross;\r\n                      candidateCountRef.current = 1;\r\n                    }\r\n                    if (candidateCountRef.current >= confirmClosedCandles) {\r\n                      if (prevConfirmedRef.current !== detectedCross) {\r\n                        prevConfirmedRef.current = detectedCross;\r\n                        setConfirmedCross(detectedCross);\r\n                        setConfirmedSource('poll');\r\n                        if (prevCrossRef.current !== detectedCross) {\r\n                          prevCrossRef.current = detectedCross;\r\n                          setCross(detectedCross);\r\n                        }\r\n                      }\r\n                    }\r\n                  } else {\r\n                    candidateConfirmedRef.current = null;\r\n                    candidateCountRef.current = 0;\r\n                  }\r\n                  lastProcessedCloseRef.current = k[6];\r\n                  // polling provides closed-candle prices, so update authoritative lastPrice\r\n                  setLastPrice(parseFloat(k[4]));\r\n                  setLastCandleClosed(true);\r\n                }\r\n              }\r\n            } catch (e) {\r\n              // ignore polling errors\r\n            }\r\n          }, 10 * 1000); // poll every 10s\r\n        }\r\n      } catch (e) {}\r\n\r\n      // exponential backoff reconnect with jitter\r\n      const attempt = reconnectAttemptsRef.current || 0;\r\n      const base = 1000; // 1s\r\n      const delay = Math.min(30000, base * Math.pow(2, attempt));\r\n      const jitter = Math.floor(Math.random() * 1000);\r\n      reconnectAttemptsRef.current = attempt + 1;\r\n      reconnectTimerRef.current = setTimeout(() => {\r\n        reconnectTimerRef.current = null;\r\n        if (!wsRef.current) {\r\n          // prefer reconnecting to the captured target\r\n          const target = reconnectTarget || symbol;\r\n          try { connect(target); } catch (e) { connect(target); }\r\n        }\r\n      }, delay + jitter);\r\n\r\n      // finally clear the currentSymbolRef to reflect that socket is closed\r\n      currentSymbolRef.current = null;\r\n    };\r\n  }, [symbol, fetchAndInit, debug, interval, emaShort, emaLong, confirmClosedCandles]);\r\n\r\n  const disconnect = useCallback(() => {\r\n    if (wsRef.current) {\r\n      wsRef.current.close();\r\n      wsRef.current = null;\r\n    }\r\n    setConnected(false);\r\n    setStatus('disconnected');\r\n    setActiveSymbol(null);\r\n    if (pollingTimerRef.current) {\r\n      clearInterval(pollingTimerRef.current);\r\n      pollingTimerRef.current = null;\r\n    }\r\n    // clear reconnect attempts/timers\r\n    try {\r\n      reconnectAttemptsRef.current = 0;\r\n      if (reconnectTimerRef.current) {\r\n        clearTimeout(reconnectTimerRef.current);\r\n        reconnectTimerRef.current = null;\r\n      }\r\n    } catch (e) {}\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    // initialize on mount (or when symbol changes)\r\n    // Reset EMA/cross state for the new symbol, but do NOT forcibly close the existing websocket\r\n    // to avoid a visible disconnect during a symbol switch. We keep the socket open until the\r\n    // new connection is established by `connect` (which will replace the old socket).\r\n    try {\r\n      // clear reconnect timers and attempts\r\n      if (reconnectTimerRef.current) {\r\n        clearTimeout(reconnectTimerRef.current);\r\n        reconnectTimerRef.current = null;\r\n      }\r\n      reconnectAttemptsRef.current = 0;\r\n\r\n      // reset refs and state for EMA and cross (prepare for new seed)\r\n      prevCrossRef.current = null;\r\n      currentSymbolRef.current = null;\r\n      ema9Ref.current = null;\r\n      ema26Ref.current = null;\r\n      // also clear confirmed/candidate tracking to avoid leaking state between symbols\r\n      ema9ConfirmedRef.current = null;\r\n      ema26ConfirmedRef.current = null;\r\n      prevConfirmedRef.current = null;\r\n      candidateConfirmedRef.current = null;\r\n      candidateCountRef.current = 0;\r\n      lastProcessedCloseRef.current = null;\r\n      setEma9(null);\r\n      setEma26(null);\r\n      setLastPrice(null);\r\n      setCross(null);\r\n      setConfirmedCross(null);\r\n      setLastCandleClosed(false);\r\n      // Set status to reloading while we fetch/init for the new symbol; do NOT set connected=false here,\r\n      // so the UI remains 'connected' until the replacement socket opens (smoother UX).\r\n      setStatus('reloading');\r\n    } catch (e) {}\r\n    // fetch history for the (new) symbol and initialize\r\n    fetchAndInit();\r\n    // cleanup on unmount\r\n    return () => {\r\n      if (wsRef.current) wsRef.current.close();\r\n      if (pollingTimerRef.current) {\r\n        clearInterval(pollingTimerRef.current);\r\n        pollingTimerRef.current = null;\r\n      }\r\n    };\r\n  }, [fetchAndInit]);\r\n\r\n  // auto connect after initialization if requested\r\n  useEffect(() => {\r\n    if (status === 'initialized' && autoConnect) {\r\n      // call connect once after initialization\r\n      connect();\r\n    }\r\n    // only run when status or autoConnect changes\r\n  }, [status, autoConnect, connect]);\r\n\r\n  return {\r\n    ema9,\r\n    ema26,\r\n    lastPrice,\r\n    lastTick,\r\n    lastCandleClosed,\r\n    cross,\r\n    confirmedCross,\r\n    confirmedSource,\r\n    connected,\r\n    status,\r\n    connect,\r\n    disconnect,\r\n    activeSymbol,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}