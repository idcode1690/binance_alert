{"ast":null,"code":"import { calculateInitialEMA, updateEMA } from './ema';\n\n// Small helper sleep\nfunction sleep(ms) {\n  return new Promise(r => setTimeout(r, ms));\n}\n\n// Normalize symbol\nfunction normSym(s) {\n  return (s || '').toString().replace(/[^A-Za-z0-9]/g, '').toUpperCase();\n}\n\n// Scan a single symbol for a cross between shortPeriod and longPeriod on the given interval\n// Returns { symbol, crossed: true/false, direction: 'bull'|'bear'|null, price, when, error }\nexport async function scanSymbolForCross(symbol, {\n  interval = '5m',\n  shortPeriod = 26,\n  longPeriod = 200,\n  limit = 500\n} = {}) {\n  const s = normSym(symbol);\n  if (!s) return {\n    symbol,\n    error: 'invalid symbol'\n  };\n  try {\n    const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${s}&interval=${interval}&limit=${limit}`;\n    const res = await fetch(url);\n    if (!res.ok) return {\n      symbol: s,\n      error: `klines fetch failed ${res.status}`\n    };\n    const data = await res.json();\n    const closes = (data || []).map(k => parseFloat(k[4]));\n    if (!Array.isArray(closes) || closes.length < longPeriod + 1) {\n      return {\n        symbol: s,\n        error: `not enough candles (${closes.length}) for long period ${longPeriod}`\n      };\n    }\n\n    // compute EMA before last closed candle (use closes up to second-last)\n    const before = closes.slice(0, -1);\n    const lastClose = closes[closes.length - 1];\n    const emaShortBefore = calculateInitialEMA(before.slice(-Math.max(before.length, longPeriod + 10)), shortPeriod);\n    const emaLongBefore = calculateInitialEMA(before.slice(-Math.max(before.length, longPeriod + 10)), longPeriod);\n\n    // if calculateInitialEMA can't compute because not enough length, fall back to full before\n    // but calculateInitialEMA already expects array length >= period\n\n    const emaShortAfter = updateEMA(emaShortBefore, lastClose, shortPeriod);\n    const emaLongAfter = updateEMA(emaLongBefore, lastClose, longPeriod);\n    const crossBefore = emaShortBefore > emaLongBefore ? 'bull' : 'bear';\n    const crossAfter = emaShortAfter > emaLongAfter ? 'bull' : 'bear';\n    const crossed = crossBefore !== crossAfter;\n    const direction = crossed ? crossAfter : null;\n    const when = data && data.length > 0 ? new Date(data[data.length - 1][6]).toISOString() : new Date().toISOString();\n    return {\n      symbol: s,\n      crossed,\n      direction,\n      price: lastClose,\n      when\n    };\n  } catch (err) {\n    return {\n      symbol: s,\n      error: String(err)\n    };\n  }\n}\n\n// Run a sequential scan over symbols with delay between requests to avoid rate limits.\n// onUpdate is called per-symbol with the result object; returns a controller with stop().\nexport function startScanner(symbols, {\n  interval = '5m',\n  shortPeriod = 26,\n  longPeriod = 200,\n  limit = 500,\n  delayMs = 500\n} = {}, onUpdate) {\n  let stopped = false;\n  async function runOnce() {\n    for (const raw of symbols) {\n      if (stopped) break;\n      const s = normSym(raw);\n      const res = await scanSymbolForCross(s, {\n        interval,\n        shortPeriod,\n        longPeriod,\n        limit\n      });\n      try {\n        onUpdate && onUpdate(res);\n      } catch (e) {}\n      // delay to avoid bursting requests (rate limit protection)\n      if (stopped) break;\n      await sleep(delayMs);\n    }\n  }\n  let loopPromise = null;\n  async function loop() {\n    while (!stopped) {\n      await runOnce();\n      // after one full pass, wait a bit before next full pass\n      for (let i = 0; i < 10 && !stopped; i++) {\n        await sleep(1000);\n      }\n    }\n  }\n  loopPromise = loop();\n  return {\n    stop() {\n      stopped = true;\n    },\n    isStopped() {\n      return stopped;\n    },\n    promise: loopPromise\n  };\n}","map":{"version":3,"names":["calculateInitialEMA","updateEMA","sleep","ms","Promise","r","setTimeout","normSym","s","toString","replace","toUpperCase","scanSymbolForCross","symbol","interval","shortPeriod","longPeriod","limit","error","url","res","fetch","ok","status","data","json","closes","map","k","parseFloat","Array","isArray","length","before","slice","lastClose","emaShortBefore","Math","max","emaLongBefore","emaShortAfter","emaLongAfter","crossBefore","crossAfter","crossed","direction","when","Date","toISOString","price","err","String","startScanner","symbols","delayMs","onUpdate","stopped","runOnce","raw","e","loopPromise","loop","i","stop","isStopped","promise"],"sources":["C:/Users/e1it3/Desktop/program/binance_alert/src/utils/scanner.js"],"sourcesContent":["import { calculateInitialEMA, updateEMA } from './ema';\r\n\r\n// Small helper sleep\r\nfunction sleep(ms) {\r\n  return new Promise((r) => setTimeout(r, ms));\r\n}\r\n\r\n// Normalize symbol\r\nfunction normSym(s) {\r\n  return (s || '').toString().replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n}\r\n\r\n// Scan a single symbol for a cross between shortPeriod and longPeriod on the given interval\r\n// Returns { symbol, crossed: true/false, direction: 'bull'|'bear'|null, price, when, error }\r\nexport async function scanSymbolForCross(symbol, { interval = '5m', shortPeriod = 26, longPeriod = 200, limit = 500 } = {}) {\r\n  const s = normSym(symbol);\r\n  if (!s) return { symbol, error: 'invalid symbol' };\r\n  try {\r\n    const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${s}&interval=${interval}&limit=${limit}`;\r\n    const res = await fetch(url);\r\n    if (!res.ok) return { symbol: s, error: `klines fetch failed ${res.status}` };\r\n    const data = await res.json();\r\n    const closes = (data || []).map((k) => parseFloat(k[4]));\r\n    if (!Array.isArray(closes) || closes.length < longPeriod + 1) {\r\n      return { symbol: s, error: `not enough candles (${closes.length}) for long period ${longPeriod}` };\r\n    }\r\n\r\n    // compute EMA before last closed candle (use closes up to second-last)\r\n    const before = closes.slice(0, -1);\r\n    const lastClose = closes[closes.length - 1];\r\n\r\n    const emaShortBefore = calculateInitialEMA(before.slice(-Math.max(before.length, longPeriod + 10)), shortPeriod);\r\n    const emaLongBefore = calculateInitialEMA(before.slice(-Math.max(before.length, longPeriod + 10)), longPeriod);\r\n\r\n    // if calculateInitialEMA can't compute because not enough length, fall back to full before\r\n    // but calculateInitialEMA already expects array length >= period\r\n\r\n    const emaShortAfter = updateEMA(emaShortBefore, lastClose, shortPeriod);\r\n    const emaLongAfter = updateEMA(emaLongBefore, lastClose, longPeriod);\r\n\r\n    const crossBefore = emaShortBefore > emaLongBefore ? 'bull' : 'bear';\r\n    const crossAfter = emaShortAfter > emaLongAfter ? 'bull' : 'bear';\r\n\r\n    const crossed = crossBefore !== crossAfter;\r\n    const direction = crossed ? crossAfter : null;\r\n    const when = (data && data.length > 0) ? new Date(data[data.length - 1][6]).toISOString() : new Date().toISOString();\r\n\r\n    return { symbol: s, crossed, direction, price: lastClose, when };\r\n  } catch (err) {\r\n    return { symbol: s, error: String(err) };\r\n  }\r\n}\r\n\r\n// Run a sequential scan over symbols with delay between requests to avoid rate limits.\r\n// onUpdate is called per-symbol with the result object; returns a controller with stop().\r\nexport function startScanner(symbols, { interval = '5m', shortPeriod = 26, longPeriod = 200, limit = 500, delayMs = 500 } = {}, onUpdate) {\r\n  let stopped = false;\r\n\r\n  async function runOnce() {\r\n    for (const raw of symbols) {\r\n      if (stopped) break;\r\n      const s = normSym(raw);\r\n      const res = await scanSymbolForCross(s, { interval, shortPeriod, longPeriod, limit });\r\n      try { onUpdate && onUpdate(res); } catch (e) {}\r\n      // delay to avoid bursting requests (rate limit protection)\r\n      if (stopped) break;\r\n      await sleep(delayMs);\r\n    }\r\n  }\r\n\r\n  let loopPromise = null;\r\n  async function loop() {\r\n    while (!stopped) {\r\n      await runOnce();\r\n      // after one full pass, wait a bit before next full pass\r\n      for (let i = 0; i < 10 && !stopped; i++) {\r\n        await sleep(1000);\r\n      }\r\n    }\r\n  }\r\n\r\n  loopPromise = loop();\r\n\r\n  return {\r\n    stop() { stopped = true; },\r\n    isStopped() { return stopped; },\r\n    promise: loopPromise,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}