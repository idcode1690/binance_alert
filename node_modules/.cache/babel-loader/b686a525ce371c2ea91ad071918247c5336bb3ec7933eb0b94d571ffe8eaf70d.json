{"ast":null,"code":"import _objectSpread from\"C:/Users/e1it3/Desktop/program/binance_alert/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// Optimized singleton scanner manager to run scans independent of React component lifecycle.\nconst scannerManager=(()=>{let running=false;let currentSymbol=null;let scanType=null;let progress={done:0,total:0};let results=[];// activeMatches: map of symbol -> active match info for real-time monitoring\nlet activeMatches={};try{if(typeof window!=='undefined'&&window.localStorage){const raw=window.localStorage.getItem('scannerResults');if(raw)results=JSON.parse(raw)||[];}}catch(e){results=[];}let cancel=false;let scanStartTime=null;let currentAbortControllers=new Set();let listeners=new Set();let getSymbolsFn=null;let workerInstance=null;// throttle notifications to reduce render overhead\nlet lastNotifyTs=0;let pendingNotify=false;function stateSnapshot(){return{running,currentSymbol,scanType,progress:_objectSpread({},progress),results:results.slice(),active:Object.values(activeMatches),scanStartTime};}function notifyNow(){const s=stateSnapshot();for(const cb of listeners){try{cb(s);}catch(e){}}try{if(typeof window!=='undefined'&&window.localStorage){window.localStorage.setItem('scannerResults',JSON.stringify(results.slice(0,200)));}}catch(e){}}function notifyThrottled(){let force=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;try{const now=Date.now();// If the page is hidden (background tab), don't rely on setTimeout-based throttling\n// which browsers may clamp heavily; instead deliver notifications synchronously so\n// the React state held by listeners stays up-to-date when the tab becomes visible.\nconst isHidden=typeof document!=='undefined'&&document.hidden;if(isHidden){lastNotifyTs=now;pendingNotify=false;notifyNow();return;}if(force||now-lastNotifyTs>=100){lastNotifyTs=now;pendingNotify=false;notifyNow();return;}if(!pendingNotify){pendingNotify=true;const wait=Math.max(0,100-(now-lastNotifyTs));setTimeout(()=>{lastNotifyTs=Date.now();pendingNotify=false;notifyNow();},wait);}}catch(e){try{notifyNow();}catch(e2){}}}function onUpdate(cb){listeners.add(cb);return()=>listeners.delete(cb);}function setGetSymbols(fn){getSymbolsFn=fn;}const sleep=ms=>new Promise(r=>setTimeout(r,ms));function calculateEma(values,period){if(!Array.isArray(values)||values.length===0)return[];const k=2/(period+1);const out=[];let ema=null;for(let i=0;i<values.length;i++){const v=Number(values[i]);if(isNaN(v)){out.push(null);continue;}if(ema===null){if(i+1>=period){const slice=values.slice(i+1-period,i+1).map(Number);ema=slice.reduce((a,b)=>a+b,0)/period;out.push(ema);}else{out.push(null);}}else{ema=v*k+ema*(1-k);out.push(ema);}}return out;}async function start(type){let opts=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(running)return;try{console.log('[scannerManager] start called',{type,opts});}catch(e){}if(typeof getSymbolsFn!=='function')throw new Error('scannerManager: getSymbolsFn not set');running=true;cancel=false;results=[];progress={done:0,total:0};currentSymbol=null;scanType=type||null;scanStartTime=Date.now();notifyThrottled(true);const list=(await Promise.resolve(getSymbolsFn()))||[];let interval=opts&&typeof opts.interval!=='undefined'?opts.interval:'5m';if(typeof interval==='number'||typeof interval==='string'&&/^\\d+$/.test(String(interval)))interval=\"\".concat(interval,\"m\");const emaShort=opts&&typeof opts.emaShort!=='undefined'?parseInt(opts.emaShort,10):26;const emaLong=opts&&typeof opts.emaLong!=='undefined'?parseInt(opts.emaLong,10):200;// Normalize / sanitize incoming symbol list to reduce typos like 'BTCSTUSDT'\nconst sanitizeSymbol=raw=>{if(!raw)return'';try{let s=String(raw).toUpperCase();// strip any non-alphanumeric chars\ns=s.replace(/[^A-Z0-9]/g,'');// collapse repeated USDT occurrences (e.g. 'BTCUSDTUSDT' -> 'BTCUSDT')\ns=s.replace(/(USDT)+$/g,'USDT');s=s.replace(/USDTUSDT/g,'USDT');// If the result doesn't end with USDT it's not a futures symbol we care about\nif(!/USDT$/.test(s))return'';// Basic sanity: symbol length should be reasonable\nif(s.length<6||s.length>12)return'';return s;}catch(e){return'';}};// Build a unique, normalized filtered list to use for API calls.\nconst normalized=[];if(Array.isArray(list)){const seen=new Set();for(const it of list){const n=sanitizeSymbol(it);if(!n)continue;if(seen.has(n))continue;seen.add(n);normalized.push(n);}}const filtered=normalized;// Validate symbols against Binance exchangeInfo to avoid scanning invalid/typo symbols\nprogress.total=filtered.length;notifyThrottled(true);try{const infoUrl='https://fapi.binance.com/fapi/v1/exchangeInfo';const infoResp=await fetch(infoUrl,{cf:{cacheTtl:600}});if(infoResp&&infoResp.ok){const info=await infoResp.json().catch(()=>null);if(info&&Array.isArray(info.symbols)){const validSet=new Set(info.symbols.map(s=>String(s.symbol).toUpperCase()));const before=filtered.length;const cleaned=filtered.map(s=>String(s).toUpperCase()).filter(s=>validSet.has(s));if(cleaned.length!==before){try{console.log('[scannerManager] removed invalid symbols',{before,after:cleaned.length});}catch(e){}}// use cleaned list (preserve case as original list may vary)\nconst cleanedMap=new Map();filtered.forEach(s=>cleanedMap.set(String(s).toUpperCase(),s));const finalList=cleaned.map(su=>cleanedMap.get(su)||su);// replace filtered variable\n// eslint-disable-next-line no-param-reassign\nfiltered.length=0;Array.prototype.push.apply(filtered,finalList);progress.total=filtered.length;notifyThrottled(true);}}}catch(e){try{console.warn('[scannerManager] exchangeInfo fetch failed',e&&e.message?e.message:e);}catch(e2){}}const endpointBase='https://fapi.binance.com/fapi/v1/klines';// Try to delegate scanning to dedicated worker (served at /worker-scanner.js)\nconst symbolsArray=Array.isArray(list)?list:[];// Only delegate to the dedicated worker for single-run scans.\n// For continuous monitoring (`opts.monitor`), run inline loop to allow repeated passes.\ntry{console.log('[scannerManager] monitorMode?',!!(opts&&opts.monitor));}catch(e){}if(!opts.monitor&&typeof Worker!=='undefined'&&typeof window!=='undefined'){try{workerInstance=new Worker('/worker-scanner.js');let workerReady=false;const onMsg=ev=>{const m=ev.data||{};if(m.type==='started'){workerReady=true;progress.total=m.total||progress.total;notifyThrottled(true);}else if(m.type==='progress'){workerReady=true;progress.done=m.done||progress.done;currentSymbol=m.currentSymbol||currentSymbol;notifyThrottled();}else if(m.type==='match'&&m.ev){workerReady=true;results.unshift(m.ev);if(results.length>500)results=results.slice(0,500);notifyThrottled();}else if(m.type==='done'){// worker finished its task\ntry{workerInstance.terminate();}catch(e){}workerInstance=null;running=false;currentSymbol=null;cancel=false;scanStartTime=null;notifyThrottled(true);}else if(m.type==='stopped'){try{workerInstance.terminate();}catch(e){}workerInstance=null;running=false;currentSymbol=null;cancel=false;scanStartTime=null;notifyThrottled(true);}};workerInstance.addEventListener('message',onMsg);workerInstance.addEventListener('error',err=>{try{console.warn('scanner worker error',err);}catch(e){}});// send start command with symbols and options\ntry{workerInstance.postMessage({cmd:'start',symbols:symbolsArray,opts,scanType:type});}catch(e){/* ignore */}// Wait briefly for the worker to acknowledge (avoid stuck 'Scanning: ...' if worker asset missing or blocked)\nconst waitMs=2000;await new Promise(resolve=>{const to=setTimeout(()=>{if(!workerReady){try{workerInstance.removeEventListener('message',onMsg);}catch(e){}try{workerInstance.terminate();}catch(e){}workerInstance=null;}resolve();},waitMs);// if worker signals readiness before timeout, resolve early\nconst early=()=>{clearTimeout(to);resolve();};const checkInterval=setInterval(()=>{if(workerReady){clearInterval(checkInterval);early();}},50);});// If worker started and is handling the scan, return early\nif(workerInstance){// worker is active and will manage scanning\nreturn;}// else fallthrough to inline scanner\n}catch(e){try{if(workerInstance){workerInstance.terminate();workerInstance=null;}}catch(e2){}// fallthrough to inline scanner\n}}const concurrencyDefault=opts&&typeof opts.concurrency==='number'?Math.max(1,opts.concurrency):8;const batchDelayBase=opts&&typeof opts.batchDelay==='number'?Math.max(0,opts.batchDelay):120;let concurrencyCurrent=concurrencyDefault;let batchDelayCurrent=batchDelayBase;const maxConcurrency=opts&&typeof opts.maxConcurrency==='number'?Math.max(1,opts.maxConcurrency):12;let backoffCount=0;let consecutiveSuccesses=0;const successThreshold=opts&&typeof opts.rampSuccessThreshold==='number'?Math.max(1,opts.rampSuccessThreshold):3;const minBatchDelay=opts&&typeof opts.minBatchDelay==='number'?Math.max(50,opts.minBatchDelay):60;const neededCandles=Math.max(emaShort,emaLong)+10;// Allow caller to request a specific kline limit (e.g., 200). If not provided,\n// fall back to previous heuristic which ensured at least ~120 candles.\nconst klineLimitOpt=opts&&typeof opts.klineLimit==='number'?Math.max(0,parseInt(opts.klineLimit,10)):null;const candleLimit=Number.isFinite(klineLimitOpt)&&klineLimitOpt>0?Math.min(1000,Math.max(klineLimitOpt,neededCandles+1)):Math.min(1000,Math.max(neededCandles+10,120));const processSymbol=async sym=>{if(cancel)return;currentSymbol=sym;notifyThrottled();const url=\"\".concat(endpointBase,\"?symbol=\").concat(encodeURIComponent(sym),\"&interval=\").concat(encodeURIComponent(interval),\"&limit=\").concat(candleLimit);let localAbort=null;try{localAbort=new AbortController();currentAbortControllers.add(localAbort);}catch(e){}try{const r=await fetch(url,localAbort?{signal:localAbort.signal}:undefined);if(!r.ok){// Too many requests -> backoff and retry later\nif(r.status===429){backoffCount+=1;consecutiveSuccesses=0;concurrencyCurrent=Math.max(1,Math.floor(concurrencyCurrent*0.6));batchDelayCurrent=Math.min(30000,Math.floor(batchDelayCurrent*1.6));const backoffMs=Math.min(30000,1000*Math.pow(2,Math.min(backoffCount,6))+Math.floor(Math.random()*1000));await sleep(backoffMs);return;}// Bad request often means an invalid symbol (typo or delisted). Remove it to avoid repeated 400s.\nif(r.status===400){try{console.warn('[scannerManager] removing invalid symbol due to 400',sym);}catch(e){}try{const idx=filtered.indexOf(sym);if(idx!==-1){filtered.splice(idx,1);progress.total=filtered.length;notifyThrottled(true);}}catch(e){}return;}return;}const data=await r.json();backoffCount=Math.max(0,backoffCount-1);consecutiveSuccesses+=1;if(consecutiveSuccesses>=successThreshold){consecutiveSuccesses=0;if(concurrencyCurrent<maxConcurrency)concurrencyCurrent+=1;batchDelayCurrent=Math.max(minBatchDelay,Math.floor(batchDelayCurrent*0.85));}const closes=Array.isArray(data)?data.map(d=>parseFloat(d[4])):[];// require one extra candle so we can use the last closed candle (avoid counting the live/open candle)\nif(!Array.isArray(closes)||closes.length<neededCandles+1)return;const emaShortArr=calculateEma(closes,emaShort);const emaLongArr=calculateEma(closes,emaLong);const lastClosedIdx=closes.length-2;const prevIdx=lastClosedIdx-1;const prevShort=emaShortArr[prevIdx];const prevLong=emaLongArr[prevIdx];const lastShort=emaShortArr[lastClosedIdx];const lastLong=emaLongArr[lastClosedIdx];let matched=false;if(typeof prevShort==='number'&&typeof prevLong==='number'&&typeof lastShort==='number'&&typeof lastLong==='number'){if(scanType==='golden')matched=prevShort<=prevLong&&lastShort>lastLong;else if(scanType==='dead')matched=prevShort>=prevLong&&lastShort<lastLong;}const lastVolume=Array.isArray(data)&&data[lastClosedIdx]&&data[lastClosedIdx][5]!=null?parseFloat(data[lastClosedIdx][5]):0;// Real-time monitoring behavior: maintain activeMatches map. When a symbol becomes matched, add it; when it stops matching, remove it.\nif(matched){try{console.log('[scannerManager] match detected',sym,{scanType,emaShort,emaLong});}catch(e){}if(!activeMatches[sym]){const ev={id:\"\".concat(sym,\"-\").concat(Date.now(),\"-\").concat(Math.random().toString(36).slice(2,8)),symbol:sym,prevShort,prevLong,lastShort,lastLong,time:new Date().toLocaleString(),interval,emaShort,emaLong,type:scanType,volume:lastVolume};activeMatches[sym]=ev;// also keep history results for reference\nresults.unshift(ev);if(results.length>500)results=results.slice(0,500);notifyThrottled();try{console.log('[scannerManager] active add',sym);}catch(e){}}else{// update existing active entry with latest values\nactiveMatches[sym]=_objectSpread(_objectSpread({},activeMatches[sym]),{},{prevShort,prevLong,lastShort,lastLong,time:new Date().toLocaleString(),volume:lastVolume});try{console.log('[scannerManager] active update',sym);}catch(e){}}}else{if(activeMatches[sym]){try{console.log('[scannerManager] match cleared',sym);}catch(e){}delete activeMatches[sym];notifyThrottled();}}}catch(e){/* ignore */}finally{if(localAbort)currentAbortControllers.delete(localAbort);progress.done+=1;notifyThrottled();}};// support continuous monitoring mode: if opts.monitor=true, repeat full passes until stopped\nconst monitorMode=!!(opts&&opts.monitor);const pollIntervalMs=opts&&typeof opts.pollIntervalMs==='number'?Math.max(1000,opts.pollIntervalMs):null;async function runFullPass(){let i=0;try{console.log('[scannerManager] runFullPass start',{scanType,interval,total:filtered.length,time:new Date().toISOString()});}catch(e){}while(i<filtered.length){if(cancel)break;const currentConcurrency=Math.max(1,Math.floor(concurrencyCurrent));const batch=filtered.slice(i,i+currentConcurrency);if(!batch.length)break;await Promise.all(batch.map(sym=>processSymbol(sym)));if(cancel)break;i+=batch.length;if(i<filtered.length){// When the page is hidden, browser timers may be clamped and make the scanner\n// appear to 'stop'. In that case, keep scans going but be conservative: reduce\n// concurrency to 1 and use a very small yield to avoid relying on long setTimeouts.\ntry{const isHidden=typeof document!=='undefined'&&document.hidden;if(isHidden){// small yield so we don't spin the event loop too hard, but avoid long sleeps\nawait sleep(20);}else{const jitter=Math.floor(Math.random()*Math.min(120,Math.max(10,Math.floor(batchDelayCurrent*0.5))));const delay=Math.max(0,batchDelayCurrent+jitter);await sleep(delay);}}catch(e){/* ignore */}}}try{console.log('[scannerManager] runFullPass done',{processed:i,time:new Date().toISOString()});}catch(e){}}try{let passCount=0;do{passCount+=1;try{console.log('[scannerManager] monitoring pass start',{passCount,monitorMode,time:new Date().toISOString()});}catch(e){}// reset progress for this pass\nprogress.done=0;progress.total=filtered.length;notifyThrottled(true);await runFullPass();if(cancel)break;// if not monitoring, break after one pass\nif(!monitorMode)break;// wait for poll interval (default to interval minutes + 5 seconds if not provided)\nlet waitMs=pollIntervalMs;if(!waitMs){// try to derive from interval string like '5m'\nconst m=String(interval||'').match(/^(\\d+)m$/);if(m){waitMs=parseInt(m[1],10)*60*1000+5000;}else{waitMs=30000;}}const step=1000;let slept=0;try{console.log('[scannerManager] waiting between passes',{waitMs});}catch(e){}while(slept<waitMs&&!cancel){const to=Math.min(step,waitMs-slept);await sleep(to);slept+=to;}try{console.log('[scannerManager] waiting complete',{passCount,time:new Date().toISOString()});}catch(e){}}while(!cancel);}catch(err){try{console.error('scannerManager.start error',err&&err.message?err.message:err);}catch(e){}}finally{try{for(const c of currentAbortControllers){try{c.abort();}catch(e){}}}catch(e){}currentAbortControllers.clear();running=false;currentSymbol=null;cancel=false;scanStartTime=null;scanType=null;notifyThrottled(true);}}function stop(){cancel=true;try{for(const c of currentAbortControllers){try{c.abort();}catch(e){}}currentAbortControllers.clear();}catch(e){}// If a worker is running, tell it to stop and terminate it\ntry{if(workerInstance){try{workerInstance.postMessage({cmd:'stop'});}catch(e){}try{workerInstance.terminate();}catch(e){}workerInstance=null;}}catch(e){}running=false;currentSymbol=null;scanStartTime=null;scanType=null;notifyThrottled(true);}function getState(){return stateSnapshot();}function removeResult(id){if(!id)return;results=results.filter(r=>r.id!==id);notifyThrottled();}function clearResults(){results=[];notifyThrottled(true);}function removeActive(symbol){if(!symbol)return;if(activeMatches[symbol]){delete activeMatches[symbol];notifyThrottled(true);}}return{onUpdate,setGetSymbols,start,stop,getState,removeResult,clearResults,removeActive};})();export default scannerManager;","map":{"version":3,"names":["scannerManager","running","currentSymbol","scanType","progress","done","total","results","activeMatches","window","localStorage","raw","getItem","JSON","parse","e","cancel","scanStartTime","currentAbortControllers","Set","listeners","getSymbolsFn","workerInstance","lastNotifyTs","pendingNotify","stateSnapshot","_objectSpread","slice","active","Object","values","notifyNow","s","cb","setItem","stringify","notifyThrottled","force","arguments","length","undefined","now","Date","isHidden","document","hidden","wait","Math","max","setTimeout","e2","onUpdate","add","delete","setGetSymbols","fn","sleep","ms","Promise","r","calculateEma","period","Array","isArray","k","out","ema","i","v","Number","isNaN","push","map","reduce","a","b","start","type","opts","console","log","Error","list","resolve","interval","test","String","concat","emaShort","parseInt","emaLong","sanitizeSymbol","toUpperCase","replace","normalized","seen","it","n","has","filtered","infoUrl","infoResp","fetch","cf","cacheTtl","ok","info","json","catch","symbols","validSet","symbol","before","cleaned","filter","after","cleanedMap","Map","forEach","set","finalList","su","get","prototype","apply","warn","message","endpointBase","symbolsArray","monitor","Worker","workerReady","onMsg","ev","m","data","unshift","terminate","addEventListener","err","postMessage","cmd","waitMs","to","removeEventListener","early","clearTimeout","checkInterval","setInterval","clearInterval","concurrencyDefault","concurrency","batchDelayBase","batchDelay","concurrencyCurrent","batchDelayCurrent","maxConcurrency","backoffCount","consecutiveSuccesses","successThreshold","rampSuccessThreshold","minBatchDelay","neededCandles","klineLimitOpt","klineLimit","candleLimit","isFinite","min","processSymbol","sym","url","encodeURIComponent","localAbort","AbortController","signal","status","floor","backoffMs","pow","random","idx","indexOf","splice","closes","d","parseFloat","emaShortArr","emaLongArr","lastClosedIdx","prevIdx","prevShort","prevLong","lastShort","lastLong","matched","lastVolume","id","toString","time","toLocaleString","volume","monitorMode","pollIntervalMs","runFullPass","toISOString","currentConcurrency","batch","all","jitter","delay","processed","passCount","match","step","slept","error","c","abort","clear","stop","getState","removeResult","clearResults","removeActive"],"sources":["C:/Users/e1it3/Desktop/program/binance_alert/src/lib/scannerManager.js"],"sourcesContent":["// Optimized singleton scanner manager to run scans independent of React component lifecycle.\r\nconst scannerManager = (() => {\r\n  let running = false;\r\n  let currentSymbol = null;\r\n  let scanType = null;\r\n  let progress = { done: 0, total: 0 };\r\n  let results = [];\r\n  // activeMatches: map of symbol -> active match info for real-time monitoring\r\n  let activeMatches = {};\r\n  try { if (typeof window !== 'undefined' && window.localStorage) { const raw = window.localStorage.getItem('scannerResults'); if (raw) results = JSON.parse(raw) || []; } } catch (e) { results = []; }\r\n  let cancel = false;\r\n  let scanStartTime = null;\r\n  let currentAbortControllers = new Set();\r\n  let listeners = new Set();\r\n  let getSymbolsFn = null;\r\n  let workerInstance = null;\r\n  // throttle notifications to reduce render overhead\r\n  let lastNotifyTs = 0; let pendingNotify = false;\r\n\r\n  function stateSnapshot() { return { running, currentSymbol, scanType, progress: { ...progress }, results: results.slice(), active: Object.values(activeMatches), scanStartTime }; }\r\n  function notifyNow() {\r\n    const s = stateSnapshot();\r\n    for (const cb of listeners) { try { cb(s); } catch (e) {} }\r\n    try { if (typeof window !== 'undefined' && window.localStorage) { window.localStorage.setItem('scannerResults', JSON.stringify(results.slice(0, 200))); } } catch (e) {}\r\n  }\r\n  function notifyThrottled(force = false) {\r\n    try {\r\n      const now = Date.now();\r\n      // If the page is hidden (background tab), don't rely on setTimeout-based throttling\r\n      // which browsers may clamp heavily; instead deliver notifications synchronously so\r\n      // the React state held by listeners stays up-to-date when the tab becomes visible.\r\n      const isHidden = (typeof document !== 'undefined' && document.hidden);\r\n      if (isHidden) {\r\n        lastNotifyTs = now; pendingNotify = false; notifyNow(); return;\r\n      }\r\n      if (force || now - lastNotifyTs >= 100) { lastNotifyTs = now; pendingNotify = false; notifyNow(); return; }\r\n      if (!pendingNotify) { pendingNotify = true; const wait = Math.max(0, 100 - (now - lastNotifyTs)); setTimeout(() => { lastNotifyTs = Date.now(); pendingNotify = false; notifyNow(); }, wait); }\r\n    } catch (e) { try { notifyNow(); } catch (e2) {} }\r\n  }\r\n\r\n  function onUpdate(cb) { listeners.add(cb); return () => listeners.delete(cb); }\r\n  function setGetSymbols(fn) { getSymbolsFn = fn; }\r\n  const sleep = (ms) => new Promise(r => setTimeout(r, ms));\r\n\r\n  function calculateEma(values, period) {\r\n    if (!Array.isArray(values) || values.length === 0) return [];\r\n    const k = 2 / (period + 1); const out = []; let ema = null;\r\n    for (let i = 0; i < values.length; i++) {\r\n      const v = Number(values[i]); if (isNaN(v)) { out.push(null); continue; }\r\n      if (ema === null) { if (i + 1 >= period) { const slice = values.slice(i + 1 - period, i + 1).map(Number); ema = slice.reduce((a,b)=>a+b,0)/period; out.push(ema); } else { out.push(null); } }\r\n      else { ema = v * k + ema * (1 - k); out.push(ema); }\r\n    }\r\n    return out;\r\n  }\r\n\r\n  async function start(type, opts = {}) {\r\n    if (running) return;\r\n    try { console.log('[scannerManager] start called', { type, opts }); } catch (e) {}\r\n    if (typeof getSymbolsFn !== 'function') throw new Error('scannerManager: getSymbolsFn not set');\r\n    running = true; cancel = false; results = []; progress = { done: 0, total: 0 }; currentSymbol = null; scanType = type || null; scanStartTime = Date.now();\r\n    notifyThrottled(true);\r\n    const list = (await Promise.resolve(getSymbolsFn())) || [];\r\n    let interval = (opts && typeof opts.interval !== 'undefined') ? opts.interval : '5m';\r\n    if (typeof interval === 'number' || (typeof interval === 'string' && /^\\d+$/.test(String(interval)))) interval = `${interval}m`;\r\n    const emaShort = (opts && typeof opts.emaShort !== 'undefined') ? parseInt(opts.emaShort, 10) : 26;\r\n    const emaLong = (opts && typeof opts.emaLong !== 'undefined') ? parseInt(opts.emaLong, 10) : 200;\r\n    // Normalize / sanitize incoming symbol list to reduce typos like 'BTCSTUSDT'\r\n    const sanitizeSymbol = (raw) => {\r\n      if (!raw) return '';\r\n      try {\r\n        let s = String(raw).toUpperCase();\r\n        // strip any non-alphanumeric chars\r\n        s = s.replace(/[^A-Z0-9]/g, '');\r\n        // collapse repeated USDT occurrences (e.g. 'BTCUSDTUSDT' -> 'BTCUSDT')\r\n        s = s.replace(/(USDT)+$/g, 'USDT');\r\n        s = s.replace(/USDTUSDT/g, 'USDT');\r\n        // If the result doesn't end with USDT it's not a futures symbol we care about\r\n        if (!/USDT$/.test(s)) return '';\r\n        // Basic sanity: symbol length should be reasonable\r\n        if (s.length < 6 || s.length > 12) return '';\r\n        return s;\r\n      } catch (e) { return ''; }\r\n    };\r\n\r\n    // Build a unique, normalized filtered list to use for API calls.\r\n    const normalized = [];\r\n    if (Array.isArray(list)) {\r\n      const seen = new Set();\r\n      for (const it of list) {\r\n        const n = sanitizeSymbol(it);\r\n        if (!n) continue;\r\n        if (seen.has(n)) continue;\r\n        seen.add(n);\r\n        normalized.push(n);\r\n      }\r\n    }\r\n    const filtered = normalized;\r\n    // Validate symbols against Binance exchangeInfo to avoid scanning invalid/typo symbols\r\n    progress.total = filtered.length; notifyThrottled(true);\r\n    try {\r\n      const infoUrl = 'https://fapi.binance.com/fapi/v1/exchangeInfo';\r\n      const infoResp = await fetch(infoUrl, { cf: { cacheTtl: 600 } });\r\n      if (infoResp && infoResp.ok) {\r\n        const info = await infoResp.json().catch(() => null);\r\n        if (info && Array.isArray(info.symbols)) {\r\n          const validSet = new Set(info.symbols.map(s => String(s.symbol).toUpperCase()));\r\n          const before = filtered.length;\r\n          const cleaned = filtered.map(s => String(s).toUpperCase()).filter(s => validSet.has(s));\r\n          if (cleaned.length !== before) {\r\n            try { console.log('[scannerManager] removed invalid symbols', { before, after: cleaned.length }); } catch (e) {}\r\n          }\r\n          // use cleaned list (preserve case as original list may vary)\r\n          const cleanedMap = new Map(); filtered.forEach(s => cleanedMap.set(String(s).toUpperCase(), s));\r\n          const finalList = cleaned.map(su => cleanedMap.get(su) || su);\r\n          // replace filtered variable\r\n          // eslint-disable-next-line no-param-reassign\r\n          filtered.length = 0; Array.prototype.push.apply(filtered, finalList);\r\n          progress.total = filtered.length; notifyThrottled(true);\r\n        }\r\n      }\r\n    } catch (e) { try { console.warn('[scannerManager] exchangeInfo fetch failed', e && e.message ? e.message : e); } catch (e2) {} }\r\n    const endpointBase = 'https://fapi.binance.com/fapi/v1/klines';\r\n\r\n    // Try to delegate scanning to dedicated worker (served at /worker-scanner.js)\r\n    const symbolsArray = Array.isArray(list) ? list : [];\r\n    // Only delegate to the dedicated worker for single-run scans.\r\n    // For continuous monitoring (`opts.monitor`), run inline loop to allow repeated passes.\r\n    try { console.log('[scannerManager] monitorMode?', !!(opts && opts.monitor)); } catch (e) {}\r\n    if (!opts.monitor && typeof Worker !== 'undefined' && typeof window !== 'undefined') {\r\n      try {\r\n        workerInstance = new Worker('/worker-scanner.js');\r\n        let workerReady = false;\r\n        const onMsg = (ev) => {\r\n          const m = ev.data || {};\r\n          if (m.type === 'started') {\r\n            workerReady = true; progress.total = m.total || progress.total; notifyThrottled(true);\r\n          } else if (m.type === 'progress') {\r\n            workerReady = true; progress.done = m.done || progress.done; currentSymbol = m.currentSymbol || currentSymbol; notifyThrottled();\r\n          } else if (m.type === 'match' && m.ev) {\r\n            workerReady = true; results.unshift(m.ev); if (results.length > 500) results = results.slice(0, 500); notifyThrottled();\r\n          } else if (m.type === 'done') {\r\n            // worker finished its task\r\n            try { workerInstance.terminate(); } catch (e) {}\r\n            workerInstance = null; running = false; currentSymbol = null; cancel = false; scanStartTime = null; notifyThrottled(true);\r\n          } else if (m.type === 'stopped') {\r\n            try { workerInstance.terminate(); } catch (e) {}\r\n            workerInstance = null; running = false; currentSymbol = null; cancel = false; scanStartTime = null; notifyThrottled(true);\r\n          }\r\n        };\r\n        workerInstance.addEventListener('message', onMsg);\r\n        workerInstance.addEventListener('error', (err) => {\r\n          try { console.warn('scanner worker error', err); } catch (e) {}\r\n        });\r\n        // send start command with symbols and options\r\n        try { workerInstance.postMessage({ cmd: 'start', symbols: symbolsArray, opts, scanType: type }); } catch (e) { /* ignore */ }\r\n\r\n        // Wait briefly for the worker to acknowledge (avoid stuck 'Scanning: ...' if worker asset missing or blocked)\r\n        const waitMs = 2000;\r\n        await new Promise((resolve) => {\r\n          const to = setTimeout(() => {\r\n            if (!workerReady) {\r\n              try { workerInstance.removeEventListener('message', onMsg); } catch (e) {}\r\n              try { workerInstance.terminate(); } catch (e) {}\r\n              workerInstance = null;\r\n            }\r\n            resolve();\r\n          }, waitMs);\r\n          // if worker signals readiness before timeout, resolve early\r\n          const early = () => { clearTimeout(to); resolve(); };\r\n          const checkInterval = setInterval(() => { if (workerReady) { clearInterval(checkInterval); early(); } }, 50);\r\n        });\r\n\r\n        // If worker started and is handling the scan, return early\r\n        if (workerInstance) {\r\n          // worker is active and will manage scanning\r\n          return;\r\n        }\r\n        // else fallthrough to inline scanner\r\n      } catch (e) {\r\n        try { if (workerInstance) { workerInstance.terminate(); workerInstance = null; } } catch (e2) {}\r\n        // fallthrough to inline scanner\r\n      }\r\n    }\r\n\r\n    const concurrencyDefault = (opts && typeof opts.concurrency === 'number') ? Math.max(1, opts.concurrency) : 8;\r\n    const batchDelayBase = (opts && typeof opts.batchDelay === 'number') ? Math.max(0, opts.batchDelay) : 120;\r\n    let concurrencyCurrent = concurrencyDefault; let batchDelayCurrent = batchDelayBase;\r\n    const maxConcurrency = (opts && typeof opts.maxConcurrency === 'number') ? Math.max(1, opts.maxConcurrency) : 12;\r\n    let backoffCount = 0; let consecutiveSuccesses = 0;\r\n    const successThreshold = (opts && typeof opts.rampSuccessThreshold === 'number') ? Math.max(1, opts.rampSuccessThreshold) : 3;\r\n    const minBatchDelay = (opts && typeof opts.minBatchDelay === 'number') ? Math.max(50, opts.minBatchDelay) : 60;\r\n    const neededCandles = Math.max(emaShort, emaLong) + 10;\r\n    // Allow caller to request a specific kline limit (e.g., 200). If not provided,\r\n    // fall back to previous heuristic which ensured at least ~120 candles.\r\n    const klineLimitOpt = (opts && typeof opts.klineLimit === 'number') ? Math.max(0, parseInt(opts.klineLimit, 10)) : null;\r\n    const candleLimit = (Number.isFinite(klineLimitOpt) && klineLimitOpt > 0)\r\n      ? Math.min(1000, Math.max(klineLimitOpt, neededCandles + 1))\r\n      : Math.min(1000, Math.max(neededCandles + 10, 120));\r\n\r\n    const processSymbol = async (sym) => {\r\n      if (cancel) return;\r\n      currentSymbol = sym; notifyThrottled();\r\n      const url = `${endpointBase}?symbol=${encodeURIComponent(sym)}&interval=${encodeURIComponent(interval)}&limit=${candleLimit}`;\r\n      let localAbort = null; try { localAbort = new AbortController(); currentAbortControllers.add(localAbort); } catch (e) {}\r\n      try {\r\n        const r = await fetch(url, localAbort ? { signal: localAbort.signal } : undefined);\r\n        if (!r.ok) {\r\n          // Too many requests -> backoff and retry later\r\n          if (r.status === 429) {\r\n            backoffCount += 1; consecutiveSuccesses = 0; concurrencyCurrent = Math.max(1, Math.floor(concurrencyCurrent * 0.6)); batchDelayCurrent = Math.min(30000, Math.floor(batchDelayCurrent * 1.6));\r\n            const backoffMs = Math.min(30000, 1000 * Math.pow(2, Math.min(backoffCount, 6)) + Math.floor(Math.random() * 1000));\r\n            await sleep(backoffMs);\r\n            return;\r\n          }\r\n          // Bad request often means an invalid symbol (typo or delisted). Remove it to avoid repeated 400s.\r\n          if (r.status === 400) {\r\n            try { console.warn('[scannerManager] removing invalid symbol due to 400', sym); } catch (e) {}\r\n            try {\r\n              const idx = filtered.indexOf(sym);\r\n              if (idx !== -1) {\r\n                filtered.splice(idx, 1);\r\n                progress.total = filtered.length;\r\n                notifyThrottled(true);\r\n              }\r\n            } catch (e) {}\r\n            return;\r\n          }\r\n          return;\r\n        }\r\n        const data = await r.json();\r\n        backoffCount = Math.max(0, backoffCount - 1); consecutiveSuccesses += 1;\r\n        if (consecutiveSuccesses >= successThreshold) { consecutiveSuccesses = 0; if (concurrencyCurrent < maxConcurrency) concurrencyCurrent += 1; batchDelayCurrent = Math.max(minBatchDelay, Math.floor(batchDelayCurrent * 0.85)); }\r\n        const closes = Array.isArray(data) ? data.map(d => parseFloat(d[4])) : [];\r\n          // require one extra candle so we can use the last closed candle (avoid counting the live/open candle)\r\n          if (!Array.isArray(closes) || closes.length < neededCandles + 1) return;\r\n        const emaShortArr = calculateEma(closes, emaShort); const emaLongArr = calculateEma(closes, emaLong);\r\n          const lastClosedIdx = closes.length - 2; const prevIdx = lastClosedIdx - 1;\r\n          const prevShort = emaShortArr[prevIdx]; const prevLong = emaLongArr[prevIdx];\r\n          const lastShort = emaShortArr[lastClosedIdx]; const lastLong = emaLongArr[lastClosedIdx];\r\n        let matched = false;\r\n        if (typeof prevShort === 'number' && typeof prevLong === 'number' && typeof lastShort === 'number' && typeof lastLong === 'number') {\r\n          if (scanType === 'golden') matched = (prevShort <= prevLong && lastShort > lastLong);\r\n          else if (scanType === 'dead') matched = (prevShort >= prevLong && lastShort < lastLong);\r\n        }\r\n        const lastVolume = (Array.isArray(data) && data[lastClosedIdx] && data[lastClosedIdx][5] != null) ? parseFloat(data[lastClosedIdx][5]) : 0;\r\n        // Real-time monitoring behavior: maintain activeMatches map. When a symbol becomes matched, add it; when it stops matching, remove it.\r\n        if (matched) {\r\n          try { console.log('[scannerManager] match detected', sym, { scanType, emaShort, emaLong }); } catch (e) {}\r\n          if (!activeMatches[sym]) {\r\n            const ev = { id: `${sym}-${Date.now()}-${Math.random().toString(36).slice(2,8)}`, symbol: sym, prevShort, prevLong, lastShort, lastLong, time: new Date().toLocaleString(), interval, emaShort, emaLong, type: scanType, volume: lastVolume };\r\n            activeMatches[sym] = ev;\r\n            // also keep history results for reference\r\n            results.unshift(ev); if (results.length > 500) results = results.slice(0, 500);\r\n            notifyThrottled();\r\n            try { console.log('[scannerManager] active add', sym); } catch (e) {}\r\n          } else {\r\n            // update existing active entry with latest values\r\n            activeMatches[sym] = { ...activeMatches[sym], prevShort, prevLong, lastShort, lastLong, time: new Date().toLocaleString(), volume: lastVolume };\r\n            try { console.log('[scannerManager] active update', sym); } catch (e) {}\r\n          }\r\n        } else {\r\n          if (activeMatches[sym]) {\r\n            try { console.log('[scannerManager] match cleared', sym); } catch (e) {}\r\n            delete activeMatches[sym];\r\n            notifyThrottled();\r\n          }\r\n        }\r\n      } catch (e) { /* ignore */ }\r\n      finally { if (localAbort) currentAbortControllers.delete(localAbort); progress.done += 1; notifyThrottled(); }\r\n    };\r\n\r\n    // support continuous monitoring mode: if opts.monitor=true, repeat full passes until stopped\r\n    const monitorMode = !!(opts && opts.monitor);\r\n    const pollIntervalMs = (opts && typeof opts.pollIntervalMs === 'number') ? Math.max(1000, opts.pollIntervalMs) : null;\r\n    async function runFullPass() {\r\n      let i = 0;\r\n      try { console.log('[scannerManager] runFullPass start', { scanType, interval, total: filtered.length, time: new Date().toISOString() }); } catch (e) {}\r\n      while (i < filtered.length) {\r\n        if (cancel) break;\r\n        const currentConcurrency = Math.max(1, Math.floor(concurrencyCurrent));\r\n        const batch = filtered.slice(i, i + currentConcurrency); if (!batch.length) break;\r\n        await Promise.all(batch.map(sym => processSymbol(sym)));\r\n        if (cancel) break; i += batch.length;\r\n        if (i < filtered.length) {\r\n          // When the page is hidden, browser timers may be clamped and make the scanner\r\n          // appear to 'stop'. In that case, keep scans going but be conservative: reduce\r\n          // concurrency to 1 and use a very small yield to avoid relying on long setTimeouts.\r\n          try {\r\n            const isHidden = (typeof document !== 'undefined' && document.hidden);\r\n            if (isHidden) {\r\n              // small yield so we don't spin the event loop too hard, but avoid long sleeps\r\n              await sleep(20);\r\n            } else {\r\n              const jitter = Math.floor(Math.random() * Math.min(120, Math.max(10, Math.floor(batchDelayCurrent * 0.5))));\r\n              const delay = Math.max(0, batchDelayCurrent + jitter);\r\n              await sleep(delay);\r\n            }\r\n          } catch (e) { /* ignore */ }\r\n        }\r\n      }\r\n      try { console.log('[scannerManager] runFullPass done', { processed: i, time: new Date().toISOString() }); } catch (e) {}\r\n    }\r\n    try {\r\n      let passCount = 0;\r\n      do {\r\n        passCount += 1;\r\n        try { console.log('[scannerManager] monitoring pass start', { passCount, monitorMode, time: new Date().toISOString() }); } catch (e) {}\r\n        // reset progress for this pass\r\n        progress.done = 0; progress.total = filtered.length; notifyThrottled(true);\r\n        await runFullPass();\r\n        if (cancel) break;\r\n        // if not monitoring, break after one pass\r\n        if (!monitorMode) break;\r\n        // wait for poll interval (default to interval minutes + 5 seconds if not provided)\r\n        let waitMs = pollIntervalMs;\r\n        if (!waitMs) {\r\n          // try to derive from interval string like '5m'\r\n          const m = String(interval || '').match(/^(\\d+)m$/);\r\n          if (m) { waitMs = parseInt(m[1], 10) * 60 * 1000 + 5000; } else { waitMs = 30000; }\r\n        }\r\n        const step = 1000;\r\n        let slept = 0;\r\n        try { console.log('[scannerManager] waiting between passes', { waitMs }); } catch (e) {}\r\n        while (slept < waitMs && !cancel) { const to = Math.min(step, waitMs - slept); await sleep(to); slept += to; }\r\n        try { console.log('[scannerManager] waiting complete', { passCount, time: new Date().toISOString() }); } catch (e) {}\r\n      } while (!cancel);\r\n    } catch (err) { try { console.error('scannerManager.start error', err && err.message ? err.message : err); } catch (e) {} }\r\n    finally { try { for (const c of currentAbortControllers) { try { c.abort(); } catch (e) {} } } catch (e) {} currentAbortControllers.clear(); running = false; currentSymbol = null; cancel = false; scanStartTime = null; scanType = null; notifyThrottled(true); }\r\n  }\r\n\r\n  function stop() {\r\n    cancel = true;\r\n    try { for (const c of currentAbortControllers) { try { c.abort(); } catch (e) {} } currentAbortControllers.clear(); } catch (e) {}\r\n    // If a worker is running, tell it to stop and terminate it\r\n    try {\r\n      if (workerInstance) {\r\n        try { workerInstance.postMessage({ cmd: 'stop' }); } catch (e) {}\r\n        try { workerInstance.terminate(); } catch (e) {}\r\n        workerInstance = null;\r\n      }\r\n    } catch (e) {}\r\n    running = false; currentSymbol = null; scanStartTime = null; scanType = null; notifyThrottled(true);\r\n  }\r\n  function getState() { return stateSnapshot(); }\r\n  function removeResult(id) { if (!id) return; results = results.filter(r => r.id !== id); notifyThrottled(); }\r\n  function clearResults() { results = []; notifyThrottled(true); }\r\n  function removeActive(symbol) { if (!symbol) return; if (activeMatches[symbol]) { delete activeMatches[symbol]; notifyThrottled(true); } }\r\n\r\n  return { onUpdate, setGetSymbols, start, stop, getState, removeResult, clearResults, removeActive };\r\n})();\r\n\r\nexport default scannerManager;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}