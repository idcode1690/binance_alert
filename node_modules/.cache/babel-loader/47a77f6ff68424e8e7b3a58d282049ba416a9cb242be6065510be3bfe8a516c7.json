{"ast":null,"code":"import{useEffect,useRef,useState,useCallback}from'react';import{calculateInitialEMA,updateEMA}from'../utils/ema';// Hook options: { symbol }\nexport default function useEmaCross(){let{symbol='BTCUSDT',autoConnect=true,debug=false,interval='1m',emaShort=9,emaLong=26,confirmClosedCandles=1}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const[ema9,setEma9]=useState(null);const[ema26,setEma26]=useState(null);const[lastPrice,setLastPrice]=useState(null);// lastTick represents the most recent trade/partial-candle price (live preview).\n// lastPrice remains reserved for the most recent CLOSED candle price and is\n// used when emitting confirmed alerts/notifications.\n// eslint-disable-next-line no-unused-vars\nconst[lastTick,setLastTick]=useState(null);// when debug is enabled, log lastTick updates so the variable is visibly used\n// inside this module (and also helpful for debugging live preview values).\nuseEffect(()=>{try{if(debug&&typeof lastTick!=='undefined'&&lastTick!==null){// lightweight debug output\n// eslint-disable-next-line no-console\nconsole.debug('[useEmaCross] lastTick',lastTick);}}catch(e){}},[lastTick,debug]);const[cross,setCross]=useState(null);// preview (live) cross\nconst[confirmedCross,setConfirmedCross]=useState(null);// only updated on closed candles (confirmed)\nconst[confirmedSource,setConfirmedSource]=useState(null);// 'ws' | 'poll' | 'init'\nconst[connected,setConnected]=useState(false);const[status,setStatus]=useState('idle');const[lastCandleClosed,setLastCandleClosed]=useState(false);const[activeSymbol,setActiveSymbol]=useState(null);// which symbol the hook has initialized/connected for\nconst wsRef=useRef(null);const prevCrossRef=useRef(null);const prevConfirmedRef=useRef(null);const candidateConfirmedRef=useRef(null);const candidateCountRef=useRef(0);const ema9Ref=useRef(null);const ema26Ref=useRef(null);// confirmed EMAs updated only on closed candles (kline.x === true) or polling\nconst ema9ConfirmedRef=useRef(null);const ema26ConfirmedRef=useRef(null);const reconnectAttemptsRef=useRef(0);const reconnectTimerRef=useRef(null);const currentSymbolRef=useRef(null);const lastProcessedCloseRef=useRef(null);// timestamp (ms) of last processed closed candle\nconst pollingTimerRef=useRef(null);// Normalize interval strings for Binance API compatibility.\n// Binance accepts tokens like '1m','3m','5m','15m','30m','1h','2h','4h', etc.\n// The app sometimes passes numeric minute strings like '240m' or '240';\n// convert minute multiples of 60 to '4h' style tokens so REST requests don't 400.\nconst normalizeIntervalForBinance=raw=>{try{let s=String(raw||'').trim();if(!s)return s;s=s.toLowerCase();const allowed=new Set(['1m','3m','5m','15m','30m','1h','2h','4h','6h','8h','12h','1d','3d','1w','1m']);if(allowed.has(s))return s;// plain number like '240' -> minutes\nconst numMatch=s.match(/^([0-9]+)$/);if(numMatch){const n=Number(numMatch[1]);if(n%60===0)return\"\".concat(n/60,\"h\");return\"\".concat(n,\"m\");}// matches like '240m'\nconst mMatch=s.match(/^([0-9]+)m$/);if(mMatch){const n=Number(mMatch[1]);if(n%60===0)return\"\".concat(n/60,\"h\");return\"\".concat(n,\"m\");}// matches like '4h'\nconst hMatch=s.match(/^([0-9]+)h$/);if(hMatch)return\"\".concat(Number(hMatch[1]),\"h\");return s;}catch(e){return String(raw);}};const getBinanceInterval=()=>normalizeIntervalForBinance(interval);const fetchAndInit=useCallback(async function(){let target=arguments.length>0&&arguments[0]!==undefined?arguments[0]:symbol;try{const t=(target||symbol).toString();setStatus('fetching historical klines');const norm=t.replace(/[^A-Za-z0-9]/g,'').toUpperCase();// use Binance Futures (USDT-M) REST endpoint for klines; interval is configurable\n// normalize interval to Binance-accepted token (e.g., convert '240m' -> '4h')\nconst bi=getBinanceInterval();// request up to 1000 candles to provide long historical context for EMA calculations\nconst url=\"https://fapi.binance.com/fapi/v1/klines?symbol=\".concat(norm,\"&interval=\").concat(bi,\"&limit=1000\");const res=await fetch(url);if(!res.ok)throw new Error(\"Failed to fetch klines: \".concat(res.status));const data=await res.json();// kline array: [ openTime, open, high, low, close, ... ]\nconst closes=data.map(k=>parseFloat(k[4]));if(closes.length<emaLong)throw new Error(\"Not enough historical candles to initialize EMA\".concat(emaLong));// Determine sensible history windows for initial EMA calculation\nconst shortWindow=Math.max(emaShort*10,100);const longWindow=Math.max(emaLong*12,300);// Use the close history to compute EMA short/long\nif(debug)console.debug('[useEmaCross] fetchAndInit params',{symbol:norm,interval,emaShort,emaLong,shortWindow,longWindow,closesLength:closes.length});const initEma9=calculateInitialEMA(closes.slice(-shortWindow),emaShort);const initEma26=calculateInitialEMA(closes.slice(-longWindow),emaLong);// initialize both preview and confirmed EMAs from historical closes\nema9Ref.current=initEma9;ema26Ref.current=initEma26;ema9ConfirmedRef.current=initEma9;ema26ConfirmedRef.current=initEma26;// record which symbol these EMAs correspond to\ncurrentSymbolRef.current=norm;setActiveSymbol(norm);// record last processed closed candle time (closeTime at index 6)\ntry{lastProcessedCloseRef.current=data[data.length-1][6];}catch(e){lastProcessedCloseRef.current=null;}setEma9(initEma9);setEma26(initEma26);setLastPrice(closes[closes.length-1]);setStatus('initialized');// set initial cross\nconst initialCross=initEma9>initEma26?'bull':'bear';if(debug)console.debug('[useEmaCross] initial EMAs',{initEma9,initEma26,initialCross});prevCrossRef.current=initialCross;setCross(initialCross);prevConfirmedRef.current=initialCross;setConfirmedCross(initialCross);setConfirmedSource('init');}catch(err){setStatus(\"init error: \".concat(err.message));console.error(err);}},[symbol,interval,emaShort,emaLong,debug]);const connect=useCallback(async overrideSymbol=>{const targetSymbol=(overrideSymbol||symbol).toString();const targetNorm=targetSymbol.replace(/[^A-Za-z0-9]/g,'').toUpperCase();// if a websocket exists for same symbol, no-op\nif(wsRef.current){if(currentSymbolRef.current===targetNorm)return;// do NOT close the existing socket here; create a new socket and let the\n// new socket's onopen handler replace/close the old socket to avoid a\n// brief disconnected state in the UI.\n}// Ensure EMA is initialized for the target symbol before connecting\ntry{const targetNorm=targetSymbol.replace(/[^A-Za-z0-9]/g,'').toUpperCase();if(currentSymbolRef.current!==targetNorm||ema9Ref.current==null||ema26Ref.current==null){await fetchAndInit(targetNorm);}}catch(err){setStatus(\"init error: \".concat(err.message));return;}setStatus('connecting websocket');// Use combined stream: kline interval (configurable) + aggTrade for higher-frequency trade updates\nconst klineStream=\"\".concat(targetNorm.toLowerCase(),\"@kline_\").concat(getBinanceInterval());const tradeStream=\"\".concat(targetNorm.toLowerCase(),\"@aggTrade\");const streams=\"\".concat(klineStream,\"/\").concat(tradeStream);// use Binance Futures (USDT-M) websocket (fstream) combined stream\nconst url=\"wss://fstream.binance.com/stream?streams=\".concat(streams);console.log('Connecting websocket for',targetSymbol,'url=',url);const ws=new WebSocket(url);// Do not overwrite wsRef.current immediately. Create a new socket and only replace the\n// existing one after the new socket successfully opens. This allows a seamless symbol\n// switch without briefly showing disconnected state in the UI.\nconst oldWs=wsRef.current;ws.onopen=()=>{// mark as successful open\nreconnectAttemptsRef.current=0;if(reconnectTimerRef.current){clearTimeout(reconnectTimerRef.current);reconnectTimerRef.current=null;}// stop polling if it was started while socket was down\nif(pollingTimerRef.current){clearInterval(pollingTimerRef.current);pollingTimerRef.current=null;}// If there was a previous socket, mark it as replaced so its onclose handler\n// skips reconnect logic, then close it.\ntry{if(oldWs){oldWs.__replaced=true;try{oldWs.close();}catch(e){}}}catch(e){}// now adopt the new socket as the active socket\nwsRef.current=ws;currentSymbolRef.current=targetNorm;setActiveSymbol(targetNorm);if(debug)console.log('[useEmaCross] websocket open for',targetNorm);setConnected(true);setStatus('connected');};ws.onmessage=ev=>{try{const payloadWrapper=JSON.parse(ev.data);// combined stream returns { stream, data }\nconst payload=payloadWrapper.data||payloadWrapper;// determine the source symbol for this message (if available)\nlet sourceSymbol=null;try{if(payload&&payload.s)sourceSymbol=payload.s.toString().toUpperCase();else if(payloadWrapper&&payloadWrapper.stream){const streamName=payloadWrapper.stream.toString();// e.g. trxusdt@aggTrade\nsourceSymbol=streamName.split('@')[0].toUpperCase();}}catch(e){sourceSymbol=null;}// If the message is not for the currently-initialized symbol, ignore it.\n// NOTE: previously we only ignored messages when currentSymbolRef was set;\n// that left a small window during symbol switches where messages could be\n// processed while currentSymbolRef was null. Be stricter: if the message\n// contains a source symbol it must match the initialized symbol, otherwise\n// ignore it.\nif(sourceSymbol){if(!currentSymbolRef.current||currentSymbolRef.current.toString().toUpperCase()!==sourceSymbol.toString().toUpperCase()){return;// ignore messages from other symbols or while switching\n}}// aggTrade messages have event type 'aggTrade' and price in p\nif(debug){try{const streamName=payloadWrapper.stream||payload.e||'unknown';console.log('[useEmaCross] incoming',{stream:streamName,sourceSymbol,event:payload.e||null});}catch(e){}}if(payload.e==='aggTrade'){const price=parseFloat(payload.p);// update live tick price only; do NOT overwrite the last closed price\n// which should be used for confirmed alerts.\nsetLastTick(price);if(ema9Ref.current==null||ema26Ref.current==null)return;// update EMA using trade price to provide higher-frequency preview\nconst newEma9=updateEMA(ema9Ref.current,price,emaShort);const newEma26=updateEMA(ema26Ref.current,price,emaLong);// preview EMAs only\nema9Ref.current=newEma9;ema26Ref.current=newEma26;setEma9(newEma9);setEma26(newEma26);// Do not update `cross` from trade ticks — keep cross decision tied to closed candles.\n}// kline messages contain a 'k' object\nif(payload.k){if(debug)console.log('[useEmaCross] kline payload x=',payload.k.x,'close=',payload.k.c);const k=payload.k;const close=parseFloat(k.c);// for partial candles, update live tick display; for closed candles\n// update the confirmed lastPrice (closed price) which will be used\n// for confirmedCross/notifications.\nsetLastTick(close);setLastCandleClosed(Boolean(k.x));// candidate cross detected for this kline (set when closed candle processed)\nlet detectedCross=null;if(ema9Ref.current==null||ema26Ref.current==null)return;// update EMA using kline close\n// For partial candle: update preview EMA only\nif(!k.x){const newEma9=updateEMA(ema9Ref.current,close,emaShort);const newEma26=updateEMA(ema26Ref.current,close,emaLong);ema9Ref.current=newEma9;ema26Ref.current=newEma26;setEma9(newEma9);setEma26(newEma26);}else{// closed candle: update confirmed EMAs only (and sync preview to confirmed)\nif(ema9ConfirmedRef.current==null||ema26ConfirmedRef.current==null){// defensive: fall back to preview if confirmed not initialized\nema9ConfirmedRef.current=ema9Ref.current;ema26ConfirmedRef.current=ema26Ref.current;}const prevShort=typeof ema9ConfirmedRef.current==='number'?ema9ConfirmedRef.current:null;const prevLong=typeof ema26ConfirmedRef.current==='number'?ema26ConfirmedRef.current:null;const newEma9c=updateEMA(ema9ConfirmedRef.current,close,emaShort);const newEma26c=updateEMA(ema26ConfirmedRef.current,close,emaLong);// update confirmed refs\nema9ConfirmedRef.current=newEma9c;ema26ConfirmedRef.current=newEma26c;// sync preview to confirmed after closed candle to avoid drift\nema9Ref.current=newEma9c;ema26Ref.current=newEma26c;setEma9(newEma9c);setEma26(newEma26c);// closed candle: also record the closed price as the authoritative lastPrice\nsetLastPrice(close);// Determine whether an actual cross occurred between the previous confirmed\n// EMAs and the newly computed confirmed EMAs. A cross is defined as a\n// sign change: prevShort <= prevLong && newShort > newLong => golden\n// prevShort >= prevLong && newShort < newLong => dead\ndetectedCross=null;try{if(prevShort!=null&&prevLong!=null){if(prevShort<=prevLong&&newEma9c>newEma26c)detectedCross='bull';else if(prevShort>=prevLong&&newEma9c<newEma26c)detectedCross='bear';else detectedCross=null;// no crossing event\n}}catch(e){detectedCross=null;}}// Do not update `cross` for preview/partial candles here; cross will be\n// determined and updated only when a candle is closed (confirmed).\n// If candle is closed (k.x === true) and it's a new closed candle, update processed time and set confirmed cross\nif(Boolean(k.x)){try{const closeTime=k.T||k.t||null;// k.T is close time in ms\nif(closeTime&&(!lastProcessedCloseRef.current||closeTime>lastProcessedCloseRef.current)){lastProcessedCloseRef.current=closeTime;// compute confirmed cross using confirmed EMA refs (fallback to preview values)\n// Only consider a confirmed cross when we detect an actual crossing event\n// between the previous confirmed EMAs and the newly computed confirmed EMAs.\nif(debug)console.debug('[useEmaCross] closed candle detected',{closeTime,close,ema9Confirmed:ema9ConfirmedRef.current,ema26Confirmed:ema26ConfirmedRef.current,ema9Preview:ema9Ref.current,ema26Preview:ema26Ref.current,detectedCross});// If we didn't detect an explicit sign-change event, fall back to\n// comparing the current confirmed EMAs. This ensures confirmedCross\n// updates on closed candles even when previous values are not set\n// or edge-cases occur during initialization.\nlet candidate=detectedCross;if(candidate==null){if(ema9ConfirmedRef.current!=null&&ema26ConfirmedRef.current!=null){candidate=ema9ConfirmedRef.current>ema26ConfirmedRef.current?'bull':'bear';}}if(candidate!=null){if(candidateConfirmedRef.current===candidate){candidateCountRef.current=(candidateCountRef.current||0)+1;}else{candidateConfirmedRef.current=candidate;candidateCountRef.current=1;}if(debug)console.debug('[useEmaCross] candidateConfirmed state',{candidateConfirmed:candidateConfirmedRef.current,candidateCount:candidateCountRef.current,required:confirmClosedCandles});if(candidateCountRef.current>=confirmClosedCandles){if(prevConfirmedRef.current!==candidate){prevConfirmedRef.current=candidate;setConfirmedCross(candidate);setConfirmedSource('ws');// also update public `cross` so UI reflects the closed-candle decision\nif(prevCrossRef.current!==candidate){prevCrossRef.current=candidate;setCross(candidate);}}}}else{// No crossing event: reset candidate tracking so we only detect real cross events\ncandidateConfirmedRef.current=null;candidateCountRef.current=0;}}}catch(e){// fallback: if we couldn't compute confirmed EMAs, fall back to\n// preview EMAs (if available) to set a confirmed-like value.\nconst fallback=ema9Ref.current!=null&&ema26Ref.current!=null?ema9Ref.current>ema26Ref.current?'bull':'bear':null;if(fallback&&prevConfirmedRef.current!==fallback){prevConfirmedRef.current=fallback;setConfirmedCross(fallback);setConfirmedSource('ws');}}}else{// partial candle: preview already updated above\n}}}catch(err){console.error('ws message parse error',err);}};ws.onerror=e=>{// if this socket was intentionally replaced by a new one, ignore errors\nif(ws.__replaced){if(debug)console.log('[useEmaCross] ignored error on replaced socket');return;}console.error('ws error',e);setStatus('websocket error');// close to trigger backoff reconnect\ntry{ws.close();}catch(err){}};ws.onclose=()=>{// if this socket was intentionally replaced by a new one, skip close handling\nif(ws.__replaced){if(debug)console.log('[useEmaCross] websocket was replaced; skipping onclose handling');return;}setConnected(false);setStatus('websocket closed');wsRef.current=null;if(debug)console.log('[useEmaCross] websocket closed');// capture intended reconnect target now (before we nullify refs)\nconst reconnectTarget=currentSymbolRef.current||symbol;// clear active symbol immediately for UI, but keep reconnectTarget for retries\nsetActiveSymbol(null);// start polling for closed candles while websocket is down\ntry{if(!pollingTimerRef.current){pollingTimerRef.current=setInterval(async()=>{try{const sym=(reconnectTarget||symbol||'').replace(/[^A-Za-z0-9]/g,'').toUpperCase();if(!sym)return;const url=\"https://fapi.binance.com/fapi/v1/klines?symbol=\".concat(sym,\"&interval=\").concat(getBinanceInterval(),\"&limit=10\");const res=await fetch(url);if(!res.ok)return;const data=await res.json();// iterate candles in chronological order and process any closed candles newer than lastProcessedCloseRef\nconst newClosed=[];for(const k of data){const closeTime=k[6];if(closeTime&&(!lastProcessedCloseRef.current||closeTime>lastProcessedCloseRef.current)){newClosed.push(k);}}if(newClosed.length>0){// sort by closeTime asc\nnewClosed.sort((a,b)=>a[6]-b[6]);for(const k of newClosed){const close=parseFloat(k[4]);// update EMAs using closed candle\nif(ema9Ref.current==null||ema26Ref.current==null)continue;// update confirmed EMAs using closed candle (polling)\nif(ema9ConfirmedRef.current==null||ema26ConfirmedRef.current==null){ema9ConfirmedRef.current=ema9Ref.current;ema26ConfirmedRef.current=ema26Ref.current;}const prevShort=typeof ema9ConfirmedRef.current==='number'?ema9ConfirmedRef.current:null;const prevLong=typeof ema26ConfirmedRef.current==='number'?ema26ConfirmedRef.current:null;const newEma9c=updateEMA(ema9ConfirmedRef.current,close,emaShort);const newEma26c=updateEMA(ema26ConfirmedRef.current,close,emaLong);ema9ConfirmedRef.current=newEma9c;ema26ConfirmedRef.current=newEma26c;// sync preview to confirmed\nema9Ref.current=newEma9c;ema26Ref.current=newEma26c;setEma9(newEma9c);setEma26(newEma26c);// detect actual crossing event between previous confirmed EMAs and new confirmed EMAs\nlet detectedCross=null;try{if(prevShort!=null&&prevLong!=null){if(prevShort<=prevLong&&newEma9c>newEma26c)detectedCross='bull';else if(prevShort>=prevLong&&newEma9c<newEma26c)detectedCross='bear';else detectedCross=null;}}catch(e){detectedCross=null;}if(detectedCross!=null){if(candidateConfirmedRef.current===detectedCross){candidateCountRef.current=(candidateCountRef.current||0)+1;}else{candidateConfirmedRef.current=detectedCross;candidateCountRef.current=1;}if(candidateCountRef.current>=confirmClosedCandles){if(prevConfirmedRef.current!==detectedCross){prevConfirmedRef.current=detectedCross;setConfirmedCross(detectedCross);setConfirmedSource('poll');if(prevCrossRef.current!==detectedCross){prevCrossRef.current=detectedCross;setCross(detectedCross);}}}}else{candidateConfirmedRef.current=null;candidateCountRef.current=0;}lastProcessedCloseRef.current=k[6];// polling provides closed-candle prices, so update authoritative lastPrice\nsetLastPrice(parseFloat(k[4]));setLastCandleClosed(true);}}}catch(e){// ignore polling errors\n}},10*1000);// poll every 10s\n}}catch(e){}// exponential backoff reconnect with jitter\nconst attempt=reconnectAttemptsRef.current||0;const base=1000;// 1s\nconst delay=Math.min(30000,base*Math.pow(2,attempt));const jitter=Math.floor(Math.random()*1000);reconnectAttemptsRef.current=attempt+1;reconnectTimerRef.current=setTimeout(()=>{reconnectTimerRef.current=null;if(!wsRef.current){// prefer reconnecting to the captured target\nconst target=reconnectTarget||symbol;try{connect(target);}catch(e){connect(target);}}},delay+jitter);// finally clear the currentSymbolRef to reflect that socket is closed\ncurrentSymbolRef.current=null;};},[symbol,fetchAndInit,debug,interval,emaShort,emaLong,confirmClosedCandles]);const disconnect=useCallback(()=>{if(wsRef.current){wsRef.current.close();wsRef.current=null;}setConnected(false);setStatus('disconnected');setActiveSymbol(null);if(pollingTimerRef.current){clearInterval(pollingTimerRef.current);pollingTimerRef.current=null;}// clear reconnect attempts/timers\ntry{reconnectAttemptsRef.current=0;if(reconnectTimerRef.current){clearTimeout(reconnectTimerRef.current);reconnectTimerRef.current=null;}}catch(e){}},[]);useEffect(()=>{// initialize on mount (or when symbol changes)\n// Reset EMA/cross state for the new symbol, but do NOT forcibly close the existing websocket\n// to avoid a visible disconnect during a symbol switch. We keep the socket open until the\n// new connection is established by `connect` (which will replace the old socket).\ntry{// clear reconnect timers and attempts\nif(reconnectTimerRef.current){clearTimeout(reconnectTimerRef.current);reconnectTimerRef.current=null;}reconnectAttemptsRef.current=0;// reset refs and state for EMA and cross (prepare for new seed)\nprevCrossRef.current=null;currentSymbolRef.current=null;ema9Ref.current=null;ema26Ref.current=null;// also clear confirmed/candidate tracking to avoid leaking state between symbols\nema9ConfirmedRef.current=null;ema26ConfirmedRef.current=null;prevConfirmedRef.current=null;candidateConfirmedRef.current=null;candidateCountRef.current=0;lastProcessedCloseRef.current=null;setEma9(null);setEma26(null);setLastPrice(null);setCross(null);setConfirmedCross(null);setLastCandleClosed(false);// Set status to reloading while we fetch/init for the new symbol; do NOT set connected=false here,\n// so the UI remains 'connected' until the replacement socket opens (smoother UX).\nsetStatus('reloading');}catch(e){}// fetch history for the (new) symbol and initialize\nfetchAndInit();// cleanup on unmount\nreturn()=>{if(wsRef.current)wsRef.current.close();if(pollingTimerRef.current){clearInterval(pollingTimerRef.current);pollingTimerRef.current=null;}};},[fetchAndInit]);// auto connect after initialization if requested\nuseEffect(()=>{if(status==='initialized'&&autoConnect){// call connect once after initialization\nconnect();}// only run when status or autoConnect changes\n},[status,autoConnect,connect]);return{ema9,ema26,lastPrice,lastTick,lastCandleClosed,cross,confirmedCross,confirmedSource,connected,status,connect,disconnect,activeSymbol};}","map":{"version":3,"names":["useEffect","useRef","useState","useCallback","calculateInitialEMA","updateEMA","useEmaCross","symbol","autoConnect","debug","interval","emaShort","emaLong","confirmClosedCandles","arguments","length","undefined","ema9","setEma9","ema26","setEma26","lastPrice","setLastPrice","lastTick","setLastTick","console","e","cross","setCross","confirmedCross","setConfirmedCross","confirmedSource","setConfirmedSource","connected","setConnected","status","setStatus","lastCandleClosed","setLastCandleClosed","activeSymbol","setActiveSymbol","wsRef","prevCrossRef","prevConfirmedRef","candidateConfirmedRef","candidateCountRef","ema9Ref","ema26Ref","ema9ConfirmedRef","ema26ConfirmedRef","reconnectAttemptsRef","reconnectTimerRef","currentSymbolRef","lastProcessedCloseRef","pollingTimerRef","normalizeIntervalForBinance","raw","s","String","trim","toLowerCase","allowed","Set","has","numMatch","match","n","Number","concat","mMatch","hMatch","getBinanceInterval","fetchAndInit","target","t","toString","norm","replace","toUpperCase","bi","url","res","fetch","ok","Error","data","json","closes","map","k","parseFloat","shortWindow","Math","max","longWindow","closesLength","initEma9","slice","initEma26","current","initialCross","err","message","error","connect","overrideSymbol","targetSymbol","targetNorm","klineStream","tradeStream","streams","log","ws","WebSocket","oldWs","onopen","clearTimeout","clearInterval","__replaced","close","onmessage","ev","payloadWrapper","JSON","parse","payload","sourceSymbol","stream","streamName","split","event","price","p","newEma9","newEma26","x","c","Boolean","detectedCross","prevShort","prevLong","newEma9c","newEma26c","closeTime","T","ema9Confirmed","ema26Confirmed","ema9Preview","ema26Preview","candidate","candidateConfirmed","candidateCount","required","fallback","onerror","onclose","reconnectTarget","setInterval","sym","newClosed","push","sort","a","b","attempt","base","delay","min","pow","jitter","floor","random","setTimeout","disconnect"],"sources":["C:/Users/e1it3/Desktop/program/binance_alert/src/hooks/useEmaCross.js"],"sourcesContent":["import { useEffect, useRef, useState, useCallback } from 'react';\r\nimport { calculateInitialEMA, updateEMA } from '../utils/ema';\r\n\r\n// Hook options: { symbol }\r\nexport default function useEmaCross({ symbol = 'BTCUSDT', autoConnect = true, debug = false, interval = '1m', emaShort = 9, emaLong = 26, confirmClosedCandles = 1 } = {}) {\r\n  const [ema9, setEma9] = useState(null);\r\n  const [ema26, setEma26] = useState(null);\r\n  const [lastPrice, setLastPrice] = useState(null);\r\n  // lastTick represents the most recent trade/partial-candle price (live preview).\r\n  // lastPrice remains reserved for the most recent CLOSED candle price and is\r\n  // used when emitting confirmed alerts/notifications.\r\n  // eslint-disable-next-line no-unused-vars\r\n  const [lastTick, setLastTick] = useState(null);\r\n\r\n  // when debug is enabled, log lastTick updates so the variable is visibly used\r\n  // inside this module (and also helpful for debugging live preview values).\r\n  useEffect(() => {\r\n    try {\r\n      if (debug && typeof lastTick !== 'undefined' && lastTick !== null) {\r\n        // lightweight debug output\r\n        // eslint-disable-next-line no-console\r\n        console.debug('[useEmaCross] lastTick', lastTick);\r\n      }\r\n    } catch (e) {}\r\n  }, [lastTick, debug]);\r\n  const [cross, setCross] = useState(null); // preview (live) cross\r\n  const [confirmedCross, setConfirmedCross] = useState(null); // only updated on closed candles (confirmed)\r\n  const [confirmedSource, setConfirmedSource] = useState(null); // 'ws' | 'poll' | 'init'\r\n  const [connected, setConnected] = useState(false);\r\n  const [status, setStatus] = useState('idle');\r\n  const [lastCandleClosed, setLastCandleClosed] = useState(false);\r\n  const [activeSymbol, setActiveSymbol] = useState(null); // which symbol the hook has initialized/connected for\r\n\r\n  const wsRef = useRef(null);\r\n  const prevCrossRef = useRef(null);\r\n  const prevConfirmedRef = useRef(null);\r\n  const candidateConfirmedRef = useRef(null);\r\n  const candidateCountRef = useRef(0);\r\n  const ema9Ref = useRef(null);\r\n  const ema26Ref = useRef(null);\r\n  // confirmed EMAs updated only on closed candles (kline.x === true) or polling\r\n  const ema9ConfirmedRef = useRef(null);\r\n  const ema26ConfirmedRef = useRef(null);\r\n  const reconnectAttemptsRef = useRef(0);\r\n  const reconnectTimerRef = useRef(null);\r\n  const currentSymbolRef = useRef(null);\r\n  const lastProcessedCloseRef = useRef(null); // timestamp (ms) of last processed closed candle\r\n  const pollingTimerRef = useRef(null);\r\n\r\n  // Normalize interval strings for Binance API compatibility.\r\n  // Binance accepts tokens like '1m','3m','5m','15m','30m','1h','2h','4h', etc.\r\n  // The app sometimes passes numeric minute strings like '240m' or '240';\r\n  // convert minute multiples of 60 to '4h' style tokens so REST requests don't 400.\r\n  const normalizeIntervalForBinance = (raw) => {\r\n    try {\r\n      let s = String(raw || '').trim();\r\n      if (!s) return s;\r\n      s = s.toLowerCase();\r\n      const allowed = new Set(['1m','3m','5m','15m','30m','1h','2h','4h','6h','8h','12h','1d','3d','1w','1m']);\r\n      if (allowed.has(s)) return s;\r\n      // plain number like '240' -> minutes\r\n      const numMatch = s.match(/^([0-9]+)$/);\r\n      if (numMatch) {\r\n        const n = Number(numMatch[1]);\r\n        if (n % 60 === 0) return `${n/60}h`;\r\n        return `${n}m`;\r\n      }\r\n      // matches like '240m'\r\n      const mMatch = s.match(/^([0-9]+)m$/);\r\n      if (mMatch) {\r\n        const n = Number(mMatch[1]);\r\n        if (n % 60 === 0) return `${n/60}h`;\r\n        return `${n}m`;\r\n      }\r\n      // matches like '4h'\r\n      const hMatch = s.match(/^([0-9]+)h$/);\r\n      if (hMatch) return `${Number(hMatch[1])}h`;\r\n      return s;\r\n    } catch (e) { return String(raw); }\r\n  };\r\n\r\n  const getBinanceInterval = () => normalizeIntervalForBinance(interval);\r\n\r\n  const fetchAndInit = useCallback(async (target = symbol) => {\r\n    try {\r\n      const t = (target || symbol).toString();\r\n      setStatus('fetching historical klines');\r\n      const norm = t.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n  // use Binance Futures (USDT-M) REST endpoint for klines; interval is configurable\r\n  // normalize interval to Binance-accepted token (e.g., convert '240m' -> '4h')\r\n  const bi = getBinanceInterval();\r\n  // request up to 1000 candles to provide long historical context for EMA calculations\r\n  const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${norm}&interval=${bi}&limit=1000`;\r\n    const res = await fetch(url);\r\n      if (!res.ok) throw new Error(`Failed to fetch klines: ${res.status}`);\r\n      const data = await res.json();\r\n      // kline array: [ openTime, open, high, low, close, ... ]\r\n  const closes = data.map((k) => parseFloat(k[4]));\r\n\r\n  if (closes.length < emaLong) throw new Error(`Not enough historical candles to initialize EMA${emaLong}`);\r\n\r\n    // Determine sensible history windows for initial EMA calculation\r\n    const shortWindow = Math.max(emaShort * 10, 100);\r\n    const longWindow = Math.max(emaLong * 12, 300);\r\n\r\n  // Use the close history to compute EMA short/long\r\n  if (debug) console.debug('[useEmaCross] fetchAndInit params', { symbol: norm, interval, emaShort, emaLong, shortWindow, longWindow, closesLength: closes.length });\r\n  const initEma9 = calculateInitialEMA(closes.slice(-shortWindow), emaShort);\r\n  const initEma26 = calculateInitialEMA(closes.slice(-longWindow), emaLong);\r\n\r\n  // initialize both preview and confirmed EMAs from historical closes\r\n  ema9Ref.current = initEma9;\r\n  ema26Ref.current = initEma26;\r\n  ema9ConfirmedRef.current = initEma9;\r\n  ema26ConfirmedRef.current = initEma26;\r\n      // record which symbol these EMAs correspond to\r\n      currentSymbolRef.current = norm;\r\n      setActiveSymbol(norm);\r\n      // record last processed closed candle time (closeTime at index 6)\r\n      try { lastProcessedCloseRef.current = data[data.length - 1][6]; } catch (e) { lastProcessedCloseRef.current = null; }\r\n    setEma9(initEma9);\r\n    setEma26(initEma26);\r\n    setLastPrice(closes[closes.length - 1]);\r\n      setStatus('initialized');\r\n      // set initial cross\r\n    const initialCross = initEma9 > initEma26 ? 'bull' : 'bear';\r\n    if (debug) console.debug('[useEmaCross] initial EMAs', { initEma9, initEma26, initialCross });\r\n      prevCrossRef.current = initialCross;\r\n  setCross(initialCross);\r\n  prevConfirmedRef.current = initialCross;\r\n  setConfirmedCross(initialCross);\r\n  setConfirmedSource('init');\r\n    } catch (err) {\r\n      setStatus(`init error: ${err.message}`);\r\n      console.error(err);\r\n    }\r\n  }, [symbol, interval, emaShort, emaLong, debug]);\r\n\r\n  const connect = useCallback(async (overrideSymbol) => {\r\n    const targetSymbol = (overrideSymbol || symbol).toString();\r\n    const targetNorm = targetSymbol.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n    // if a websocket exists for same symbol, no-op\r\n    if (wsRef.current) {\r\n      if (currentSymbolRef.current === targetNorm) return;\r\n      // do NOT close the existing socket here; create a new socket and let the\r\n      // new socket's onopen handler replace/close the old socket to avoid a\r\n      // brief disconnected state in the UI.\r\n    }\r\n    // Ensure EMA is initialized for the target symbol before connecting\r\n    try {\r\n      const targetNorm = targetSymbol.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n      if (currentSymbolRef.current !== targetNorm || ema9Ref.current == null || ema26Ref.current == null) {\r\n        await fetchAndInit(targetNorm);\r\n      }\r\n    } catch (err) {\r\n      setStatus(`init error: ${err.message}`);\r\n      return;\r\n    }\r\n\r\n    setStatus('connecting websocket');\r\n    // Use combined stream: kline interval (configurable) + aggTrade for higher-frequency trade updates\r\n    const klineStream = `${targetNorm.toLowerCase()}@kline_${getBinanceInterval()}`;\r\n  const tradeStream = `${targetNorm.toLowerCase()}@aggTrade`;\r\n    const streams = `${klineStream}/${tradeStream}`;\r\n  // use Binance Futures (USDT-M) websocket (fstream) combined stream\r\n  const url = `wss://fstream.binance.com/stream?streams=${streams}`;\r\n  console.log('Connecting websocket for', targetSymbol, 'url=', url);\r\n  const ws = new WebSocket(url);\r\n    // Do not overwrite wsRef.current immediately. Create a new socket and only replace the\r\n    // existing one after the new socket successfully opens. This allows a seamless symbol\r\n    // switch without briefly showing disconnected state in the UI.\r\n  const oldWs = wsRef.current;\r\n\r\n    ws.onopen = () => {\r\n      // mark as successful open\r\n      reconnectAttemptsRef.current = 0;\r\n      if (reconnectTimerRef.current) {\r\n        clearTimeout(reconnectTimerRef.current);\r\n        reconnectTimerRef.current = null;\r\n      }\r\n      // stop polling if it was started while socket was down\r\n      if (pollingTimerRef.current) {\r\n        clearInterval(pollingTimerRef.current);\r\n        pollingTimerRef.current = null;\r\n      }\r\n\r\n      // If there was a previous socket, mark it as replaced so its onclose handler\r\n      // skips reconnect logic, then close it.\r\n      try {\r\n        if (oldWs) {\r\n          oldWs.__replaced = true;\r\n          try { oldWs.close(); } catch (e) {}\r\n        }\r\n      } catch (e) {}\r\n\r\n      // now adopt the new socket as the active socket\r\n      wsRef.current = ws;\r\n      currentSymbolRef.current = targetNorm;\r\n      setActiveSymbol(targetNorm);\r\n      if (debug) console.log('[useEmaCross] websocket open for', targetNorm);\r\n  setConnected(true);\r\n  setStatus('connected');\r\n    };\r\n\r\n    ws.onmessage = (ev) => {\r\n      try {\r\n        const payloadWrapper = JSON.parse(ev.data);\r\n        // combined stream returns { stream, data }\r\n        const payload = payloadWrapper.data || payloadWrapper;\r\n\r\n        // determine the source symbol for this message (if available)\r\n        let sourceSymbol = null;\r\n        try {\r\n          if (payload && payload.s) sourceSymbol = payload.s.toString().toUpperCase();\r\n          else if (payloadWrapper && payloadWrapper.stream) {\r\n            const streamName = payloadWrapper.stream.toString(); // e.g. trxusdt@aggTrade\r\n            sourceSymbol = streamName.split('@')[0].toUpperCase();\r\n          }\r\n        } catch (e) { sourceSymbol = null; }\r\n\r\n        // If the message is not for the currently-initialized symbol, ignore it.\r\n        // NOTE: previously we only ignored messages when currentSymbolRef was set;\r\n        // that left a small window during symbol switches where messages could be\r\n        // processed while currentSymbolRef was null. Be stricter: if the message\r\n        // contains a source symbol it must match the initialized symbol, otherwise\r\n        // ignore it.\r\n        if (sourceSymbol) {\r\n          if (!currentSymbolRef.current || currentSymbolRef.current.toString().toUpperCase() !== sourceSymbol.toString().toUpperCase()) {\r\n            return; // ignore messages from other symbols or while switching\r\n          }\r\n        }\r\n\r\n        // aggTrade messages have event type 'aggTrade' and price in p\r\n        if (debug) {\r\n          try {\r\n            const streamName = payloadWrapper.stream || payload.e || 'unknown';\r\n            console.log('[useEmaCross] incoming', { stream: streamName, sourceSymbol, event: payload.e || null });\r\n          } catch (e) {}\r\n        }\r\n        if (payload.e === 'aggTrade') {\r\n          const price = parseFloat(payload.p);\r\n          // update live tick price only; do NOT overwrite the last closed price\r\n          // which should be used for confirmed alerts.\r\n          setLastTick(price);\r\n\r\n          if (ema9Ref.current == null || ema26Ref.current == null) return;\r\n\r\n          // update EMA using trade price to provide higher-frequency preview\r\n          const newEma9 = updateEMA(ema9Ref.current, price, emaShort);\r\n          const newEma26 = updateEMA(ema26Ref.current, price, emaLong);\r\n          // preview EMAs only\r\n          ema9Ref.current = newEma9;\r\n          ema26Ref.current = newEma26;\r\n          setEma9(newEma9);\r\n          setEma26(newEma26);\r\n\r\n          // Do not update `cross` from trade ticks — keep cross decision tied to closed candles.\r\n        }\r\n\r\n        // kline messages contain a 'k' object\r\n        if (payload.k) {\r\n          if (debug) console.log('[useEmaCross] kline payload x=', payload.k.x, 'close=', payload.k.c);\r\n          const k = payload.k;\r\n          const close = parseFloat(k.c);\r\n          // for partial candles, update live tick display; for closed candles\r\n          // update the confirmed lastPrice (closed price) which will be used\r\n          // for confirmedCross/notifications.\r\n          setLastTick(close);\r\n          setLastCandleClosed(Boolean(k.x));\r\n\r\n          // candidate cross detected for this kline (set when closed candle processed)\r\n          let detectedCross = null;\r\n\r\n          if (ema9Ref.current == null || ema26Ref.current == null) return;\r\n\r\n          // update EMA using kline close\r\n          // For partial candle: update preview EMA only\r\n          if (!k.x) {\r\n            const newEma9 = updateEMA(ema9Ref.current, close, emaShort);\r\n            const newEma26 = updateEMA(ema26Ref.current, close, emaLong);\r\n            ema9Ref.current = newEma9;\r\n            ema26Ref.current = newEma26;\r\n            setEma9(newEma9);\r\n            setEma26(newEma26);\r\n            } else {\r\n            // closed candle: update confirmed EMAs only (and sync preview to confirmed)\r\n            if (ema9ConfirmedRef.current == null || ema26ConfirmedRef.current == null) {\r\n              // defensive: fall back to preview if confirmed not initialized\r\n              ema9ConfirmedRef.current = ema9Ref.current;\r\n              ema26ConfirmedRef.current = ema26Ref.current;\r\n            }\r\n            const prevShort = (typeof ema9ConfirmedRef.current === 'number') ? ema9ConfirmedRef.current : null;\r\n            const prevLong = (typeof ema26ConfirmedRef.current === 'number') ? ema26ConfirmedRef.current : null;\r\n            const newEma9c = updateEMA(ema9ConfirmedRef.current, close, emaShort);\r\n            const newEma26c = updateEMA(ema26ConfirmedRef.current, close, emaLong);\r\n            // update confirmed refs\r\n            ema9ConfirmedRef.current = newEma9c;\r\n            ema26ConfirmedRef.current = newEma26c;\r\n            // sync preview to confirmed after closed candle to avoid drift\r\n            ema9Ref.current = newEma9c;\r\n            ema26Ref.current = newEma26c;\r\n            setEma9(newEma9c);\r\n            setEma26(newEma26c);\r\n            // closed candle: also record the closed price as the authoritative lastPrice\r\n            setLastPrice(close);\r\n            // Determine whether an actual cross occurred between the previous confirmed\r\n            // EMAs and the newly computed confirmed EMAs. A cross is defined as a\r\n            // sign change: prevShort <= prevLong && newShort > newLong => golden\r\n            // prevShort >= prevLong && newShort < newLong => dead\r\n            detectedCross = null;\r\n            try {\r\n              if (prevShort != null && prevLong != null) {\r\n                if (prevShort <= prevLong && newEma9c > newEma26c) detectedCross = 'bull';\r\n                else if (prevShort >= prevLong && newEma9c < newEma26c) detectedCross = 'bear';\r\n                else detectedCross = null; // no crossing event\r\n              }\r\n            } catch (e) { detectedCross = null; }\r\n          }\r\n\r\n          // Do not update `cross` for preview/partial candles here; cross will be\r\n          // determined and updated only when a candle is closed (confirmed).\r\n          // If candle is closed (k.x === true) and it's a new closed candle, update processed time and set confirmed cross\r\n          if (Boolean(k.x)) {\r\n            try {\r\n              const closeTime = k.T || k.t || null; // k.T is close time in ms\r\n              if (closeTime && (!lastProcessedCloseRef.current || closeTime > lastProcessedCloseRef.current)) {\r\n                lastProcessedCloseRef.current = closeTime;\r\n                // compute confirmed cross using confirmed EMA refs (fallback to preview values)\r\n                // Only consider a confirmed cross when we detect an actual crossing event\r\n                // between the previous confirmed EMAs and the newly computed confirmed EMAs.\r\n                if (debug) console.debug('[useEmaCross] closed candle detected', { closeTime, close, ema9Confirmed: ema9ConfirmedRef.current, ema26Confirmed: ema26ConfirmedRef.current, ema9Preview: ema9Ref.current, ema26Preview: ema26Ref.current, detectedCross });\r\n                // If we didn't detect an explicit sign-change event, fall back to\r\n                // comparing the current confirmed EMAs. This ensures confirmedCross\r\n                // updates on closed candles even when previous values are not set\r\n                // or edge-cases occur during initialization.\r\n                let candidate = detectedCross;\r\n                if (candidate == null) {\r\n                  if (ema9ConfirmedRef.current != null && ema26ConfirmedRef.current != null) {\r\n                    candidate = (ema9ConfirmedRef.current > ema26ConfirmedRef.current) ? 'bull' : 'bear';\r\n                  }\r\n                }\r\n                if (candidate != null) {\r\n                  if (candidateConfirmedRef.current === candidate) {\r\n                    candidateCountRef.current = (candidateCountRef.current || 0) + 1;\r\n                  } else {\r\n                    candidateConfirmedRef.current = candidate;\r\n                    candidateCountRef.current = 1;\r\n                  }\r\n                  if (debug) console.debug('[useEmaCross] candidateConfirmed state', { candidateConfirmed: candidateConfirmedRef.current, candidateCount: candidateCountRef.current, required: confirmClosedCandles });\r\n                  if (candidateCountRef.current >= confirmClosedCandles) {\r\n                    if (prevConfirmedRef.current !== candidate) {\r\n                      prevConfirmedRef.current = candidate;\r\n                      setConfirmedCross(candidate);\r\n                      setConfirmedSource('ws');\r\n                      // also update public `cross` so UI reflects the closed-candle decision\r\n                      if (prevCrossRef.current !== candidate) {\r\n                        prevCrossRef.current = candidate;\r\n                        setCross(candidate);\r\n                      }\r\n                    }\r\n                  }\r\n                } else {\r\n                  // No crossing event: reset candidate tracking so we only detect real cross events\r\n                  candidateConfirmedRef.current = null;\r\n                  candidateCountRef.current = 0;\r\n                }\r\n                \r\n              }\r\n              } catch (e) {\r\n              // fallback: if we couldn't compute confirmed EMAs, fall back to\r\n              // preview EMAs (if available) to set a confirmed-like value.\r\n              const fallback = (ema9Ref.current != null && ema26Ref.current != null) ? (ema9Ref.current > ema26Ref.current ? 'bull' : 'bear') : null;\r\n              if (fallback && prevConfirmedRef.current !== fallback) {\r\n                prevConfirmedRef.current = fallback;\r\n                setConfirmedCross(fallback);\r\n                setConfirmedSource('ws');\r\n              }\r\n            }\r\n          } else {\r\n            // partial candle: preview already updated above\r\n          }\r\n        }\r\n      } catch (err) {\r\n        console.error('ws message parse error', err);\r\n      }\r\n    };\r\n\r\n    ws.onerror = (e) => {\r\n      // if this socket was intentionally replaced by a new one, ignore errors\r\n      if (ws.__replaced) {\r\n        if (debug) console.log('[useEmaCross] ignored error on replaced socket');\r\n        return;\r\n      }\r\n      console.error('ws error', e);\r\n      setStatus('websocket error');\r\n      // close to trigger backoff reconnect\r\n      try { ws.close(); } catch (err) {}\r\n    };\r\n\r\n    ws.onclose = () => {\r\n      // if this socket was intentionally replaced by a new one, skip close handling\r\n      if (ws.__replaced) {\r\n        if (debug) console.log('[useEmaCross] websocket was replaced; skipping onclose handling');\r\n        return;\r\n      }\r\n      setConnected(false);\r\n      setStatus('websocket closed');\r\n      wsRef.current = null;\r\n      if (debug) console.log('[useEmaCross] websocket closed');\r\n\r\n      // capture intended reconnect target now (before we nullify refs)\r\n      const reconnectTarget = currentSymbolRef.current || symbol;\r\n      // clear active symbol immediately for UI, but keep reconnectTarget for retries\r\n      setActiveSymbol(null);\r\n\r\n      // start polling for closed candles while websocket is down\r\n      try {\r\n        if (!pollingTimerRef.current) {\r\n              pollingTimerRef.current = setInterval(async () => {\r\n            try {\r\n              const sym = (reconnectTarget || symbol || '').replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n              if (!sym) return;\r\n                  const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${sym}&interval=${getBinanceInterval()}&limit=10`;\r\n              const res = await fetch(url);\r\n              if (!res.ok) return;\r\n              const data = await res.json();\r\n              // iterate candles in chronological order and process any closed candles newer than lastProcessedCloseRef\r\n              const newClosed = [];\r\n              for (const k of data) {\r\n                const closeTime = k[6];\r\n                if (closeTime && (!lastProcessedCloseRef.current || closeTime > lastProcessedCloseRef.current)) {\r\n                  newClosed.push(k);\r\n                }\r\n              }\r\n                if (newClosed.length > 0) {\r\n                // sort by closeTime asc\r\n                newClosed.sort((a, b) => a[6] - b[6]);\r\n                  for (const k of newClosed) {\r\n                  const close = parseFloat(k[4]);\r\n                  // update EMAs using closed candle\r\n                  if (ema9Ref.current == null || ema26Ref.current == null) continue;\r\n                  // update confirmed EMAs using closed candle (polling)\r\n                  if (ema9ConfirmedRef.current == null || ema26ConfirmedRef.current == null) {\r\n                    ema9ConfirmedRef.current = ema9Ref.current;\r\n                    ema26ConfirmedRef.current = ema26Ref.current;\r\n                  }\r\n                  const prevShort = (typeof ema9ConfirmedRef.current === 'number') ? ema9ConfirmedRef.current : null;\r\n                  const prevLong = (typeof ema26ConfirmedRef.current === 'number') ? ema26ConfirmedRef.current : null;\r\n                  const newEma9c = updateEMA(ema9ConfirmedRef.current, close, emaShort);\r\n                  const newEma26c = updateEMA(ema26ConfirmedRef.current, close, emaLong);\r\n                  ema9ConfirmedRef.current = newEma9c;\r\n                  ema26ConfirmedRef.current = newEma26c;\r\n                  // sync preview to confirmed\r\n                  ema9Ref.current = newEma9c;\r\n                  ema26Ref.current = newEma26c;\r\n                  setEma9(newEma9c);\r\n                  setEma26(newEma26c);\r\n                  // detect actual crossing event between previous confirmed EMAs and new confirmed EMAs\r\n                  let detectedCross = null;\r\n                  try {\r\n                    if (prevShort != null && prevLong != null) {\r\n                      if (prevShort <= prevLong && newEma9c > newEma26c) detectedCross = 'bull';\r\n                      else if (prevShort >= prevLong && newEma9c < newEma26c) detectedCross = 'bear';\r\n                      else detectedCross = null;\r\n                    }\r\n                  } catch (e) { detectedCross = null; }\r\n                  if (detectedCross != null) {\r\n                    if (candidateConfirmedRef.current === detectedCross) {\r\n                      candidateCountRef.current = (candidateCountRef.current || 0) + 1;\r\n                    } else {\r\n                      candidateConfirmedRef.current = detectedCross;\r\n                      candidateCountRef.current = 1;\r\n                    }\r\n                    if (candidateCountRef.current >= confirmClosedCandles) {\r\n                      if (prevConfirmedRef.current !== detectedCross) {\r\n                        prevConfirmedRef.current = detectedCross;\r\n                        setConfirmedCross(detectedCross);\r\n                        setConfirmedSource('poll');\r\n                        if (prevCrossRef.current !== detectedCross) {\r\n                          prevCrossRef.current = detectedCross;\r\n                          setCross(detectedCross);\r\n                        }\r\n                      }\r\n                    }\r\n                  } else {\r\n                    candidateConfirmedRef.current = null;\r\n                    candidateCountRef.current = 0;\r\n                  }\r\n                  lastProcessedCloseRef.current = k[6];\r\n                  // polling provides closed-candle prices, so update authoritative lastPrice\r\n                  setLastPrice(parseFloat(k[4]));\r\n                  setLastCandleClosed(true);\r\n                }\r\n              }\r\n            } catch (e) {\r\n              // ignore polling errors\r\n            }\r\n          }, 10 * 1000); // poll every 10s\r\n        }\r\n      } catch (e) {}\r\n\r\n      // exponential backoff reconnect with jitter\r\n      const attempt = reconnectAttemptsRef.current || 0;\r\n      const base = 1000; // 1s\r\n      const delay = Math.min(30000, base * Math.pow(2, attempt));\r\n      const jitter = Math.floor(Math.random() * 1000);\r\n      reconnectAttemptsRef.current = attempt + 1;\r\n      reconnectTimerRef.current = setTimeout(() => {\r\n        reconnectTimerRef.current = null;\r\n        if (!wsRef.current) {\r\n          // prefer reconnecting to the captured target\r\n          const target = reconnectTarget || symbol;\r\n          try { connect(target); } catch (e) { connect(target); }\r\n        }\r\n      }, delay + jitter);\r\n\r\n      // finally clear the currentSymbolRef to reflect that socket is closed\r\n      currentSymbolRef.current = null;\r\n    };\r\n  }, [symbol, fetchAndInit, debug, interval, emaShort, emaLong, confirmClosedCandles]);\r\n\r\n  const disconnect = useCallback(() => {\r\n    if (wsRef.current) {\r\n      wsRef.current.close();\r\n      wsRef.current = null;\r\n    }\r\n    setConnected(false);\r\n    setStatus('disconnected');\r\n    setActiveSymbol(null);\r\n    if (pollingTimerRef.current) {\r\n      clearInterval(pollingTimerRef.current);\r\n      pollingTimerRef.current = null;\r\n    }\r\n    // clear reconnect attempts/timers\r\n    try {\r\n      reconnectAttemptsRef.current = 0;\r\n      if (reconnectTimerRef.current) {\r\n        clearTimeout(reconnectTimerRef.current);\r\n        reconnectTimerRef.current = null;\r\n      }\r\n    } catch (e) {}\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    // initialize on mount (or when symbol changes)\r\n    // Reset EMA/cross state for the new symbol, but do NOT forcibly close the existing websocket\r\n    // to avoid a visible disconnect during a symbol switch. We keep the socket open until the\r\n    // new connection is established by `connect` (which will replace the old socket).\r\n    try {\r\n      // clear reconnect timers and attempts\r\n      if (reconnectTimerRef.current) {\r\n        clearTimeout(reconnectTimerRef.current);\r\n        reconnectTimerRef.current = null;\r\n      }\r\n      reconnectAttemptsRef.current = 0;\r\n\r\n      // reset refs and state for EMA and cross (prepare for new seed)\r\n      prevCrossRef.current = null;\r\n      currentSymbolRef.current = null;\r\n      ema9Ref.current = null;\r\n      ema26Ref.current = null;\r\n      // also clear confirmed/candidate tracking to avoid leaking state between symbols\r\n      ema9ConfirmedRef.current = null;\r\n      ema26ConfirmedRef.current = null;\r\n      prevConfirmedRef.current = null;\r\n      candidateConfirmedRef.current = null;\r\n      candidateCountRef.current = 0;\r\n      lastProcessedCloseRef.current = null;\r\n      setEma9(null);\r\n      setEma26(null);\r\n      setLastPrice(null);\r\n      setCross(null);\r\n      setConfirmedCross(null);\r\n      setLastCandleClosed(false);\r\n      // Set status to reloading while we fetch/init for the new symbol; do NOT set connected=false here,\r\n      // so the UI remains 'connected' until the replacement socket opens (smoother UX).\r\n      setStatus('reloading');\r\n    } catch (e) {}\r\n    // fetch history for the (new) symbol and initialize\r\n    fetchAndInit();\r\n    // cleanup on unmount\r\n    return () => {\r\n      if (wsRef.current) wsRef.current.close();\r\n      if (pollingTimerRef.current) {\r\n        clearInterval(pollingTimerRef.current);\r\n        pollingTimerRef.current = null;\r\n      }\r\n    };\r\n  }, [fetchAndInit]);\r\n\r\n  // auto connect after initialization if requested\r\n  useEffect(() => {\r\n    if (status === 'initialized' && autoConnect) {\r\n      // call connect once after initialization\r\n      connect();\r\n    }\r\n    // only run when status or autoConnect changes\r\n  }, [status, autoConnect, connect]);\r\n\r\n  return {\r\n    ema9,\r\n    ema26,\r\n    lastPrice,\r\n    lastTick,\r\n    lastCandleClosed,\r\n    cross,\r\n    confirmedCross,\r\n    confirmedSource,\r\n    connected,\r\n    status,\r\n    connect,\r\n    disconnect,\r\n    activeSymbol,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}