{"ast":null,"code":"import{useEffect,useRef,useState,useCallback}from'react';import{calculateInitialEMA,updateEMA}from'../utils/ema';// Hook options: { symbol }\nexport default function useEmaCross(){let{symbol='BTCUSDT',autoConnect=true,debug=false,interval='1m',emaShort=9,emaLong=26,confirmClosedCandles=1}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const[ema9,setEma9]=useState(null);const[ema26,setEma26]=useState(null);const[lastPrice,setLastPrice]=useState(null);// lastTick represents the most recent trade/partial-candle price (live preview).\n// lastPrice remains reserved for the most recent CLOSED candle price and is\n// used when emitting confirmed alerts/notifications.\n// eslint-disable-next-line no-unused-vars\nconst[lastTick,setLastTick]=useState(null);// when debug is enabled, log lastTick updates so the variable is visibly used\n// inside this module (and also helpful for debugging live preview values).\nuseEffect(()=>{try{if(debug&&typeof lastTick!=='undefined'&&lastTick!==null){// lightweight debug output\n// eslint-disable-next-line no-console\nconsole.debug('[useEmaCross] lastTick',lastTick);}}catch(e){}},[lastTick,debug]);const[cross,setCross]=useState(null);// preview (live) cross\nconst[confirmedCross,setConfirmedCross]=useState(null);// only updated on closed candles (confirmed)\nconst[confirmedSource,setConfirmedSource]=useState(null);// 'ws' | 'poll' | 'init'\nconst[connected,setConnected]=useState(false);const[status,setStatus]=useState('idle');const[lastCandleClosed,setLastCandleClosed]=useState(false);const[activeSymbol,setActiveSymbol]=useState(null);// which symbol the hook has initialized/connected for\nconst wsRef=useRef(null);const prevCrossRef=useRef(null);const prevConfirmedRef=useRef(null);const candidateConfirmedRef=useRef(null);const candidateCountRef=useRef(0);const ema9Ref=useRef(null);const ema26Ref=useRef(null);// confirmed EMAs updated only on closed candles (kline.x === true) or polling\nconst ema9ConfirmedRef=useRef(null);const ema26ConfirmedRef=useRef(null);const reconnectAttemptsRef=useRef(0);const reconnectTimerRef=useRef(null);const currentSymbolRef=useRef(null);const lastProcessedCloseRef=useRef(null);// timestamp (ms) of last processed closed candle\nconst pollingTimerRef=useRef(null);const fetchAndInit=useCallback(async function(){let target=arguments.length>0&&arguments[0]!==undefined?arguments[0]:symbol;try{const t=(target||symbol).toString();setStatus('fetching historical klines');const norm=t.replace(/[^A-Za-z0-9]/g,'').toUpperCase();// use Binance Futures (USDT-M) REST endpoint for klines; interval is configurable\nconst url=\"https://fapi.binance.com/fapi/v1/klines?symbol=\".concat(norm,\"&interval=\").concat(interval,\"&limit=500\");const res=await fetch(url);if(!res.ok)throw new Error(\"Failed to fetch klines: \".concat(res.status));const data=await res.json();// kline array: [ openTime, open, high, low, close, ... ]\nconst closes=data.map(k=>parseFloat(k[4]));if(closes.length<emaLong)throw new Error(\"Not enough historical candles to initialize EMA\".concat(emaLong));// Determine sensible history windows for initial EMA calculation\nconst shortWindow=Math.max(emaShort*10,100);const longWindow=Math.max(emaLong*12,300);// Use the close history to compute EMA short/long\nif(debug)console.debug('[useEmaCross] fetchAndInit params',{symbol:norm,interval,emaShort,emaLong,shortWindow,longWindow,closesLength:closes.length});const initEma9=calculateInitialEMA(closes.slice(-shortWindow),emaShort);const initEma26=calculateInitialEMA(closes.slice(-longWindow),emaLong);// initialize both preview and confirmed EMAs from historical closes\nema9Ref.current=initEma9;ema26Ref.current=initEma26;ema9ConfirmedRef.current=initEma9;ema26ConfirmedRef.current=initEma26;// record which symbol these EMAs correspond to\ncurrentSymbolRef.current=norm;setActiveSymbol(norm);// record last processed closed candle time (closeTime at index 6)\ntry{lastProcessedCloseRef.current=data[data.length-1][6];}catch(e){lastProcessedCloseRef.current=null;}setEma9(initEma9);setEma26(initEma26);setLastPrice(closes[closes.length-1]);setStatus('initialized');// set initial cross\nconst initialCross=initEma9>initEma26?'bull':'bear';if(debug)console.debug('[useEmaCross] initial EMAs',{initEma9,initEma26,initialCross});prevCrossRef.current=initialCross;setCross(initialCross);prevConfirmedRef.current=initialCross;setConfirmedCross(initialCross);setConfirmedSource('init');}catch(err){setStatus(\"init error: \".concat(err.message));console.error(err);}},[symbol,interval,emaShort,emaLong,debug]);const connect=useCallback(async overrideSymbol=>{const targetSymbol=(overrideSymbol||symbol).toString();const targetNorm=targetSymbol.replace(/[^A-Za-z0-9]/g,'').toUpperCase();// if a websocket exists for same symbol, no-op\nif(wsRef.current){if(currentSymbolRef.current===targetNorm)return;// do NOT close the existing socket here; create a new socket and let the\n// new socket's onopen handler replace/close the old socket to avoid a\n// brief disconnected state in the UI.\n}// Ensure EMA is initialized for the target symbol before connecting\ntry{const targetNorm=targetSymbol.replace(/[^A-Za-z0-9]/g,'').toUpperCase();if(currentSymbolRef.current!==targetNorm||ema9Ref.current==null||ema26Ref.current==null){await fetchAndInit(targetNorm);}}catch(err){setStatus(\"init error: \".concat(err.message));return;}setStatus('connecting websocket');// Use combined stream: kline interval (configurable) + aggTrade for higher-frequency trade updates\nconst klineStream=\"\".concat(targetNorm.toLowerCase(),\"@kline_\").concat(String(interval));const tradeStream=\"\".concat(targetNorm.toLowerCase(),\"@aggTrade\");const streams=\"\".concat(klineStream,\"/\").concat(tradeStream);// use Binance Futures (USDT-M) websocket (fstream) combined stream\nconst url=\"wss://fstream.binance.com/stream?streams=\".concat(streams);console.log('Connecting websocket for',targetSymbol,'url=',url);const ws=new WebSocket(url);// Do not overwrite wsRef.current immediately. Create a new socket and only replace the\n// existing one after the new socket successfully opens. This allows a seamless symbol\n// switch without briefly showing disconnected state in the UI.\nconst oldWs=wsRef.current;ws.onopen=()=>{// mark as successful open\nreconnectAttemptsRef.current=0;if(reconnectTimerRef.current){clearTimeout(reconnectTimerRef.current);reconnectTimerRef.current=null;}// stop polling if it was started while socket was down\nif(pollingTimerRef.current){clearInterval(pollingTimerRef.current);pollingTimerRef.current=null;}// If there was a previous socket, mark it as replaced so its onclose handler\n// skips reconnect logic, then close it.\ntry{if(oldWs){oldWs.__replaced=true;try{oldWs.close();}catch(e){}}}catch(e){}// now adopt the new socket as the active socket\nwsRef.current=ws;currentSymbolRef.current=targetNorm;setActiveSymbol(targetNorm);if(debug)console.log('[useEmaCross] websocket open for',targetNorm);setConnected(true);setStatus('connected');};ws.onmessage=ev=>{try{const payloadWrapper=JSON.parse(ev.data);// combined stream returns { stream, data }\nconst payload=payloadWrapper.data||payloadWrapper;// determine the source symbol for this message (if available)\nlet sourceSymbol=null;try{if(payload&&payload.s)sourceSymbol=payload.s.toString().toUpperCase();else if(payloadWrapper&&payloadWrapper.stream){const streamName=payloadWrapper.stream.toString();// e.g. trxusdt@aggTrade\nsourceSymbol=streamName.split('@')[0].toUpperCase();}}catch(e){sourceSymbol=null;}// If the message is not for the currently-initialized symbol, ignore it.\n// NOTE: previously we only ignored messages when currentSymbolRef was set;\n// that left a small window during symbol switches where messages could be\n// processed while currentSymbolRef was null. Be stricter: if the message\n// contains a source symbol it must match the initialized symbol, otherwise\n// ignore it.\nif(sourceSymbol){if(!currentSymbolRef.current||currentSymbolRef.current.toString().toUpperCase()!==sourceSymbol.toString().toUpperCase()){return;// ignore messages from other symbols or while switching\n}}// aggTrade messages have event type 'aggTrade' and price in p\nif(debug){try{const streamName=payloadWrapper.stream||payload.e||'unknown';console.log('[useEmaCross] incoming',{stream:streamName,sourceSymbol,event:payload.e||null});}catch(e){}}if(payload.e==='aggTrade'){const price=parseFloat(payload.p);// update live tick price only; do NOT overwrite the last closed price\n// which should be used for confirmed alerts.\nsetLastTick(price);if(ema9Ref.current==null||ema26Ref.current==null)return;// update EMA using trade price to provide higher-frequency preview\nconst newEma9=updateEMA(ema9Ref.current,price,emaShort);const newEma26=updateEMA(ema26Ref.current,price,emaLong);// preview EMAs only\nema9Ref.current=newEma9;ema26Ref.current=newEma26;setEma9(newEma9);setEma26(newEma26);// Do not update `cross` from trade ticks — keep cross decision tied to closed candles.\n}// kline messages contain a 'k' object\nif(payload.k){if(debug)console.log('[useEmaCross] kline payload x=',payload.k.x,'close=',payload.k.c);const k=payload.k;const close=parseFloat(k.c);// for partial candles, update live tick display; for closed candles\n// update the confirmed lastPrice (closed price) which will be used\n// for confirmedCross/notifications.\nsetLastTick(close);setLastCandleClosed(Boolean(k.x));if(ema9Ref.current==null||ema26Ref.current==null)return;// update EMA using kline close\n// For partial candle: update preview EMA only\nif(!k.x){const newEma9=updateEMA(ema9Ref.current,close,emaShort);const newEma26=updateEMA(ema26Ref.current,close,emaLong);ema9Ref.current=newEma9;ema26Ref.current=newEma26;setEma9(newEma9);setEma26(newEma26);}else{// closed candle: update confirmed EMAs only (and sync preview to confirmed)\nif(ema9ConfirmedRef.current==null||ema26ConfirmedRef.current==null){// defensive: fall back to preview if confirmed not initialized\nema9ConfirmedRef.current=ema9Ref.current;ema26ConfirmedRef.current=ema26Ref.current;}const prevShort=typeof ema9ConfirmedRef.current==='number'?ema9ConfirmedRef.current:null;const prevLong=typeof ema26ConfirmedRef.current==='number'?ema26ConfirmedRef.current:null;const newEma9c=updateEMA(ema9ConfirmedRef.current,close,emaShort);const newEma26c=updateEMA(ema26ConfirmedRef.current,close,emaLong);// update confirmed refs\nema9ConfirmedRef.current=newEma9c;ema26ConfirmedRef.current=newEma26c;// sync preview to confirmed after closed candle to avoid drift\nema9Ref.current=newEma9c;ema26Ref.current=newEma26c;setEma9(newEma9c);setEma26(newEma26c);// closed candle: also record the closed price as the authoritative lastPrice\nsetLastPrice(close);// Determine whether an actual cross occurred between the previous confirmed\n// EMAs and the newly computed confirmed EMAs. A cross is defined as a\n// sign change: prevShort <= prevLong && newShort > newLong => golden\n// prevShort >= prevLong && newShort < newLong => dead\nlet detectedCross=null;try{if(prevShort!=null&&prevLong!=null){if(prevShort<=prevLong&&newEma9c>newEma26c)detectedCross='bull';else if(prevShort>=prevLong&&newEma9c<newEma26c)detectedCross='bear';else detectedCross=null;// no crossing event\n}}catch(e){detectedCross=null;}}// Do not update `cross` for preview/partial candles here; cross will be\n// determined and updated only when a candle is closed (confirmed).\n// If candle is closed (k.x === true) and it's a new closed candle, update processed time and set confirmed cross\nif(Boolean(k.x)){try{const closeTime=k.T||k.t||null;// k.T is close time in ms\nif(closeTime&&(!lastProcessedCloseRef.current||closeTime>lastProcessedCloseRef.current)){lastProcessedCloseRef.current=closeTime;// compute confirmed cross using confirmed EMA refs (fallback to preview values)\n// Only consider a confirmed cross when we detect an actual crossing event\n// between the previous confirmed EMAs and the newly computed confirmed EMAs.\nif(debug)console.debug('[useEmaCross] closed candle detected',{closeTime,close,ema9Confirmed:ema9ConfirmedRef.current,ema26Confirmed:ema26ConfirmedRef.current,ema9Preview:ema9Ref.current,ema26Preview:ema26Ref.current,detectedCross});if(detectedCross!=null){if(candidateConfirmedRef.current===detectedCross){candidateCountRef.current=(candidateCountRef.current||0)+1;}else{candidateConfirmedRef.current=detectedCross;candidateCountRef.current=1;}if(debug)console.debug('[useEmaCross] candidateConfirmed state',{candidateConfirmed:candidateConfirmedRef.current,candidateCount:candidateCountRef.current,required:confirmClosedCandles});if(candidateCountRef.current>=confirmClosedCandles){if(prevConfirmedRef.current!==detectedCross){prevConfirmedRef.current=detectedCross;setConfirmedCross(detectedCross);setConfirmedSource('ws');// also update public `cross` so UI reflects the closed-candle decision\nif(prevCrossRef.current!==detectedCross){prevCrossRef.current=detectedCross;setCross(detectedCross);}}}}else{// No crossing event: reset candidate tracking so we only detect real cross events\ncandidateConfirmedRef.current=null;candidateCountRef.current=0;}}}catch(e){// fallback: if we couldn't compute confirmed EMAs, fall back to\n// preview EMAs (if available) to set a confirmed-like value.\nconst fallback=ema9Ref.current!=null&&ema26Ref.current!=null?ema9Ref.current>ema26Ref.current?'bull':'bear':null;if(fallback&&prevConfirmedRef.current!==fallback){prevConfirmedRef.current=fallback;setConfirmedCross(fallback);setConfirmedSource('ws');}}}else{// partial candle: preview already updated above\n}}}catch(err){console.error('ws message parse error',err);}};ws.onerror=e=>{// if this socket was intentionally replaced by a new one, ignore errors\nif(ws.__replaced){if(debug)console.log('[useEmaCross] ignored error on replaced socket');return;}console.error('ws error',e);setStatus('websocket error');// close to trigger backoff reconnect\ntry{ws.close();}catch(err){}};ws.onclose=()=>{// if this socket was intentionally replaced by a new one, skip close handling\nif(ws.__replaced){if(debug)console.log('[useEmaCross] websocket was replaced; skipping onclose handling');return;}setConnected(false);setStatus('websocket closed');wsRef.current=null;if(debug)console.log('[useEmaCross] websocket closed');// capture intended reconnect target now (before we nullify refs)\nconst reconnectTarget=currentSymbolRef.current||symbol;// clear active symbol immediately for UI, but keep reconnectTarget for retries\nsetActiveSymbol(null);// start polling for closed candles while websocket is down\ntry{if(!pollingTimerRef.current){pollingTimerRef.current=setInterval(async()=>{try{const sym=(reconnectTarget||symbol||'').replace(/[^A-Za-z0-9]/g,'').toUpperCase();if(!sym)return;const url=\"https://fapi.binance.com/fapi/v1/klines?symbol=\".concat(sym,\"&interval=\").concat(interval,\"&limit=10\");const res=await fetch(url);if(!res.ok)return;const data=await res.json();// iterate candles in chronological order and process any closed candles newer than lastProcessedCloseRef\nconst newClosed=[];for(const k of data){const closeTime=k[6];if(closeTime&&(!lastProcessedCloseRef.current||closeTime>lastProcessedCloseRef.current)){newClosed.push(k);}}if(newClosed.length>0){// sort by closeTime asc\nnewClosed.sort((a,b)=>a[6]-b[6]);for(const k of newClosed){const close=parseFloat(k[4]);// update EMAs using closed candle\nif(ema9Ref.current==null||ema26Ref.current==null)continue;// update confirmed EMAs using closed candle (polling)\nif(ema9ConfirmedRef.current==null||ema26ConfirmedRef.current==null){ema9ConfirmedRef.current=ema9Ref.current;ema26ConfirmedRef.current=ema26Ref.current;}const prevShort=typeof ema9ConfirmedRef.current==='number'?ema9ConfirmedRef.current:null;const prevLong=typeof ema26ConfirmedRef.current==='number'?ema26ConfirmedRef.current:null;const newEma9c=updateEMA(ema9ConfirmedRef.current,close,emaShort);const newEma26c=updateEMA(ema26ConfirmedRef.current,close,emaLong);ema9ConfirmedRef.current=newEma9c;ema26ConfirmedRef.current=newEma26c;// sync preview to confirmed\nema9Ref.current=newEma9c;ema26Ref.current=newEma26c;setEma9(newEma9c);setEma26(newEma26c);// detect actual crossing event between previous confirmed EMAs and new confirmed EMAs\nlet detectedCross=null;try{if(prevShort!=null&&prevLong!=null){if(prevShort<=prevLong&&newEma9c>newEma26c)detectedCross='bull';else if(prevShort>=prevLong&&newEma9c<newEma26c)detectedCross='bear';else detectedCross=null;}}catch(e){detectedCross=null;}if(detectedCross!=null){if(candidateConfirmedRef.current===detectedCross){candidateCountRef.current=(candidateCountRef.current||0)+1;}else{candidateConfirmedRef.current=detectedCross;candidateCountRef.current=1;}if(candidateCountRef.current>=confirmClosedCandles){if(prevConfirmedRef.current!==detectedCross){prevConfirmedRef.current=detectedCross;setConfirmedCross(detectedCross);setConfirmedSource('poll');if(prevCrossRef.current!==detectedCross){prevCrossRef.current=detectedCross;setCross(detectedCross);}}}}else{candidateConfirmedRef.current=null;candidateCountRef.current=0;}lastProcessedCloseRef.current=k[6];// polling provides closed-candle prices, so update authoritative lastPrice\nsetLastPrice(parseFloat(k[4]));setLastCandleClosed(true);}}}catch(e){// ignore polling errors\n}},10*1000);// poll every 10s\n}}catch(e){}// exponential backoff reconnect with jitter\nconst attempt=reconnectAttemptsRef.current||0;const base=1000;// 1s\nconst delay=Math.min(30000,base*Math.pow(2,attempt));const jitter=Math.floor(Math.random()*1000);reconnectAttemptsRef.current=attempt+1;reconnectTimerRef.current=setTimeout(()=>{reconnectTimerRef.current=null;if(!wsRef.current){// prefer reconnecting to the captured target\nconst target=reconnectTarget||symbol;try{connect(target);}catch(e){connect(target);}}},delay+jitter);// finally clear the currentSymbolRef to reflect that socket is closed\ncurrentSymbolRef.current=null;};},[symbol,fetchAndInit,debug,interval,emaShort,emaLong,confirmClosedCandles]);const disconnect=useCallback(()=>{if(wsRef.current){wsRef.current.close();wsRef.current=null;}setConnected(false);setStatus('disconnected');setActiveSymbol(null);if(pollingTimerRef.current){clearInterval(pollingTimerRef.current);pollingTimerRef.current=null;}// clear reconnect attempts/timers\ntry{reconnectAttemptsRef.current=0;if(reconnectTimerRef.current){clearTimeout(reconnectTimerRef.current);reconnectTimerRef.current=null;}}catch(e){}},[]);useEffect(()=>{// initialize on mount (or when symbol changes)\n// Reset EMA/cross state for the new symbol, but do NOT forcibly close the existing websocket\n// to avoid a visible disconnect during a symbol switch. We keep the socket open until the\n// new connection is established by `connect` (which will replace the old socket).\ntry{// clear reconnect timers and attempts\nif(reconnectTimerRef.current){clearTimeout(reconnectTimerRef.current);reconnectTimerRef.current=null;}reconnectAttemptsRef.current=0;// reset refs and state for EMA and cross (prepare for new seed)\nprevCrossRef.current=null;currentSymbolRef.current=null;ema9Ref.current=null;ema26Ref.current=null;// also clear confirmed/candidate tracking to avoid leaking state between symbols\nema9ConfirmedRef.current=null;ema26ConfirmedRef.current=null;prevConfirmedRef.current=null;candidateConfirmedRef.current=null;candidateCountRef.current=0;lastProcessedCloseRef.current=null;setEma9(null);setEma26(null);setLastPrice(null);setCross(null);setConfirmedCross(null);setLastCandleClosed(false);// Set status to reloading while we fetch/init for the new symbol; do NOT set connected=false here,\n// so the UI remains 'connected' until the replacement socket opens (smoother UX).\nsetStatus('reloading');}catch(e){}// fetch history for the (new) symbol and initialize\nfetchAndInit();// cleanup on unmount\nreturn()=>{if(wsRef.current)wsRef.current.close();if(pollingTimerRef.current){clearInterval(pollingTimerRef.current);pollingTimerRef.current=null;}};},[fetchAndInit]);// auto connect after initialization if requested\nuseEffect(()=>{if(status==='initialized'&&autoConnect){// call connect once after initialization\nconnect();}// only run when status or autoConnect changes\n},[status,autoConnect,connect]);return{ema9,ema26,lastPrice,lastTick,lastCandleClosed,cross,confirmedCross,confirmedSource,connected,status,connect,disconnect,activeSymbol};}","map":{"version":3,"names":["useEffect","useRef","useState","useCallback","calculateInitialEMA","updateEMA","useEmaCross","symbol","autoConnect","debug","interval","emaShort","emaLong","confirmClosedCandles","arguments","length","undefined","ema9","setEma9","ema26","setEma26","lastPrice","setLastPrice","lastTick","setLastTick","console","e","cross","setCross","confirmedCross","setConfirmedCross","confirmedSource","setConfirmedSource","connected","setConnected","status","setStatus","lastCandleClosed","setLastCandleClosed","activeSymbol","setActiveSymbol","wsRef","prevCrossRef","prevConfirmedRef","candidateConfirmedRef","candidateCountRef","ema9Ref","ema26Ref","ema9ConfirmedRef","ema26ConfirmedRef","reconnectAttemptsRef","reconnectTimerRef","currentSymbolRef","lastProcessedCloseRef","pollingTimerRef","fetchAndInit","target","t","toString","norm","replace","toUpperCase","url","concat","res","fetch","ok","Error","data","json","closes","map","k","parseFloat","shortWindow","Math","max","longWindow","closesLength","initEma9","slice","initEma26","current","initialCross","err","message","error","connect","overrideSymbol","targetSymbol","targetNorm","klineStream","toLowerCase","String","tradeStream","streams","log","ws","WebSocket","oldWs","onopen","clearTimeout","clearInterval","__replaced","close","onmessage","ev","payloadWrapper","JSON","parse","payload","sourceSymbol","s","stream","streamName","split","event","price","p","newEma9","newEma26","x","c","Boolean","prevShort","prevLong","newEma9c","newEma26c","detectedCross","closeTime","T","ema9Confirmed","ema26Confirmed","ema9Preview","ema26Preview","candidateConfirmed","candidateCount","required","fallback","onerror","onclose","reconnectTarget","setInterval","sym","newClosed","push","sort","a","b","attempt","base","delay","min","pow","jitter","floor","random","setTimeout","disconnect"],"sources":["C:/Users/e1it3/Desktop/program/binance_alert/src/hooks/useEmaCross.js"],"sourcesContent":["import { useEffect, useRef, useState, useCallback } from 'react';\r\nimport { calculateInitialEMA, updateEMA } from '../utils/ema';\r\n\r\n// Hook options: { symbol }\r\nexport default function useEmaCross({ symbol = 'BTCUSDT', autoConnect = true, debug = false, interval = '1m', emaShort = 9, emaLong = 26, confirmClosedCandles = 1 } = {}) {\r\n  const [ema9, setEma9] = useState(null);\r\n  const [ema26, setEma26] = useState(null);\r\n  const [lastPrice, setLastPrice] = useState(null);\r\n  // lastTick represents the most recent trade/partial-candle price (live preview).\r\n  // lastPrice remains reserved for the most recent CLOSED candle price and is\r\n  // used when emitting confirmed alerts/notifications.\r\n  // eslint-disable-next-line no-unused-vars\r\n  const [lastTick, setLastTick] = useState(null);\r\n\r\n  // when debug is enabled, log lastTick updates so the variable is visibly used\r\n  // inside this module (and also helpful for debugging live preview values).\r\n  useEffect(() => {\r\n    try {\r\n      if (debug && typeof lastTick !== 'undefined' && lastTick !== null) {\r\n        // lightweight debug output\r\n        // eslint-disable-next-line no-console\r\n        console.debug('[useEmaCross] lastTick', lastTick);\r\n      }\r\n    } catch (e) {}\r\n  }, [lastTick, debug]);\r\n  const [cross, setCross] = useState(null); // preview (live) cross\r\n  const [confirmedCross, setConfirmedCross] = useState(null); // only updated on closed candles (confirmed)\r\n  const [confirmedSource, setConfirmedSource] = useState(null); // 'ws' | 'poll' | 'init'\r\n  const [connected, setConnected] = useState(false);\r\n  const [status, setStatus] = useState('idle');\r\n  const [lastCandleClosed, setLastCandleClosed] = useState(false);\r\n  const [activeSymbol, setActiveSymbol] = useState(null); // which symbol the hook has initialized/connected for\r\n\r\n  const wsRef = useRef(null);\r\n  const prevCrossRef = useRef(null);\r\n  const prevConfirmedRef = useRef(null);\r\n  const candidateConfirmedRef = useRef(null);\r\n  const candidateCountRef = useRef(0);\r\n  const ema9Ref = useRef(null);\r\n  const ema26Ref = useRef(null);\r\n  // confirmed EMAs updated only on closed candles (kline.x === true) or polling\r\n  const ema9ConfirmedRef = useRef(null);\r\n  const ema26ConfirmedRef = useRef(null);\r\n  const reconnectAttemptsRef = useRef(0);\r\n  const reconnectTimerRef = useRef(null);\r\n  const currentSymbolRef = useRef(null);\r\n  const lastProcessedCloseRef = useRef(null); // timestamp (ms) of last processed closed candle\r\n  const pollingTimerRef = useRef(null);\r\n\r\n  const fetchAndInit = useCallback(async (target = symbol) => {\r\n    try {\r\n      const t = (target || symbol).toString();\r\n      setStatus('fetching historical klines');\r\n      const norm = t.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n  // use Binance Futures (USDT-M) REST endpoint for klines; interval is configurable\r\n  const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${norm}&interval=${interval}&limit=500`;\r\n    const res = await fetch(url);\r\n      if (!res.ok) throw new Error(`Failed to fetch klines: ${res.status}`);\r\n      const data = await res.json();\r\n      // kline array: [ openTime, open, high, low, close, ... ]\r\n  const closes = data.map((k) => parseFloat(k[4]));\r\n\r\n  if (closes.length < emaLong) throw new Error(`Not enough historical candles to initialize EMA${emaLong}`);\r\n\r\n    // Determine sensible history windows for initial EMA calculation\r\n    const shortWindow = Math.max(emaShort * 10, 100);\r\n    const longWindow = Math.max(emaLong * 12, 300);\r\n\r\n  // Use the close history to compute EMA short/long\r\n  if (debug) console.debug('[useEmaCross] fetchAndInit params', { symbol: norm, interval, emaShort, emaLong, shortWindow, longWindow, closesLength: closes.length });\r\n  const initEma9 = calculateInitialEMA(closes.slice(-shortWindow), emaShort);\r\n  const initEma26 = calculateInitialEMA(closes.slice(-longWindow), emaLong);\r\n\r\n  // initialize both preview and confirmed EMAs from historical closes\r\n  ema9Ref.current = initEma9;\r\n  ema26Ref.current = initEma26;\r\n  ema9ConfirmedRef.current = initEma9;\r\n  ema26ConfirmedRef.current = initEma26;\r\n      // record which symbol these EMAs correspond to\r\n      currentSymbolRef.current = norm;\r\n      setActiveSymbol(norm);\r\n      // record last processed closed candle time (closeTime at index 6)\r\n      try { lastProcessedCloseRef.current = data[data.length - 1][6]; } catch (e) { lastProcessedCloseRef.current = null; }\r\n    setEma9(initEma9);\r\n    setEma26(initEma26);\r\n    setLastPrice(closes[closes.length - 1]);\r\n      setStatus('initialized');\r\n      // set initial cross\r\n    const initialCross = initEma9 > initEma26 ? 'bull' : 'bear';\r\n    if (debug) console.debug('[useEmaCross] initial EMAs', { initEma9, initEma26, initialCross });\r\n      prevCrossRef.current = initialCross;\r\n  setCross(initialCross);\r\n  prevConfirmedRef.current = initialCross;\r\n  setConfirmedCross(initialCross);\r\n  setConfirmedSource('init');\r\n    } catch (err) {\r\n      setStatus(`init error: ${err.message}`);\r\n      console.error(err);\r\n    }\r\n  }, [symbol, interval, emaShort, emaLong, debug]);\r\n\r\n  const connect = useCallback(async (overrideSymbol) => {\r\n    const targetSymbol = (overrideSymbol || symbol).toString();\r\n    const targetNorm = targetSymbol.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n    // if a websocket exists for same symbol, no-op\r\n    if (wsRef.current) {\r\n      if (currentSymbolRef.current === targetNorm) return;\r\n      // do NOT close the existing socket here; create a new socket and let the\r\n      // new socket's onopen handler replace/close the old socket to avoid a\r\n      // brief disconnected state in the UI.\r\n    }\r\n    // Ensure EMA is initialized for the target symbol before connecting\r\n    try {\r\n      const targetNorm = targetSymbol.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n      if (currentSymbolRef.current !== targetNorm || ema9Ref.current == null || ema26Ref.current == null) {\r\n        await fetchAndInit(targetNorm);\r\n      }\r\n    } catch (err) {\r\n      setStatus(`init error: ${err.message}`);\r\n      return;\r\n    }\r\n\r\n    setStatus('connecting websocket');\r\n    // Use combined stream: kline interval (configurable) + aggTrade for higher-frequency trade updates\r\n    const klineStream = `${targetNorm.toLowerCase()}@kline_${String(interval)}`;\r\n  const tradeStream = `${targetNorm.toLowerCase()}@aggTrade`;\r\n    const streams = `${klineStream}/${tradeStream}`;\r\n  // use Binance Futures (USDT-M) websocket (fstream) combined stream\r\n  const url = `wss://fstream.binance.com/stream?streams=${streams}`;\r\n  console.log('Connecting websocket for', targetSymbol, 'url=', url);\r\n  const ws = new WebSocket(url);\r\n    // Do not overwrite wsRef.current immediately. Create a new socket and only replace the\r\n    // existing one after the new socket successfully opens. This allows a seamless symbol\r\n    // switch without briefly showing disconnected state in the UI.\r\n  const oldWs = wsRef.current;\r\n\r\n    ws.onopen = () => {\r\n      // mark as successful open\r\n      reconnectAttemptsRef.current = 0;\r\n      if (reconnectTimerRef.current) {\r\n        clearTimeout(reconnectTimerRef.current);\r\n        reconnectTimerRef.current = null;\r\n      }\r\n      // stop polling if it was started while socket was down\r\n      if (pollingTimerRef.current) {\r\n        clearInterval(pollingTimerRef.current);\r\n        pollingTimerRef.current = null;\r\n      }\r\n\r\n      // If there was a previous socket, mark it as replaced so its onclose handler\r\n      // skips reconnect logic, then close it.\r\n      try {\r\n        if (oldWs) {\r\n          oldWs.__replaced = true;\r\n          try { oldWs.close(); } catch (e) {}\r\n        }\r\n      } catch (e) {}\r\n\r\n      // now adopt the new socket as the active socket\r\n      wsRef.current = ws;\r\n      currentSymbolRef.current = targetNorm;\r\n      setActiveSymbol(targetNorm);\r\n      if (debug) console.log('[useEmaCross] websocket open for', targetNorm);\r\n  setConnected(true);\r\n  setStatus('connected');\r\n    };\r\n\r\n    ws.onmessage = (ev) => {\r\n      try {\r\n        const payloadWrapper = JSON.parse(ev.data);\r\n        // combined stream returns { stream, data }\r\n        const payload = payloadWrapper.data || payloadWrapper;\r\n\r\n        // determine the source symbol for this message (if available)\r\n        let sourceSymbol = null;\r\n        try {\r\n          if (payload && payload.s) sourceSymbol = payload.s.toString().toUpperCase();\r\n          else if (payloadWrapper && payloadWrapper.stream) {\r\n            const streamName = payloadWrapper.stream.toString(); // e.g. trxusdt@aggTrade\r\n            sourceSymbol = streamName.split('@')[0].toUpperCase();\r\n          }\r\n        } catch (e) { sourceSymbol = null; }\r\n\r\n        // If the message is not for the currently-initialized symbol, ignore it.\r\n        // NOTE: previously we only ignored messages when currentSymbolRef was set;\r\n        // that left a small window during symbol switches where messages could be\r\n        // processed while currentSymbolRef was null. Be stricter: if the message\r\n        // contains a source symbol it must match the initialized symbol, otherwise\r\n        // ignore it.\r\n        if (sourceSymbol) {\r\n          if (!currentSymbolRef.current || currentSymbolRef.current.toString().toUpperCase() !== sourceSymbol.toString().toUpperCase()) {\r\n            return; // ignore messages from other symbols or while switching\r\n          }\r\n        }\r\n\r\n        // aggTrade messages have event type 'aggTrade' and price in p\r\n        if (debug) {\r\n          try {\r\n            const streamName = payloadWrapper.stream || payload.e || 'unknown';\r\n            console.log('[useEmaCross] incoming', { stream: streamName, sourceSymbol, event: payload.e || null });\r\n          } catch (e) {}\r\n        }\r\n        if (payload.e === 'aggTrade') {\r\n          const price = parseFloat(payload.p);\r\n          // update live tick price only; do NOT overwrite the last closed price\r\n          // which should be used for confirmed alerts.\r\n          setLastTick(price);\r\n\r\n          if (ema9Ref.current == null || ema26Ref.current == null) return;\r\n\r\n          // update EMA using trade price to provide higher-frequency preview\r\n          const newEma9 = updateEMA(ema9Ref.current, price, emaShort);\r\n          const newEma26 = updateEMA(ema26Ref.current, price, emaLong);\r\n          // preview EMAs only\r\n          ema9Ref.current = newEma9;\r\n          ema26Ref.current = newEma26;\r\n          setEma9(newEma9);\r\n          setEma26(newEma26);\r\n\r\n          // Do not update `cross` from trade ticks — keep cross decision tied to closed candles.\r\n        }\r\n\r\n        // kline messages contain a 'k' object\r\n        if (payload.k) {\r\n          if (debug) console.log('[useEmaCross] kline payload x=', payload.k.x, 'close=', payload.k.c);\r\n          const k = payload.k;\r\n          const close = parseFloat(k.c);\r\n          // for partial candles, update live tick display; for closed candles\r\n          // update the confirmed lastPrice (closed price) which will be used\r\n          // for confirmedCross/notifications.\r\n          setLastTick(close);\r\n          setLastCandleClosed(Boolean(k.x));\r\n\r\n          if (ema9Ref.current == null || ema26Ref.current == null) return;\r\n\r\n          // update EMA using kline close\r\n          // For partial candle: update preview EMA only\r\n          if (!k.x) {\r\n            const newEma9 = updateEMA(ema9Ref.current, close, emaShort);\r\n            const newEma26 = updateEMA(ema26Ref.current, close, emaLong);\r\n            ema9Ref.current = newEma9;\r\n            ema26Ref.current = newEma26;\r\n            setEma9(newEma9);\r\n            setEma26(newEma26);\r\n            } else {\r\n            // closed candle: update confirmed EMAs only (and sync preview to confirmed)\r\n            if (ema9ConfirmedRef.current == null || ema26ConfirmedRef.current == null) {\r\n              // defensive: fall back to preview if confirmed not initialized\r\n              ema9ConfirmedRef.current = ema9Ref.current;\r\n              ema26ConfirmedRef.current = ema26Ref.current;\r\n            }\r\n            const prevShort = (typeof ema9ConfirmedRef.current === 'number') ? ema9ConfirmedRef.current : null;\r\n            const prevLong = (typeof ema26ConfirmedRef.current === 'number') ? ema26ConfirmedRef.current : null;\r\n            const newEma9c = updateEMA(ema9ConfirmedRef.current, close, emaShort);\r\n            const newEma26c = updateEMA(ema26ConfirmedRef.current, close, emaLong);\r\n            // update confirmed refs\r\n            ema9ConfirmedRef.current = newEma9c;\r\n            ema26ConfirmedRef.current = newEma26c;\r\n            // sync preview to confirmed after closed candle to avoid drift\r\n            ema9Ref.current = newEma9c;\r\n            ema26Ref.current = newEma26c;\r\n            setEma9(newEma9c);\r\n            setEma26(newEma26c);\r\n            // closed candle: also record the closed price as the authoritative lastPrice\r\n            setLastPrice(close);\r\n            // Determine whether an actual cross occurred between the previous confirmed\r\n            // EMAs and the newly computed confirmed EMAs. A cross is defined as a\r\n            // sign change: prevShort <= prevLong && newShort > newLong => golden\r\n            // prevShort >= prevLong && newShort < newLong => dead\r\n            let detectedCross = null;\r\n            try {\r\n              if (prevShort != null && prevLong != null) {\r\n                if (prevShort <= prevLong && newEma9c > newEma26c) detectedCross = 'bull';\r\n                else if (prevShort >= prevLong && newEma9c < newEma26c) detectedCross = 'bear';\r\n                else detectedCross = null; // no crossing event\r\n              }\r\n            } catch (e) { detectedCross = null; }\r\n          }\r\n\r\n          // Do not update `cross` for preview/partial candles here; cross will be\r\n          // determined and updated only when a candle is closed (confirmed).\r\n          // If candle is closed (k.x === true) and it's a new closed candle, update processed time and set confirmed cross\r\n          if (Boolean(k.x)) {\r\n            try {\r\n              const closeTime = k.T || k.t || null; // k.T is close time in ms\r\n              if (closeTime && (!lastProcessedCloseRef.current || closeTime > lastProcessedCloseRef.current)) {\r\n                lastProcessedCloseRef.current = closeTime;\r\n                // compute confirmed cross using confirmed EMA refs (fallback to preview values)\r\n                // Only consider a confirmed cross when we detect an actual crossing event\r\n                // between the previous confirmed EMAs and the newly computed confirmed EMAs.\r\n                if (debug) console.debug('[useEmaCross] closed candle detected', { closeTime, close, ema9Confirmed: ema9ConfirmedRef.current, ema26Confirmed: ema26ConfirmedRef.current, ema9Preview: ema9Ref.current, ema26Preview: ema26Ref.current, detectedCross });\r\n                if (detectedCross != null) {\r\n                  if (candidateConfirmedRef.current === detectedCross) {\r\n                    candidateCountRef.current = (candidateCountRef.current || 0) + 1;\r\n                  } else {\r\n                    candidateConfirmedRef.current = detectedCross;\r\n                    candidateCountRef.current = 1;\r\n                  }\r\n                  if (debug) console.debug('[useEmaCross] candidateConfirmed state', { candidateConfirmed: candidateConfirmedRef.current, candidateCount: candidateCountRef.current, required: confirmClosedCandles });\r\n                  if (candidateCountRef.current >= confirmClosedCandles) {\r\n                    if (prevConfirmedRef.current !== detectedCross) {\r\n                      prevConfirmedRef.current = detectedCross;\r\n                      setConfirmedCross(detectedCross);\r\n                      setConfirmedSource('ws');\r\n                      // also update public `cross` so UI reflects the closed-candle decision\r\n                      if (prevCrossRef.current !== detectedCross) {\r\n                        prevCrossRef.current = detectedCross;\r\n                        setCross(detectedCross);\r\n                      }\r\n                    }\r\n                  }\r\n                } else {\r\n                  // No crossing event: reset candidate tracking so we only detect real cross events\r\n                  candidateConfirmedRef.current = null;\r\n                  candidateCountRef.current = 0;\r\n                }\r\n              }\r\n              } catch (e) {\r\n              // fallback: if we couldn't compute confirmed EMAs, fall back to\r\n              // preview EMAs (if available) to set a confirmed-like value.\r\n              const fallback = (ema9Ref.current != null && ema26Ref.current != null) ? (ema9Ref.current > ema26Ref.current ? 'bull' : 'bear') : null;\r\n              if (fallback && prevConfirmedRef.current !== fallback) {\r\n                prevConfirmedRef.current = fallback;\r\n                setConfirmedCross(fallback);\r\n                setConfirmedSource('ws');\r\n              }\r\n            }\r\n          } else {\r\n            // partial candle: preview already updated above\r\n          }\r\n        }\r\n      } catch (err) {\r\n        console.error('ws message parse error', err);\r\n      }\r\n    };\r\n\r\n    ws.onerror = (e) => {\r\n      // if this socket was intentionally replaced by a new one, ignore errors\r\n      if (ws.__replaced) {\r\n        if (debug) console.log('[useEmaCross] ignored error on replaced socket');\r\n        return;\r\n      }\r\n      console.error('ws error', e);\r\n      setStatus('websocket error');\r\n      // close to trigger backoff reconnect\r\n      try { ws.close(); } catch (err) {}\r\n    };\r\n\r\n    ws.onclose = () => {\r\n      // if this socket was intentionally replaced by a new one, skip close handling\r\n      if (ws.__replaced) {\r\n        if (debug) console.log('[useEmaCross] websocket was replaced; skipping onclose handling');\r\n        return;\r\n      }\r\n      setConnected(false);\r\n      setStatus('websocket closed');\r\n      wsRef.current = null;\r\n      if (debug) console.log('[useEmaCross] websocket closed');\r\n\r\n      // capture intended reconnect target now (before we nullify refs)\r\n      const reconnectTarget = currentSymbolRef.current || symbol;\r\n      // clear active symbol immediately for UI, but keep reconnectTarget for retries\r\n      setActiveSymbol(null);\r\n\r\n      // start polling for closed candles while websocket is down\r\n      try {\r\n        if (!pollingTimerRef.current) {\r\n              pollingTimerRef.current = setInterval(async () => {\r\n            try {\r\n              const sym = (reconnectTarget || symbol || '').replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n              if (!sym) return;\r\n                  const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${sym}&interval=${interval}&limit=10`;\r\n              const res = await fetch(url);\r\n              if (!res.ok) return;\r\n              const data = await res.json();\r\n              // iterate candles in chronological order and process any closed candles newer than lastProcessedCloseRef\r\n              const newClosed = [];\r\n              for (const k of data) {\r\n                const closeTime = k[6];\r\n                if (closeTime && (!lastProcessedCloseRef.current || closeTime > lastProcessedCloseRef.current)) {\r\n                  newClosed.push(k);\r\n                }\r\n              }\r\n                if (newClosed.length > 0) {\r\n                // sort by closeTime asc\r\n                newClosed.sort((a, b) => a[6] - b[6]);\r\n                  for (const k of newClosed) {\r\n                  const close = parseFloat(k[4]);\r\n                  // update EMAs using closed candle\r\n                  if (ema9Ref.current == null || ema26Ref.current == null) continue;\r\n                  // update confirmed EMAs using closed candle (polling)\r\n                  if (ema9ConfirmedRef.current == null || ema26ConfirmedRef.current == null) {\r\n                    ema9ConfirmedRef.current = ema9Ref.current;\r\n                    ema26ConfirmedRef.current = ema26Ref.current;\r\n                  }\r\n                  const prevShort = (typeof ema9ConfirmedRef.current === 'number') ? ema9ConfirmedRef.current : null;\r\n                  const prevLong = (typeof ema26ConfirmedRef.current === 'number') ? ema26ConfirmedRef.current : null;\r\n                  const newEma9c = updateEMA(ema9ConfirmedRef.current, close, emaShort);\r\n                  const newEma26c = updateEMA(ema26ConfirmedRef.current, close, emaLong);\r\n                  ema9ConfirmedRef.current = newEma9c;\r\n                  ema26ConfirmedRef.current = newEma26c;\r\n                  // sync preview to confirmed\r\n                  ema9Ref.current = newEma9c;\r\n                  ema26Ref.current = newEma26c;\r\n                  setEma9(newEma9c);\r\n                  setEma26(newEma26c);\r\n                  // detect actual crossing event between previous confirmed EMAs and new confirmed EMAs\r\n                  let detectedCross = null;\r\n                  try {\r\n                    if (prevShort != null && prevLong != null) {\r\n                      if (prevShort <= prevLong && newEma9c > newEma26c) detectedCross = 'bull';\r\n                      else if (prevShort >= prevLong && newEma9c < newEma26c) detectedCross = 'bear';\r\n                      else detectedCross = null;\r\n                    }\r\n                  } catch (e) { detectedCross = null; }\r\n                  if (detectedCross != null) {\r\n                    if (candidateConfirmedRef.current === detectedCross) {\r\n                      candidateCountRef.current = (candidateCountRef.current || 0) + 1;\r\n                    } else {\r\n                      candidateConfirmedRef.current = detectedCross;\r\n                      candidateCountRef.current = 1;\r\n                    }\r\n                    if (candidateCountRef.current >= confirmClosedCandles) {\r\n                      if (prevConfirmedRef.current !== detectedCross) {\r\n                        prevConfirmedRef.current = detectedCross;\r\n                        setConfirmedCross(detectedCross);\r\n                        setConfirmedSource('poll');\r\n                        if (prevCrossRef.current !== detectedCross) {\r\n                          prevCrossRef.current = detectedCross;\r\n                          setCross(detectedCross);\r\n                        }\r\n                      }\r\n                    }\r\n                  } else {\r\n                    candidateConfirmedRef.current = null;\r\n                    candidateCountRef.current = 0;\r\n                  }\r\n                  lastProcessedCloseRef.current = k[6];\r\n                  // polling provides closed-candle prices, so update authoritative lastPrice\r\n                  setLastPrice(parseFloat(k[4]));\r\n                  setLastCandleClosed(true);\r\n                }\r\n              }\r\n            } catch (e) {\r\n              // ignore polling errors\r\n            }\r\n          }, 10 * 1000); // poll every 10s\r\n        }\r\n      } catch (e) {}\r\n\r\n      // exponential backoff reconnect with jitter\r\n      const attempt = reconnectAttemptsRef.current || 0;\r\n      const base = 1000; // 1s\r\n      const delay = Math.min(30000, base * Math.pow(2, attempt));\r\n      const jitter = Math.floor(Math.random() * 1000);\r\n      reconnectAttemptsRef.current = attempt + 1;\r\n      reconnectTimerRef.current = setTimeout(() => {\r\n        reconnectTimerRef.current = null;\r\n        if (!wsRef.current) {\r\n          // prefer reconnecting to the captured target\r\n          const target = reconnectTarget || symbol;\r\n          try { connect(target); } catch (e) { connect(target); }\r\n        }\r\n      }, delay + jitter);\r\n\r\n      // finally clear the currentSymbolRef to reflect that socket is closed\r\n      currentSymbolRef.current = null;\r\n    };\r\n  }, [symbol, fetchAndInit, debug, interval, emaShort, emaLong, confirmClosedCandles]);\r\n\r\n  const disconnect = useCallback(() => {\r\n    if (wsRef.current) {\r\n      wsRef.current.close();\r\n      wsRef.current = null;\r\n    }\r\n    setConnected(false);\r\n    setStatus('disconnected');\r\n    setActiveSymbol(null);\r\n    if (pollingTimerRef.current) {\r\n      clearInterval(pollingTimerRef.current);\r\n      pollingTimerRef.current = null;\r\n    }\r\n    // clear reconnect attempts/timers\r\n    try {\r\n      reconnectAttemptsRef.current = 0;\r\n      if (reconnectTimerRef.current) {\r\n        clearTimeout(reconnectTimerRef.current);\r\n        reconnectTimerRef.current = null;\r\n      }\r\n    } catch (e) {}\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    // initialize on mount (or when symbol changes)\r\n    // Reset EMA/cross state for the new symbol, but do NOT forcibly close the existing websocket\r\n    // to avoid a visible disconnect during a symbol switch. We keep the socket open until the\r\n    // new connection is established by `connect` (which will replace the old socket).\r\n    try {\r\n      // clear reconnect timers and attempts\r\n      if (reconnectTimerRef.current) {\r\n        clearTimeout(reconnectTimerRef.current);\r\n        reconnectTimerRef.current = null;\r\n      }\r\n      reconnectAttemptsRef.current = 0;\r\n\r\n      // reset refs and state for EMA and cross (prepare for new seed)\r\n      prevCrossRef.current = null;\r\n      currentSymbolRef.current = null;\r\n      ema9Ref.current = null;\r\n      ema26Ref.current = null;\r\n      // also clear confirmed/candidate tracking to avoid leaking state between symbols\r\n      ema9ConfirmedRef.current = null;\r\n      ema26ConfirmedRef.current = null;\r\n      prevConfirmedRef.current = null;\r\n      candidateConfirmedRef.current = null;\r\n      candidateCountRef.current = 0;\r\n      lastProcessedCloseRef.current = null;\r\n      setEma9(null);\r\n      setEma26(null);\r\n      setLastPrice(null);\r\n      setCross(null);\r\n      setConfirmedCross(null);\r\n      setLastCandleClosed(false);\r\n      // Set status to reloading while we fetch/init for the new symbol; do NOT set connected=false here,\r\n      // so the UI remains 'connected' until the replacement socket opens (smoother UX).\r\n      setStatus('reloading');\r\n    } catch (e) {}\r\n    // fetch history for the (new) symbol and initialize\r\n    fetchAndInit();\r\n    // cleanup on unmount\r\n    return () => {\r\n      if (wsRef.current) wsRef.current.close();\r\n      if (pollingTimerRef.current) {\r\n        clearInterval(pollingTimerRef.current);\r\n        pollingTimerRef.current = null;\r\n      }\r\n    };\r\n  }, [fetchAndInit]);\r\n\r\n  // auto connect after initialization if requested\r\n  useEffect(() => {\r\n    if (status === 'initialized' && autoConnect) {\r\n      // call connect once after initialization\r\n      connect();\r\n    }\r\n    // only run when status or autoConnect changes\r\n  }, [status, autoConnect, connect]);\r\n\r\n  return {\r\n    ema9,\r\n    ema26,\r\n    lastPrice,\r\n    lastTick,\r\n    lastCandleClosed,\r\n    cross,\r\n    confirmedCross,\r\n    confirmedSource,\r\n    connected,\r\n    status,\r\n    connect,\r\n    disconnect,\r\n    activeSymbol,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}