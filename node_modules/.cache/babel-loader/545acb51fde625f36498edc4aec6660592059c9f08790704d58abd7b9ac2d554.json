{"ast":null,"code":"import _objectSpread from\"C:/Users/e1it3/Desktop/program/binance_alert/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// Simple singleton scanner manager to run scans independent of React component lifecycle.\nconst scannerManager=(()=>{let running=false;let currentSymbol=null;// track current scan type so UI can color progress (e.g., 'golden' | 'dead' | null)\nlet scanType=null;let progress={done:0,total:0};// load persisted results from localStorage when available so navigation doesn't lose matches\nlet results=[];try{if(typeof window!=='undefined'&&window.localStorage){const raw=window.localStorage.getItem('scannerResults');if(raw)results=JSON.parse(raw)||[];}}catch(e){results=[];}let cancel=false;// timestamp when the current scan started (ms since epoch) - persists so UI can show elapsed across pages\nlet scanStartTime=null;// track multiple abort controllers when running requests in parallel\nlet currentAbortControllers=new Set();let listeners=new Set();let getSymbolsFn=null;function notify(){// include scanType in the published state so UI can color the progress bar correctly\nconst state={running,currentSymbol,scanType,progress:_objectSpread({},progress),results:results.slice(),scanStartTime};for(const cb of listeners){try{cb(state);}catch(e){}}// persist results after notifying\ntry{if(typeof window!=='undefined'&&window.localStorage){window.localStorage.setItem('scannerResults',JSON.stringify(results.slice(0,200)));}}catch(e){}}function onUpdate(cb){listeners.add(cb);return()=>listeners.delete(cb);}function setGetSymbols(fn){getSymbolsFn=fn;}function sleep(ms){return new Promise(r=>setTimeout(r,ms));}// same EMA helper as used in ScannerPage\nfunction calculateEma(values,period){if(!Array.isArray(values)||values.length===0)return[];const k=2/(period+1);const out=[];let ema=null;for(let i=0;i<values.length;i++){const v=Number(values[i]);if(isNaN(v)){out.push(null);continue;}if(ema===null){if(i+1>=period){const slice=values.slice(i+1-period,i+1).map(Number);const s=slice.reduce((a,b)=>a+b,0)/period;ema=s;out.push(ema);}else{out.push(null);}}else{ema=v*k+ema*(1-k);out.push(ema);}}return out;}async function start(type){let opts=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(running)return;if(typeof getSymbolsFn!=='function')throw new Error('scannerManager: getSymbolsFn not set');// initialize run state\nrunning=true;cancel=false;results=[];progress={done:0,total:0};currentSymbol=null;scanType=type||null;scanStartTime=Date.now();notify();const list=(await Promise.resolve(getSymbolsFn()))||[];// accept options: interval (e.g., '5m' or number of minutes), emaShort, emaLong\nlet interval=opts&&typeof opts.interval!=='undefined'?opts.interval:'5m';if(typeof interval==='number'||typeof interval==='string'&&/^\\d+$/.test(interval))interval=\"\".concat(interval,\"m\");const emaShort=opts&&typeof opts.emaShort!=='undefined'?parseInt(opts.emaShort,10):26;const emaLong=opts&&typeof opts.emaLong!=='undefined'?parseInt(opts.emaLong,10):200;const filtered=Array.isArray(list)?list.filter(s=>typeof s==='string'&&/USDT$/i.test(s)):[];progress.total=filtered.length;notify();const endpointBase='https://fapi.binance.com/fapi/v1/klines';// concurrency controls: default to a faster parallelism for quicker scans\n// These defaults can be overridden via opts when calling start()\n// Adjusted defaults to slow the scanner a bit so a full pass is ~30s on typical symbol counts.\n// Make defaults conservative to avoid triggering API rate-limit warnings\n// Slightly faster defaults: increase parallelism and reduce inter-batch delay for quicker scans\n// Keep conservative limits to avoid hitting API rate limits.\nconst concurrencyDefault=opts&&typeof opts.concurrency==='number'?Math.max(1,opts.concurrency):3;const batchDelayBase=opts&&typeof opts.batchDelay==='number'?Math.max(0,opts.batchDelay):400;// ms between batches\n// mutable runtime controls (auto-tuner will adjust these)\nlet concurrencyCurrent=concurrencyDefault;let batchDelayCurrent=batchDelayBase;// cap maxConcurrency to the starting concurrency by default to prevent aggressive ramp-up\nconst maxConcurrency=opts&&typeof opts.maxConcurrency==='number'?Math.max(1,opts.maxConcurrency):concurrencyDefault;// backoff/ramp state\nlet backoffCount=0;let consecutiveSuccesses=0;const successThreshold=opts&&typeof opts.rampSuccessThreshold==='number'?Math.max(1,opts.rampSuccessThreshold):3;const minBatchDelay=opts&&typeof opts.minBatchDelay==='number'?Math.max(150,opts.minBatchDelay):200;// helper to process one symbol; catches errors and always resolves\nconst processSymbol=async sym=>{if(cancel)return;currentSymbol=sym;notify();const url=\"\".concat(endpointBase,\"?symbol=\").concat(encodeURIComponent(sym),\"&interval=\").concat(encodeURIComponent(interval),\"&limit=1000\");let localAbort=null;try{try{localAbort=new AbortController();}catch(e){localAbort=null;}if(localAbort)currentAbortControllers.add(localAbort);const r=await fetch(url,localAbort?{signal:localAbort.signal}:undefined);if(!r.ok){if(r.status===429){// increase backoff pressure and reduce concurrency\nbackoffCount+=1;consecutiveSuccesses=0;concurrencyCurrent=Math.max(1,Math.floor(concurrencyCurrent*0.6));batchDelayCurrent=Math.min(30000,Math.floor(batchDelayCurrent*1.6));const base=1000;const backoffMs=Math.min(30000,Math.floor(base*Math.pow(2,Math.min(backoffCount,6)))+Math.floor(Math.random()*1000));try{await sleep(backoffMs);}catch(e){}}return;}const data=await r.json();// success: reduce backoff pressure and allow gentle ramp-up\nbackoffCount=Math.max(0,backoffCount-1);consecutiveSuccesses+=1;if(consecutiveSuccesses>=successThreshold){consecutiveSuccesses=0;if(concurrencyCurrent<maxConcurrency){concurrencyCurrent=concurrencyCurrent+1;}batchDelayCurrent=Math.max(minBatchDelay,Math.floor(batchDelayCurrent*0.85));}const closes=Array.isArray(data)?data.map(d=>parseFloat(d[4])):[];const needed=Math.max(emaShort,emaLong)+10;if(!Array.isArray(closes)||closes.length<needed){return;}const emaShortArr=calculateEma(closes,emaShort);const emaLongArr=calculateEma(closes,emaLong);const lastIdx=closes.length-1;const prevIdx=lastIdx-1;const prevShort=emaShortArr[prevIdx];const prevLong=emaLongArr[prevIdx];const lastShort=emaShortArr[lastIdx];const lastLong=emaLongArr[lastIdx];let matched=false;if(typeof prevShort==='number'&&typeof prevLong==='number'&&typeof lastShort==='number'&&typeof lastLong==='number'){if(type==='golden'){if(prevShort<=prevLong&&lastShort>lastLong)matched=true;}else if(type==='dead'){if(prevShort>=prevLong&&lastShort<lastLong)matched=true;}}if(matched){// attach the scan type to the result so the UI can color icons per-result\n// also capture the last candle volume so the UI can show & sort by volume\nconst lastVolume=Array.isArray(data)&&data[lastIdx]&&typeof data[lastIdx][5]!=='undefined'?parseFloat(data[lastIdx][5]):0;const ev={id:\"\".concat(sym,\"-\").concat(Date.now(),\"-\").concat(Math.random().toString(36).slice(2,8)),symbol:sym,lastShort,lastLong,time:new Date().toLocaleString(),interval,emaShort,emaLong,type,volume:lastVolume};results.unshift(ev);// cap stored results to reasonable size (avoid unbounded growth)\nif(results.length>500)results=results.slice(0,500);notify();}}catch(e){if(e&&e.name==='AbortError'){// expected when stopping\n}else{// ignore other fetch errors\n}}finally{// cleanup local abort controller\nif(localAbort)currentAbortControllers.delete(localAbort);progress.done+=1;notify();}};// run in batches with a mutable concurrency controlled by the auto-tuner\nlet i=0;try{while(i<filtered.length){if(cancel)break;const currentConcurrency=Math.max(1,Math.floor(concurrencyCurrent));const batch=filtered.slice(i,i+currentConcurrency);if(!batch||batch.length===0)break;await Promise.all(batch.map(sym=>processSymbol(sym)));if(cancel)break;i+=batch.length;if(i<filtered.length){const jitter=Math.floor(Math.random()*Math.min(300,Math.max(20,Math.floor(batchDelayCurrent*0.5))));const delay=Math.max(0,batchDelayCurrent+jitter);await sleep(delay);}}}catch(err){// log unexpected errors but don't leave scanner in running state\ntry{console.error('scannerManager.start error',err&&err.message?err.message:err);}catch(e){}}finally{// cleanup any remaining abort controllers\ntry{for(const c of currentAbortControllers){try{c.abort();}catch(e){}}}catch(e){}currentAbortControllers.clear();running=false;currentSymbol=null;cancel=false;scanStartTime=null;notify();// clear scanType after finishing\nscanType=null;}}function stop(){// signal cancellation and abort any in-flight fetch\ncancel=true;try{// abort any tracked controllers\nfor(const c of currentAbortControllers){try{if(c&&typeof c.abort==='function')c.abort();}catch(e){}}currentAbortControllers.clear();}catch(e){}running=false;currentSymbol=null;scanStartTime=null;// clear scanType when stopping so UI does not remain colored\nscanType=null;notify();}function getState(){return{running,currentSymbol,scanType,progress:_objectSpread({},progress),results:results.slice(),scanStartTime};}function removeResult(id){if(!id)return;results=results.filter(r=>r.id!==id);notify();}function clearResults(){results=[];notify();}return{onUpdate,setGetSymbols,start,stop,getState,removeResult,clearResults};})();export default scannerManager;","map":{"version":3,"names":["scannerManager","running","currentSymbol","scanType","progress","done","total","results","window","localStorage","raw","getItem","JSON","parse","e","cancel","scanStartTime","currentAbortControllers","Set","listeners","getSymbolsFn","notify","state","_objectSpread","slice","cb","setItem","stringify","onUpdate","add","delete","setGetSymbols","fn","sleep","ms","Promise","r","setTimeout","calculateEma","values","period","Array","isArray","length","k","out","ema","i","v","Number","isNaN","push","map","s","reduce","a","b","start","type","opts","arguments","undefined","Error","Date","now","list","resolve","interval","test","concat","emaShort","parseInt","emaLong","filtered","filter","endpointBase","concurrencyDefault","concurrency","Math","max","batchDelayBase","batchDelay","concurrencyCurrent","batchDelayCurrent","maxConcurrency","backoffCount","consecutiveSuccesses","successThreshold","rampSuccessThreshold","minBatchDelay","processSymbol","sym","url","encodeURIComponent","localAbort","AbortController","fetch","signal","ok","status","floor","min","base","backoffMs","pow","random","data","json","closes","d","parseFloat","needed","emaShortArr","emaLongArr","lastIdx","prevIdx","prevShort","prevLong","lastShort","lastLong","matched","lastVolume","ev","id","toString","symbol","time","toLocaleString","volume","unshift","name","currentConcurrency","batch","all","jitter","delay","err","console","error","message","c","abort","clear","stop","getState","removeResult","clearResults"],"sources":["C:/Users/e1it3/Desktop/program/binance_alert/src/lib/scannerManager.js"],"sourcesContent":["// Simple singleton scanner manager to run scans independent of React component lifecycle.\r\nconst scannerManager = (() => {\r\n  let running = false;\r\n  let currentSymbol = null;\r\n  // track current scan type so UI can color progress (e.g., 'golden' | 'dead' | null)\r\n  let scanType = null;\r\n  let progress = { done: 0, total: 0 };\r\n  // load persisted results from localStorage when available so navigation doesn't lose matches\r\n  let results = [];\r\n  try {\r\n    if (typeof window !== 'undefined' && window.localStorage) {\r\n      const raw = window.localStorage.getItem('scannerResults');\r\n      if (raw) results = JSON.parse(raw) || [];\r\n    }\r\n  } catch (e) {\r\n    results = [];\r\n  }\r\n  let cancel = false;\r\n  // timestamp when the current scan started (ms since epoch) - persists so UI can show elapsed across pages\r\n  let scanStartTime = null;\r\n  // track multiple abort controllers when running requests in parallel\r\n  let currentAbortControllers = new Set();\r\n  let listeners = new Set();\r\n  let getSymbolsFn = null;\r\n\r\n  function notify() {\r\n    // include scanType in the published state so UI can color the progress bar correctly\r\n    const state = { running, currentSymbol, scanType, progress: { ...progress }, results: results.slice(), scanStartTime };\r\n    for (const cb of listeners) {\r\n      try { cb(state); } catch (e) {}\r\n    }\r\n    // persist results after notifying\r\n    try {\r\n      if (typeof window !== 'undefined' && window.localStorage) {\r\n        window.localStorage.setItem('scannerResults', JSON.stringify(results.slice(0, 200)));\r\n      }\r\n    } catch (e) {}\r\n  }\r\n\r\n  function onUpdate(cb) { listeners.add(cb); return () => listeners.delete(cb); }\r\n\r\n  function setGetSymbols(fn) { getSymbolsFn = fn; }\r\n\r\n  function sleep(ms) { return new Promise((r) => setTimeout(r, ms)); }\r\n\r\n  // same EMA helper as used in ScannerPage\r\n  function calculateEma(values, period) {\r\n    if (!Array.isArray(values) || values.length === 0) return [];\r\n    const k = 2 / (period + 1);\r\n    const out = [];\r\n    let ema = null;\r\n    for (let i = 0; i < values.length; i++) {\r\n      const v = Number(values[i]);\r\n      if (isNaN(v)) { out.push(null); continue; }\r\n      if (ema === null) {\r\n        if (i + 1 >= period) {\r\n          const slice = values.slice(i + 1 - period, i + 1).map(Number);\r\n          const s = slice.reduce((a, b) => a + b, 0) / period;\r\n          ema = s;\r\n          out.push(ema);\r\n        } else { out.push(null); }\r\n      } else {\r\n        ema = v * k + ema * (1 - k);\r\n        out.push(ema);\r\n      }\r\n    }\r\n    return out;\r\n  }\r\n\r\n  async function start(type, opts = {}) {\r\n    if (running) return;\r\n    if (typeof getSymbolsFn !== 'function') throw new Error('scannerManager: getSymbolsFn not set');\r\n  // initialize run state\r\n    running = true;\r\n    cancel = false;\r\n    results = [];\r\n    progress = { done: 0, total: 0 };\r\n    currentSymbol = null;\r\n  scanType = type || null;\r\n    scanStartTime = Date.now();\r\n    notify();\r\n    const list = (await Promise.resolve(getSymbolsFn())) || [];\r\n    // accept options: interval (e.g., '5m' or number of minutes), emaShort, emaLong\r\n    let interval = (opts && typeof opts.interval !== 'undefined') ? opts.interval : '5m';\r\n    if (typeof interval === 'number' || (typeof interval === 'string' && /^\\d+$/.test(interval))) interval = `${interval}m`;\r\n    const emaShort = (opts && typeof opts.emaShort !== 'undefined') ? parseInt(opts.emaShort, 10) : 26;\r\n    const emaLong = (opts && typeof opts.emaLong !== 'undefined') ? parseInt(opts.emaLong, 10) : 200;\r\n    const filtered = (Array.isArray(list) ? list.filter(s => typeof s === 'string' && /USDT$/i.test(s)) : []);\r\n    progress.total = filtered.length; notify();\r\n    const endpointBase = 'https://fapi.binance.com/fapi/v1/klines';\r\n\r\n  // concurrency controls: default to a faster parallelism for quicker scans\r\n  // These defaults can be overridden via opts when calling start()\r\n  // Adjusted defaults to slow the scanner a bit so a full pass is ~30s on typical symbol counts.\r\n  // Make defaults conservative to avoid triggering API rate-limit warnings\r\n  // Slightly faster defaults: increase parallelism and reduce inter-batch delay for quicker scans\r\n  // Keep conservative limits to avoid hitting API rate limits.\r\n  const concurrencyDefault = (opts && typeof opts.concurrency === 'number') ? Math.max(1, opts.concurrency) : 3;\r\n  const batchDelayBase = (opts && typeof opts.batchDelay === 'number') ? Math.max(0, opts.batchDelay) : 400; // ms between batches\r\n  // mutable runtime controls (auto-tuner will adjust these)\r\n  let concurrencyCurrent = concurrencyDefault;\r\n  let batchDelayCurrent = batchDelayBase;\r\n  // cap maxConcurrency to the starting concurrency by default to prevent aggressive ramp-up\r\n  const maxConcurrency = (opts && typeof opts.maxConcurrency === 'number') ? Math.max(1, opts.maxConcurrency) : concurrencyDefault;\r\n  // backoff/ramp state\r\n  let backoffCount = 0;\r\n  let consecutiveSuccesses = 0;\r\n  const successThreshold = (opts && typeof opts.rampSuccessThreshold === 'number') ? Math.max(1, opts.rampSuccessThreshold) : 3;\r\n  const minBatchDelay = (opts && typeof opts.minBatchDelay === 'number') ? Math.max(150, opts.minBatchDelay) : 200;\r\n\r\n  // helper to process one symbol; catches errors and always resolves\r\n    const processSymbol = async (sym) => {\r\n      if (cancel) return;\r\n      currentSymbol = sym; notify();\r\n      const url = `${endpointBase}?symbol=${encodeURIComponent(sym)}&interval=${encodeURIComponent(interval)}&limit=1000`;\r\n      let localAbort = null;\r\n      try {\r\n        try { localAbort = new AbortController(); } catch (e) { localAbort = null; }\r\n        if (localAbort) currentAbortControllers.add(localAbort);\r\n        const r = await fetch(url, localAbort ? { signal: localAbort.signal } : undefined);\r\n        if (!r.ok) {\r\n          if (r.status === 429) {\r\n            // increase backoff pressure and reduce concurrency\r\n            backoffCount += 1;\r\n            consecutiveSuccesses = 0;\r\n            concurrencyCurrent = Math.max(1, Math.floor(concurrencyCurrent * 0.6));\r\n            batchDelayCurrent = Math.min(30000, Math.floor(batchDelayCurrent * 1.6));\r\n            const base = 1000;\r\n            const backoffMs = Math.min(30000, Math.floor(base * Math.pow(2, Math.min(backoffCount, 6))) + Math.floor(Math.random() * 1000));\r\n            try { await sleep(backoffMs); } catch (e) {}\r\n          }\r\n          return;\r\n        }\r\n        const data = await r.json();\r\n        // success: reduce backoff pressure and allow gentle ramp-up\r\n        backoffCount = Math.max(0, backoffCount - 1);\r\n        consecutiveSuccesses += 1;\r\n        if (consecutiveSuccesses >= successThreshold) {\r\n          consecutiveSuccesses = 0;\r\n          if (concurrencyCurrent < maxConcurrency) {\r\n            concurrencyCurrent = concurrencyCurrent + 1;\r\n          }\r\n          batchDelayCurrent = Math.max(minBatchDelay, Math.floor(batchDelayCurrent * 0.85));\r\n        }\r\n        const closes = (Array.isArray(data) ? data.map(d => parseFloat(d[4])) : []);\r\n        const needed = Math.max(emaShort, emaLong) + 10;\r\n        if (!Array.isArray(closes) || closes.length < needed) { return; }\r\n        const emaShortArr = calculateEma(closes, emaShort);\r\n        const emaLongArr = calculateEma(closes, emaLong);\r\n        const lastIdx = closes.length - 1;\r\n        const prevIdx = lastIdx - 1;\r\n        const prevShort = emaShortArr[prevIdx];\r\n        const prevLong = emaLongArr[prevIdx];\r\n        const lastShort = emaShortArr[lastIdx];\r\n        const lastLong = emaLongArr[lastIdx];\r\n        let matched = false;\r\n        if (typeof prevShort === 'number' && typeof prevLong === 'number' && typeof lastShort === 'number' && typeof lastLong === 'number') {\r\n          if (type === 'golden') { if (prevShort <= prevLong && lastShort > lastLong) matched = true; }\r\n          else if (type === 'dead') { if (prevShort >= prevLong && lastShort < lastLong) matched = true; }\r\n        }\r\n        if (matched) {\r\n          // attach the scan type to the result so the UI can color icons per-result\r\n          // also capture the last candle volume so the UI can show & sort by volume\r\n          const lastVolume = (Array.isArray(data) && data[lastIdx] && typeof data[lastIdx][5] !== 'undefined') ? parseFloat(data[lastIdx][5]) : 0;\r\n          const ev = { id: `${sym}-${Date.now()}-${Math.random().toString(36).slice(2,8)}`, symbol: sym, lastShort, lastLong, time: new Date().toLocaleString(), interval, emaShort, emaLong, type, volume: lastVolume };\r\n          results.unshift(ev);\r\n          // cap stored results to reasonable size (avoid unbounded growth)\r\n          if (results.length > 500) results = results.slice(0, 500);\r\n          notify();\r\n        }\r\n      } catch (e) {\r\n        if (e && e.name === 'AbortError') {\r\n          // expected when stopping\r\n        } else {\r\n          // ignore other fetch errors\r\n        }\r\n      } finally {\r\n        // cleanup local abort controller\r\n        if (localAbort) currentAbortControllers.delete(localAbort);\r\n        progress.done += 1; notify();\r\n      }\r\n    };\r\n    // run in batches with a mutable concurrency controlled by the auto-tuner\r\n    let i = 0;\r\n    try {\r\n      while (i < filtered.length) {\r\n        if (cancel) break;\r\n        const currentConcurrency = Math.max(1, Math.floor(concurrencyCurrent));\r\n        const batch = filtered.slice(i, i + currentConcurrency);\r\n        if (!batch || batch.length === 0) break;\r\n        await Promise.all(batch.map(sym => processSymbol(sym)));\r\n        if (cancel) break;\r\n        i += batch.length;\r\n        if (i < filtered.length) {\r\n          const jitter = Math.floor(Math.random() * Math.min(300, Math.max(20, Math.floor(batchDelayCurrent * 0.5))));\r\n          const delay = Math.max(0, batchDelayCurrent + jitter);\r\n          await sleep(delay);\r\n        }\r\n      }\r\n    } catch (err) {\r\n      // log unexpected errors but don't leave scanner in running state\r\n      try { console.error('scannerManager.start error', err && err.message ? err.message : err); } catch (e) {}\r\n    } finally {\r\n      // cleanup any remaining abort controllers\r\n      try { for (const c of currentAbortControllers) { try { c.abort(); } catch (e) {} } } catch (e) {}\r\n      currentAbortControllers.clear();\r\n      running = false; currentSymbol = null; cancel = false; scanStartTime = null; notify();\r\n      // clear scanType after finishing\r\n      scanType = null;\r\n    }\r\n  }\r\n\r\n  function stop() {\r\n    // signal cancellation and abort any in-flight fetch\r\n    cancel = true;\r\n    try {\r\n      // abort any tracked controllers\r\n      for (const c of currentAbortControllers) {\r\n        try { if (c && typeof c.abort === 'function') c.abort(); } catch (e) {}\r\n      }\r\n      currentAbortControllers.clear();\r\n    } catch (e) {}\r\n    running = false; currentSymbol = null; scanStartTime = null;\r\n    // clear scanType when stopping so UI does not remain colored\r\n    scanType = null;\r\n    notify();\r\n  }\r\n\r\n  function getState() { return { running, currentSymbol, scanType, progress: { ...progress }, results: results.slice(), scanStartTime }; }\r\n\r\n  function removeResult(id) {\r\n    if (!id) return;\r\n    results = results.filter(r => r.id !== id);\r\n    notify();\r\n  }\r\n\r\n  function clearResults() {\r\n    results = [];\r\n    notify();\r\n  }\r\n\r\n  return { onUpdate, setGetSymbols, start, stop, getState, removeResult, clearResults };\r\n})();\r\n\r\nexport default scannerManager;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}