{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useState, useCallback } from 'react';\nimport { calculateInitialEMA, updateEMA } from '../utils/ema';\n\n// Hook options: { symbol }\nexport default function useEmaCross({\n  symbol = 'BTCUSDT',\n  autoConnect = true,\n  debug = false\n} = {}) {\n  _s();\n  const [ema26, setEma26] = useState(null);\n  const [ema200, setEma200] = useState(null);\n  const [lastPrice, setLastPrice] = useState(null);\n  const [cross, setCross] = useState(null); // preview (live) cross\n  const [confirmedCross, setConfirmedCross] = useState(null); // only updated on closed candles (confirmed)\n  const [confirmedSource, setConfirmedSource] = useState(null); // 'ws' | 'poll' | 'init'\n  const [connected, setConnected] = useState(false);\n  const [status, setStatus] = useState('idle');\n  const [lastCandleClosed, setLastCandleClosed] = useState(false);\n  const [activeSymbol, setActiveSymbol] = useState(null); // which symbol the hook has initialized/connected for\n\n  const wsRef = useRef(null);\n  const prevCrossRef = useRef(null);\n  const prevConfirmedRef = useRef(null);\n  const ema26Ref = useRef(null);\n  const ema200Ref = useRef(null);\n  // confirmed EMAs updated only on closed candles (kline.x === true) or polling\n  const ema26ConfirmedRef = useRef(null);\n  const ema200ConfirmedRef = useRef(null);\n  const reconnectAttemptsRef = useRef(0);\n  const reconnectTimerRef = useRef(null);\n  const currentSymbolRef = useRef(null);\n  const lastProcessedCloseRef = useRef(null); // timestamp (ms) of last processed closed candle\n  const pollingTimerRef = useRef(null);\n  const fetchAndInit = useCallback(async (target = symbol) => {\n    try {\n      const t = (target || symbol).toString();\n      setStatus('fetching historical klines');\n      const norm = t.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\n      // use Binance Futures (USDT-M) REST endpoint for klines (1m)\n      const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${norm}&interval=1m&limit=500`;\n      const res = await fetch(url);\n      if (!res.ok) throw new Error(`Failed to fetch klines: ${res.status}`);\n      const data = await res.json();\n      // kline array: [ openTime, open, high, low, close, ... ]\n      const closes = data.map(k => parseFloat(k[4]));\n      if (closes.length < 200) throw new Error('Not enough historical candles to initialize EMA200');\n\n      // Use the full close history to compute EMA values\n      const initEma26 = calculateInitialEMA(closes.slice(-300), 26);\n      const initEma200 = calculateInitialEMA(closes.slice(-500), 200);\n\n      // initialize both preview and confirmed EMAs from historical closes\n      ema26Ref.current = initEma26;\n      ema200Ref.current = initEma200;\n      ema26ConfirmedRef.current = initEma26;\n      ema200ConfirmedRef.current = initEma200;\n      // record which symbol these EMAs correspond to\n      currentSymbolRef.current = norm;\n      setActiveSymbol(norm);\n      // record last processed closed candle time (closeTime at index 6)\n      try {\n        lastProcessedCloseRef.current = data[data.length - 1][6];\n      } catch (e) {\n        lastProcessedCloseRef.current = null;\n      }\n      setEma26(initEma26);\n      setEma200(initEma200);\n      setLastPrice(closes[closes.length - 1]);\n      setStatus('initialized');\n      // set initial cross\n      const initialCross = initEma26 > initEma200 ? 'bull' : 'bear';\n      prevCrossRef.current = initialCross;\n      setCross(initialCross);\n      prevConfirmedRef.current = initialCross;\n      setConfirmedCross(initialCross);\n      setConfirmedSource('init');\n    } catch (err) {\n      setStatus(`init error: ${err.message}`);\n      console.error(err);\n    }\n  }, [symbol]);\n  const connect = useCallback(async overrideSymbol => {\n    const targetSymbol = (overrideSymbol || symbol).toString();\n    const targetNorm = targetSymbol.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\n    // if a websocket exists for same symbol, no-op\n    if (wsRef.current) {\n      if (currentSymbolRef.current === targetNorm) return;\n      try {\n        wsRef.current.close();\n      } catch (e) {}\n      wsRef.current = null;\n    }\n    // Ensure EMA is initialized for the target symbol before connecting\n    try {\n      const targetNorm = targetSymbol.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\n      if (currentSymbolRef.current !== targetNorm || ema26Ref.current == null || ema200Ref.current == null) {\n        await fetchAndInit(targetNorm);\n      }\n    } catch (err) {\n      setStatus(`init error: ${err.message}`);\n      return;\n    }\n    setStatus('connecting websocket');\n    // Use combined stream: kline_1m + aggTrade for higher-frequency trade updates\n    const klineStream = `${targetNorm.toLowerCase()}@kline_1m`;\n    const tradeStream = `${targetNorm.toLowerCase()}@aggTrade`;\n    const streams = `${klineStream}/${tradeStream}`;\n    // use Binance Futures (USDT-M) websocket (fstream) combined stream\n    const url = `wss://fstream.binance.com/stream?streams=${streams}`;\n    console.log('Connecting websocket for', targetSymbol, 'url=', url);\n    const ws = new WebSocket(url);\n    wsRef.current = ws;\n    ws.onopen = () => {\n      // reset backoff attempts on successful open\n      reconnectAttemptsRef.current = 0;\n      if (reconnectTimerRef.current) {\n        clearTimeout(reconnectTimerRef.current);\n        reconnectTimerRef.current = null;\n      }\n      // stop polling if it was started while socket was down\n      if (pollingTimerRef.current) {\n        clearInterval(pollingTimerRef.current);\n        pollingTimerRef.current = null;\n      }\n      currentSymbolRef.current = targetSymbol;\n      currentSymbolRef.current = targetNorm;\n      setActiveSymbol(targetNorm);\n      if (debug) console.log('[useEmaCross] websocket open for', targetNorm);\n      setConnected(true);\n      setStatus('connected');\n    };\n    ws.onmessage = ev => {\n      try {\n        const payloadWrapper = JSON.parse(ev.data);\n        // combined stream returns { stream, data }\n        const payload = payloadWrapper.data || payloadWrapper;\n\n        // determine the source symbol for this message (if available)\n        let sourceSymbol = null;\n        try {\n          if (payload && payload.s) sourceSymbol = payload.s.toString().toUpperCase();else if (payloadWrapper && payloadWrapper.stream) {\n            const streamName = payloadWrapper.stream.toString(); // e.g. trxusdt@aggTrade\n            sourceSymbol = streamName.split('@')[0].toUpperCase();\n          }\n        } catch (e) {\n          sourceSymbol = null;\n        }\n\n        // If the message is not for the currently-initialized symbol, ignore it.\n        if (currentSymbolRef.current && sourceSymbol) {\n          if (currentSymbolRef.current.toString().toUpperCase() !== sourceSymbol.toString().toUpperCase()) {\n            return; // ignore messages from other symbols\n          }\n        }\n\n        // aggTrade messages have event type 'aggTrade' and price in p\n        if (debug) {\n          try {\n            const streamName = payloadWrapper.stream || payload.e || 'unknown';\n            console.log('[useEmaCross] incoming', {\n              stream: streamName,\n              sourceSymbol,\n              event: payload.e || null\n            });\n          } catch (e) {}\n        }\n        if (payload.e === 'aggTrade') {\n          const price = parseFloat(payload.p);\n          setLastPrice(price);\n          if (ema26Ref.current == null || ema200Ref.current == null) return;\n\n          // update EMA using trade price to provide higher-frequency preview\n          const newEma26 = updateEMA(ema26Ref.current, price, 26);\n          const newEma200 = updateEMA(ema200Ref.current, price, 200);\n          // preview EMAs only\n          ema26Ref.current = newEma26;\n          ema200Ref.current = newEma200;\n          setEma26(newEma26);\n          setEma200(newEma200);\n          const newCross = newEma26 > newEma200 ? 'bull' : 'bear';\n          if (prevCrossRef.current !== newCross) {\n            prevCrossRef.current = newCross;\n            setCross(newCross);\n          }\n        }\n\n        // kline messages contain a 'k' object\n        if (payload.k) {\n          if (debug) console.log('[useEmaCross] kline payload x=', payload.k.x, 'close=', payload.k.c);\n          const k = payload.k;\n          const close = parseFloat(k.c);\n          setLastPrice(close);\n          setLastCandleClosed(Boolean(k.x));\n          if (ema26Ref.current == null || ema200Ref.current == null) return;\n\n          // update EMA using kline close\n          // For partial candle: update preview EMA only\n          if (!k.x) {\n            const newEma26 = updateEMA(ema26Ref.current, close, 26);\n            const newEma200 = updateEMA(ema200Ref.current, close, 200);\n            ema26Ref.current = newEma26;\n            ema200Ref.current = newEma200;\n            setEma26(newEma26);\n            setEma200(newEma200);\n          } else {\n            // closed candle: update confirmed EMAs only (and sync preview to confirmed)\n            if (ema26ConfirmedRef.current == null || ema200ConfirmedRef.current == null) {\n              // defensive: fall back to preview if confirmed not initialized\n              ema26ConfirmedRef.current = ema26Ref.current;\n              ema200ConfirmedRef.current = ema200Ref.current;\n            }\n            const newEma26c = updateEMA(ema26ConfirmedRef.current, close, 26);\n            const newEma200c = updateEMA(ema200ConfirmedRef.current, close, 200);\n            ema26ConfirmedRef.current = newEma26c;\n            ema200ConfirmedRef.current = newEma200c;\n            // sync preview to confirmed after closed candle to avoid drift\n            ema26Ref.current = newEma26c;\n            ema200Ref.current = newEma200c;\n            setEma26(newEma26c);\n            setEma200(newEma200c);\n          }\n\n          // compute preview (live) cross from preview EMAs\n          const previewCross = ema26Ref.current != null && ema200Ref.current != null ? ema26Ref.current > ema200Ref.current ? 'bull' : 'bear' : null;\n          if (previewCross && prevCrossRef.current !== previewCross) {\n            prevCrossRef.current = previewCross;\n            setCross(previewCross);\n          }\n          // If candle is closed (k.x === true) and it's a new closed candle, update processed time and set confirmed cross\n          if (Boolean(k.x)) {\n            try {\n              const closeTime = k.T || k.t || null; // k.T is close time in ms\n              if (closeTime && (!lastProcessedCloseRef.current || closeTime > lastProcessedCloseRef.current)) {\n                lastProcessedCloseRef.current = closeTime;\n                // compute confirmed cross using confirmed EMA refs (fallback to previewCross)\n                const confirmedNewCross = ema26ConfirmedRef.current != null && ema200ConfirmedRef.current != null ? ema26ConfirmedRef.current > ema200ConfirmedRef.current ? 'bull' : 'bear' : previewCross;\n                if (prevConfirmedRef.current !== confirmedNewCross) {\n                  prevConfirmedRef.current = confirmedNewCross;\n                  setConfirmedCross(confirmedNewCross);\n                  setConfirmedSource('ws');\n                }\n              }\n            } catch (e) {\n              // fallback: always set cross if changed (use preview cross)\n              if (prevConfirmedRef.current !== previewCross) {\n                prevConfirmedRef.current = previewCross;\n                setConfirmedCross(previewCross);\n                setConfirmedSource('ws');\n              }\n            }\n          } else {\n            // partial candle: preview already updated above\n          }\n        }\n      } catch (err) {\n        console.error('ws message parse error', err);\n      }\n    };\n    ws.onerror = e => {\n      console.error('ws error', e);\n      setStatus('websocket error');\n      // close to trigger backoff reconnect\n      try {\n        ws.close();\n      } catch (err) {}\n    };\n    ws.onclose = () => {\n      setConnected(false);\n      setStatus('websocket closed');\n      wsRef.current = null;\n      currentSymbolRef.current = null;\n      setActiveSymbol(null);\n      if (debug) console.log('[useEmaCross] websocket closed');\n      // start polling for closed candles while websocket is down\n      try {\n        if (!pollingTimerRef.current) {\n          pollingTimerRef.current = setInterval(async () => {\n            try {\n              const sym = (symbol || '').replace(/[^A-Za-z0-9]/g, '').toUpperCase();\n              if (!sym) return;\n              const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${sym}&interval=1m&limit=10`;\n              const res = await fetch(url);\n              if (!res.ok) return;\n              const data = await res.json();\n              // iterate candles in chronological order and process any closed candles newer than lastProcessedCloseRef\n              const newClosed = [];\n              for (const k of data) {\n                const closeTime = k[6];\n                if (closeTime && (!lastProcessedCloseRef.current || closeTime > lastProcessedCloseRef.current)) {\n                  newClosed.push(k);\n                }\n              }\n              if (newClosed.length > 0) {\n                // sort by closeTime asc\n                newClosed.sort((a, b) => a[6] - b[6]);\n                for (const k of newClosed) {\n                  const close = parseFloat(k[4]);\n                  // update EMAs using closed candle\n                  if (ema26Ref.current == null || ema200Ref.current == null) continue;\n                  // update confirmed EMAs using closed candle (polling)\n                  if (ema26ConfirmedRef.current == null || ema200ConfirmedRef.current == null) {\n                    ema26ConfirmedRef.current = ema26Ref.current;\n                    ema200ConfirmedRef.current = ema200Ref.current;\n                  }\n                  const newEma26c = updateEMA(ema26ConfirmedRef.current, close, 26);\n                  const newEma200c = updateEMA(ema200ConfirmedRef.current, close, 200);\n                  ema26ConfirmedRef.current = newEma26c;\n                  ema200ConfirmedRef.current = newEma200c;\n                  // sync preview to confirmed\n                  ema26Ref.current = newEma26c;\n                  ema200Ref.current = newEma200c;\n                  setEma26(newEma26c);\n                  setEma200(newEma200c);\n                  const newCross = newEma26c > newEma200c ? 'bull' : 'bear';\n                  if (prevConfirmedRef.current !== newCross) {\n                    prevConfirmedRef.current = newCross;\n                    setConfirmedCross(newCross);\n                    setConfirmedSource('poll');\n                  }\n                  lastProcessedCloseRef.current = k[6];\n                  setLastPrice(parseFloat(k[4]));\n                  setLastCandleClosed(true);\n                }\n              }\n            } catch (e) {\n              // ignore polling errors\n            }\n          }, 10 * 1000); // poll every 10s\n        }\n      } catch (e) {}\n      // exponential backoff reconnect with jitter\n      const attempt = reconnectAttemptsRef.current || 0;\n      const base = 1000; // 1s\n      const delay = Math.min(30000, base * Math.pow(2, attempt));\n      const jitter = Math.floor(Math.random() * 1000);\n      reconnectAttemptsRef.current = attempt + 1;\n      reconnectTimerRef.current = setTimeout(() => {\n        reconnectTimerRef.current = null;\n        if (!wsRef.current) {\n          // prefer reconnecting to the currently requested symbol if available\n          const target = currentSymbolRef.current || symbol;\n          try {\n            connect(target);\n          } catch (e) {\n            connect(target);\n          }\n        }\n      }, delay + jitter);\n    };\n  }, [symbol, fetchAndInit, debug]);\n  const disconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n    setConnected(false);\n    setStatus('disconnected');\n    setActiveSymbol(null);\n    if (pollingTimerRef.current) {\n      clearInterval(pollingTimerRef.current);\n      pollingTimerRef.current = null;\n    }\n    // clear reconnect attempts/timers\n    try {\n      reconnectAttemptsRef.current = 0;\n      if (reconnectTimerRef.current) {\n        clearTimeout(reconnectTimerRef.current);\n        reconnectTimerRef.current = null;\n      }\n    } catch (e) {}\n  }, []);\n  useEffect(() => {\n    // initialize on mount (or when symbol changes)\n    // Reset current state immediately so previous symbol's values don't show while new symbol initializes\n    try {\n      // close any existing websocket\n      if (wsRef.current) {\n        try {\n          wsRef.current.close();\n        } catch (e) {}\n        wsRef.current = null;\n      }\n\n      // clear reconnect timers and attempts\n      if (reconnectTimerRef.current) {\n        clearTimeout(reconnectTimerRef.current);\n        reconnectTimerRef.current = null;\n      }\n      reconnectAttemptsRef.current = 0;\n\n      // reset refs and state for EMA and cross\n      prevCrossRef.current = null;\n      currentSymbolRef.current = null;\n      ema26Ref.current = null;\n      ema200Ref.current = null;\n      setActiveSymbol(null);\n      setEma26(null);\n      setEma200(null);\n      setLastPrice(null);\n      setCross(null);\n      setLastCandleClosed(false);\n      setConnected(false);\n      setStatus('reloading');\n    } catch (e) {}\n    // fetch history for the (new) symbol and initialize\n    fetchAndInit();\n    // cleanup on unmount\n    return () => {\n      if (wsRef.current) wsRef.current.close();\n      if (pollingTimerRef.current) {\n        clearInterval(pollingTimerRef.current);\n        pollingTimerRef.current = null;\n      }\n    };\n  }, [fetchAndInit]);\n\n  // auto connect after initialization if requested\n  useEffect(() => {\n    if (status === 'initialized' && autoConnect) {\n      // call connect once after initialization\n      connect();\n    }\n    // only run when status or autoConnect changes\n  }, [status, autoConnect, connect]);\n  return {\n    ema26,\n    ema200,\n    lastPrice,\n    lastCandleClosed,\n    cross,\n    confirmedCross,\n    confirmedSource,\n    connected,\n    status,\n    connect,\n    disconnect,\n    activeSymbol\n  };\n}\n_s(useEmaCross, \"L5uY+wV89ZFduiae36KQNnXT7K4=\");","map":{"version":3,"names":["useEffect","useRef","useState","useCallback","calculateInitialEMA","updateEMA","useEmaCross","symbol","autoConnect","debug","_s","ema26","setEma26","ema200","setEma200","lastPrice","setLastPrice","cross","setCross","confirmedCross","setConfirmedCross","confirmedSource","setConfirmedSource","connected","setConnected","status","setStatus","lastCandleClosed","setLastCandleClosed","activeSymbol","setActiveSymbol","wsRef","prevCrossRef","prevConfirmedRef","ema26Ref","ema200Ref","ema26ConfirmedRef","ema200ConfirmedRef","reconnectAttemptsRef","reconnectTimerRef","currentSymbolRef","lastProcessedCloseRef","pollingTimerRef","fetchAndInit","target","t","toString","norm","replace","toUpperCase","url","res","fetch","ok","Error","data","json","closes","map","k","parseFloat","length","initEma26","slice","initEma200","current","e","initialCross","err","message","console","error","connect","overrideSymbol","targetSymbol","targetNorm","close","klineStream","toLowerCase","tradeStream","streams","log","ws","WebSocket","onopen","clearTimeout","clearInterval","onmessage","ev","payloadWrapper","JSON","parse","payload","sourceSymbol","s","stream","streamName","split","event","price","p","newEma26","newEma200","newCross","x","c","Boolean","newEma26c","newEma200c","previewCross","closeTime","T","confirmedNewCross","onerror","onclose","setInterval","sym","newClosed","push","sort","a","b","attempt","base","delay","Math","min","pow","jitter","floor","random","setTimeout","disconnect"],"sources":["C:/Users/e1it3/Desktop/program/binance_alert/src/hooks/useEmaCross.js"],"sourcesContent":["import { useEffect, useRef, useState, useCallback } from 'react';\r\nimport { calculateInitialEMA, updateEMA } from '../utils/ema';\r\n\r\n// Hook options: { symbol }\r\nexport default function useEmaCross({ symbol = 'BTCUSDT', autoConnect = true, debug = false } = {}) {\r\n  const [ema26, setEma26] = useState(null);\r\n  const [ema200, setEma200] = useState(null);\r\n  const [lastPrice, setLastPrice] = useState(null);\r\n  const [cross, setCross] = useState(null); // preview (live) cross\r\n  const [confirmedCross, setConfirmedCross] = useState(null); // only updated on closed candles (confirmed)\r\n  const [confirmedSource, setConfirmedSource] = useState(null); // 'ws' | 'poll' | 'init'\r\n  const [connected, setConnected] = useState(false);\r\n  const [status, setStatus] = useState('idle');\r\n  const [lastCandleClosed, setLastCandleClosed] = useState(false);\r\n  const [activeSymbol, setActiveSymbol] = useState(null); // which symbol the hook has initialized/connected for\r\n\r\n  const wsRef = useRef(null);\r\n  const prevCrossRef = useRef(null);\r\n  const prevConfirmedRef = useRef(null);\r\n  const ema26Ref = useRef(null);\r\n  const ema200Ref = useRef(null);\r\n  // confirmed EMAs updated only on closed candles (kline.x === true) or polling\r\n  const ema26ConfirmedRef = useRef(null);\r\n  const ema200ConfirmedRef = useRef(null);\r\n  const reconnectAttemptsRef = useRef(0);\r\n  const reconnectTimerRef = useRef(null);\r\n  const currentSymbolRef = useRef(null);\r\n  const lastProcessedCloseRef = useRef(null); // timestamp (ms) of last processed closed candle\r\n  const pollingTimerRef = useRef(null);\r\n\r\n  const fetchAndInit = useCallback(async (target = symbol) => {\r\n    try {\r\n      const t = (target || symbol).toString();\r\n      setStatus('fetching historical klines');\r\n      const norm = t.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n  // use Binance Futures (USDT-M) REST endpoint for klines (1m)\r\n  const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${norm}&interval=1m&limit=500`;\r\n      const res = await fetch(url);\r\n      if (!res.ok) throw new Error(`Failed to fetch klines: ${res.status}`);\r\n      const data = await res.json();\r\n      // kline array: [ openTime, open, high, low, close, ... ]\r\n  const closes = data.map((k) => parseFloat(k[4]));\r\n\r\n      if (closes.length < 200) throw new Error('Not enough historical candles to initialize EMA200');\r\n\r\n      // Use the full close history to compute EMA values\r\n      const initEma26 = calculateInitialEMA(closes.slice(-300), 26);\r\n      const initEma200 = calculateInitialEMA(closes.slice(-500), 200);\r\n\r\n    // initialize both preview and confirmed EMAs from historical closes\r\n    ema26Ref.current = initEma26;\r\n  ema200Ref.current = initEma200;\r\n    ema26ConfirmedRef.current = initEma26;\r\n    ema200ConfirmedRef.current = initEma200;\r\n      // record which symbol these EMAs correspond to\r\n      currentSymbolRef.current = norm;\r\n      setActiveSymbol(norm);\r\n      // record last processed closed candle time (closeTime at index 6)\r\n      try { lastProcessedCloseRef.current = data[data.length - 1][6]; } catch (e) { lastProcessedCloseRef.current = null; }\r\n      setEma26(initEma26);\r\n      setEma200(initEma200);\r\n      setLastPrice(closes[closes.length - 1]);\r\n      setStatus('initialized');\r\n      // set initial cross\r\n      const initialCross = initEma26 > initEma200 ? 'bull' : 'bear';\r\n      prevCrossRef.current = initialCross;\r\n  setCross(initialCross);\r\n  prevConfirmedRef.current = initialCross;\r\n  setConfirmedCross(initialCross);\r\n  setConfirmedSource('init');\r\n    } catch (err) {\r\n      setStatus(`init error: ${err.message}`);\r\n      console.error(err);\r\n    }\r\n  }, [symbol]);\r\n\r\n  const connect = useCallback(async (overrideSymbol) => {\r\n    const targetSymbol = (overrideSymbol || symbol).toString();\r\n    const targetNorm = targetSymbol.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n    // if a websocket exists for same symbol, no-op\r\n    if (wsRef.current) {\r\n      if (currentSymbolRef.current === targetNorm) return;\r\n      try { wsRef.current.close(); } catch (e) {}\r\n      wsRef.current = null;\r\n    }\r\n    // Ensure EMA is initialized for the target symbol before connecting\r\n    try {\r\n      const targetNorm = targetSymbol.replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n      if (currentSymbolRef.current !== targetNorm || ema26Ref.current == null || ema200Ref.current == null) {\r\n        await fetchAndInit(targetNorm);\r\n      }\r\n    } catch (err) {\r\n      setStatus(`init error: ${err.message}`);\r\n      return;\r\n    }\r\n\r\n    setStatus('connecting websocket');\r\n    // Use combined stream: kline_1m + aggTrade for higher-frequency trade updates\r\n  const klineStream = `${targetNorm.toLowerCase()}@kline_1m`;\r\n  const tradeStream = `${targetNorm.toLowerCase()}@aggTrade`;\r\n    const streams = `${klineStream}/${tradeStream}`;\r\n  // use Binance Futures (USDT-M) websocket (fstream) combined stream\r\n  const url = `wss://fstream.binance.com/stream?streams=${streams}`;\r\n  console.log('Connecting websocket for', targetSymbol, 'url=', url);\r\n  const ws = new WebSocket(url);\r\n    wsRef.current = ws;\r\n\r\n    ws.onopen = () => {\r\n      // reset backoff attempts on successful open\r\n      reconnectAttemptsRef.current = 0;\r\n      if (reconnectTimerRef.current) {\r\n        clearTimeout(reconnectTimerRef.current);\r\n        reconnectTimerRef.current = null;\r\n      }\r\n      // stop polling if it was started while socket was down\r\n      if (pollingTimerRef.current) {\r\n        clearInterval(pollingTimerRef.current);\r\n        pollingTimerRef.current = null;\r\n      }\r\n      currentSymbolRef.current = targetSymbol;\r\n      currentSymbolRef.current = targetNorm;\r\n      setActiveSymbol(targetNorm);\r\n      if (debug) console.log('[useEmaCross] websocket open for', targetNorm);\r\n      setConnected(true);\r\n      setStatus('connected');\r\n    };\r\n\r\n    ws.onmessage = (ev) => {\r\n      try {\r\n        const payloadWrapper = JSON.parse(ev.data);\r\n        // combined stream returns { stream, data }\r\n        const payload = payloadWrapper.data || payloadWrapper;\r\n\r\n        // determine the source symbol for this message (if available)\r\n        let sourceSymbol = null;\r\n        try {\r\n          if (payload && payload.s) sourceSymbol = payload.s.toString().toUpperCase();\r\n          else if (payloadWrapper && payloadWrapper.stream) {\r\n            const streamName = payloadWrapper.stream.toString(); // e.g. trxusdt@aggTrade\r\n            sourceSymbol = streamName.split('@')[0].toUpperCase();\r\n          }\r\n        } catch (e) { sourceSymbol = null; }\r\n\r\n        // If the message is not for the currently-initialized symbol, ignore it.\r\n        if (currentSymbolRef.current && sourceSymbol) {\r\n            if (currentSymbolRef.current.toString().toUpperCase() !== sourceSymbol.toString().toUpperCase()) {\r\n            return; // ignore messages from other symbols\r\n          }\r\n        }\r\n\r\n        // aggTrade messages have event type 'aggTrade' and price in p\r\n        if (debug) {\r\n          try {\r\n            const streamName = payloadWrapper.stream || payload.e || 'unknown';\r\n            console.log('[useEmaCross] incoming', { stream: streamName, sourceSymbol, event: payload.e || null });\r\n          } catch (e) {}\r\n        }\r\n        if (payload.e === 'aggTrade') {\r\n          const price = parseFloat(payload.p);\r\n          setLastPrice(price);\r\n\r\n          if (ema26Ref.current == null || ema200Ref.current == null) return;\r\n\r\n          // update EMA using trade price to provide higher-frequency preview\r\n          const newEma26 = updateEMA(ema26Ref.current, price, 26);\r\n          const newEma200 = updateEMA(ema200Ref.current, price, 200);\r\n          // preview EMAs only\r\n          ema26Ref.current = newEma26;\r\n          ema200Ref.current = newEma200;\r\n          setEma26(newEma26);\r\n          setEma200(newEma200);\r\n\r\n          const newCross = newEma26 > newEma200 ? 'bull' : 'bear';\r\n          if (prevCrossRef.current !== newCross) {\r\n            prevCrossRef.current = newCross;\r\n            setCross(newCross);\r\n          }\r\n        }\r\n\r\n        // kline messages contain a 'k' object\r\n        if (payload.k) {\r\n          if (debug) console.log('[useEmaCross] kline payload x=', payload.k.x, 'close=', payload.k.c);\r\n          const k = payload.k;\r\n          const close = parseFloat(k.c);\r\n          setLastPrice(close);\r\n          setLastCandleClosed(Boolean(k.x));\r\n\r\n          if (ema26Ref.current == null || ema200Ref.current == null) return;\r\n\r\n          // update EMA using kline close\r\n          // For partial candle: update preview EMA only\r\n          if (!k.x) {\r\n            const newEma26 = updateEMA(ema26Ref.current, close, 26);\r\n            const newEma200 = updateEMA(ema200Ref.current, close, 200);\r\n            ema26Ref.current = newEma26;\r\n            ema200Ref.current = newEma200;\r\n            setEma26(newEma26);\r\n            setEma200(newEma200);\r\n          } else {\r\n            // closed candle: update confirmed EMAs only (and sync preview to confirmed)\r\n            if (ema26ConfirmedRef.current == null || ema200ConfirmedRef.current == null) {\r\n              // defensive: fall back to preview if confirmed not initialized\r\n              ema26ConfirmedRef.current = ema26Ref.current;\r\n              ema200ConfirmedRef.current = ema200Ref.current;\r\n            }\r\n            const newEma26c = updateEMA(ema26ConfirmedRef.current, close, 26);\r\n            const newEma200c = updateEMA(ema200ConfirmedRef.current, close, 200);\r\n            ema26ConfirmedRef.current = newEma26c;\r\n            ema200ConfirmedRef.current = newEma200c;\r\n            // sync preview to confirmed after closed candle to avoid drift\r\n            ema26Ref.current = newEma26c;\r\n            ema200Ref.current = newEma200c;\r\n            setEma26(newEma26c);\r\n            setEma200(newEma200c);\r\n          }\r\n\r\n          // compute preview (live) cross from preview EMAs\r\n          const previewCross = (ema26Ref.current != null && ema200Ref.current != null) ? (ema26Ref.current > ema200Ref.current ? 'bull' : 'bear') : null;\r\n          if (previewCross && prevCrossRef.current !== previewCross) {\r\n            prevCrossRef.current = previewCross;\r\n            setCross(previewCross);\r\n          }\r\n          // If candle is closed (k.x === true) and it's a new closed candle, update processed time and set confirmed cross\r\n          if (Boolean(k.x)) {\r\n            try {\r\n              const closeTime = k.T || k.t || null; // k.T is close time in ms\r\n              if (closeTime && (!lastProcessedCloseRef.current || closeTime > lastProcessedCloseRef.current)) {\r\n                lastProcessedCloseRef.current = closeTime;\r\n                // compute confirmed cross using confirmed EMA refs (fallback to previewCross)\r\n                const confirmedNewCross = (ema26ConfirmedRef.current != null && ema200ConfirmedRef.current != null) ? (ema26ConfirmedRef.current > ema200ConfirmedRef.current ? 'bull' : 'bear') : previewCross;\r\n                if (prevConfirmedRef.current !== confirmedNewCross) {\r\n                  prevConfirmedRef.current = confirmedNewCross;\r\n                  setConfirmedCross(confirmedNewCross);\r\n                  setConfirmedSource('ws');\r\n                }\r\n              }\r\n            } catch (e) {\r\n              // fallback: always set cross if changed (use preview cross)\r\n              if (prevConfirmedRef.current !== previewCross) {\r\n                prevConfirmedRef.current = previewCross;\r\n                setConfirmedCross(previewCross);\r\n                setConfirmedSource('ws');\r\n              }\r\n            }\r\n          } else {\r\n            // partial candle: preview already updated above\r\n          }\r\n        }\r\n      } catch (err) {\r\n        console.error('ws message parse error', err);\r\n      }\r\n    };\r\n\r\n    ws.onerror = (e) => {\r\n      console.error('ws error', e);\r\n      setStatus('websocket error');\r\n      // close to trigger backoff reconnect\r\n      try { ws.close(); } catch (err) {}\r\n    };\r\n\r\n    ws.onclose = () => {\r\n      setConnected(false);\r\n      setStatus('websocket closed');\r\n      wsRef.current = null;\r\n      currentSymbolRef.current = null;\r\n      setActiveSymbol(null);\r\n      if (debug) console.log('[useEmaCross] websocket closed');\r\n      // start polling for closed candles while websocket is down\r\n      try {\r\n        if (!pollingTimerRef.current) {\r\n          pollingTimerRef.current = setInterval(async () => {\r\n            try {\r\n              const sym = (symbol || '').replace(/[^A-Za-z0-9]/g, '').toUpperCase();\r\n              if (!sym) return;\r\n              const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${sym}&interval=1m&limit=10`;\r\n              const res = await fetch(url);\r\n              if (!res.ok) return;\r\n              const data = await res.json();\r\n              // iterate candles in chronological order and process any closed candles newer than lastProcessedCloseRef\r\n              const newClosed = [];\r\n              for (const k of data) {\r\n                const closeTime = k[6];\r\n                if (closeTime && (!lastProcessedCloseRef.current || closeTime > lastProcessedCloseRef.current)) {\r\n                  newClosed.push(k);\r\n                }\r\n              }\r\n              if (newClosed.length > 0) {\r\n                // sort by closeTime asc\r\n                newClosed.sort((a, b) => a[6] - b[6]);\r\n                for (const k of newClosed) {\r\n                  const close = parseFloat(k[4]);\r\n                  // update EMAs using closed candle\r\n                  if (ema26Ref.current == null || ema200Ref.current == null) continue;\r\n                  // update confirmed EMAs using closed candle (polling)\r\n                  if (ema26ConfirmedRef.current == null || ema200ConfirmedRef.current == null) {\r\n                    ema26ConfirmedRef.current = ema26Ref.current;\r\n                    ema200ConfirmedRef.current = ema200Ref.current;\r\n                  }\r\n                  const newEma26c = updateEMA(ema26ConfirmedRef.current, close, 26);\r\n                  const newEma200c = updateEMA(ema200ConfirmedRef.current, close, 200);\r\n                  ema26ConfirmedRef.current = newEma26c;\r\n                  ema200ConfirmedRef.current = newEma200c;\r\n                  // sync preview to confirmed\r\n                  ema26Ref.current = newEma26c;\r\n                  ema200Ref.current = newEma200c;\r\n                  setEma26(newEma26c);\r\n                  setEma200(newEma200c);\r\n                  const newCross = newEma26c > newEma200c ? 'bull' : 'bear';\r\n                    if (prevConfirmedRef.current !== newCross) {\r\n                      prevConfirmedRef.current = newCross;\r\n                        setConfirmedCross(newCross);\r\n                        setConfirmedSource('poll');\r\n                    }\r\n                  lastProcessedCloseRef.current = k[6];\r\n                  setLastPrice(parseFloat(k[4]));\r\n                  setLastCandleClosed(true);\r\n                }\r\n              }\r\n            } catch (e) {\r\n              // ignore polling errors\r\n            }\r\n          }, 10 * 1000); // poll every 10s\r\n        }\r\n      } catch (e) {}\r\n      // exponential backoff reconnect with jitter\r\n      const attempt = reconnectAttemptsRef.current || 0;\r\n      const base = 1000; // 1s\r\n      const delay = Math.min(30000, base * Math.pow(2, attempt));\r\n      const jitter = Math.floor(Math.random() * 1000);\r\n      reconnectAttemptsRef.current = attempt + 1;\r\n      reconnectTimerRef.current = setTimeout(() => {\r\n        reconnectTimerRef.current = null;\r\n        if (!wsRef.current) {\r\n          // prefer reconnecting to the currently requested symbol if available\r\n          const target = currentSymbolRef.current || symbol;\r\n          try { connect(target); } catch (e) { connect(target); }\r\n        }\r\n      }, delay + jitter);\r\n    };\r\n  }, [symbol, fetchAndInit, debug]);\r\n\r\n  const disconnect = useCallback(() => {\r\n    if (wsRef.current) {\r\n      wsRef.current.close();\r\n      wsRef.current = null;\r\n    }\r\n    setConnected(false);\r\n    setStatus('disconnected');\r\n    setActiveSymbol(null);\r\n    if (pollingTimerRef.current) {\r\n      clearInterval(pollingTimerRef.current);\r\n      pollingTimerRef.current = null;\r\n    }\r\n    // clear reconnect attempts/timers\r\n    try {\r\n      reconnectAttemptsRef.current = 0;\r\n      if (reconnectTimerRef.current) {\r\n        clearTimeout(reconnectTimerRef.current);\r\n        reconnectTimerRef.current = null;\r\n      }\r\n    } catch (e) {}\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    // initialize on mount (or when symbol changes)\r\n    // Reset current state immediately so previous symbol's values don't show while new symbol initializes\r\n    try {\r\n      // close any existing websocket\r\n      if (wsRef.current) {\r\n        try { wsRef.current.close(); } catch (e) {}\r\n        wsRef.current = null;\r\n      }\r\n\r\n      // clear reconnect timers and attempts\r\n      if (reconnectTimerRef.current) {\r\n        clearTimeout(reconnectTimerRef.current);\r\n        reconnectTimerRef.current = null;\r\n      }\r\n      reconnectAttemptsRef.current = 0;\r\n\r\n      // reset refs and state for EMA and cross\r\n      prevCrossRef.current = null;\r\n      currentSymbolRef.current = null;\r\n      ema26Ref.current = null;\r\n      ema200Ref.current = null;\r\n  setActiveSymbol(null);\r\n      setEma26(null);\r\n      setEma200(null);\r\n      setLastPrice(null);\r\n      setCross(null);\r\n      setLastCandleClosed(false);\r\n      setConnected(false);\r\n      setStatus('reloading');\r\n    } catch (e) {}\r\n    // fetch history for the (new) symbol and initialize\r\n    fetchAndInit();\r\n    // cleanup on unmount\r\n    return () => {\r\n      if (wsRef.current) wsRef.current.close();\r\n      if (pollingTimerRef.current) {\r\n        clearInterval(pollingTimerRef.current);\r\n        pollingTimerRef.current = null;\r\n      }\r\n    };\r\n  }, [fetchAndInit]);\r\n\r\n  // auto connect after initialization if requested\r\n  useEffect(() => {\r\n    if (status === 'initialized' && autoConnect) {\r\n      // call connect once after initialization\r\n      connect();\r\n    }\r\n    // only run when status or autoConnect changes\r\n  }, [status, autoConnect, connect]);\r\n\r\n  return {\r\n    ema26,\r\n    ema200,\r\n    lastPrice,\r\n    lastCandleClosed,\r\n    cross,\r\n    confirmedCross,\r\n    confirmedSource,\r\n    connected,\r\n    status,\r\n    connect,\r\n    disconnect,\r\n    activeSymbol,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}