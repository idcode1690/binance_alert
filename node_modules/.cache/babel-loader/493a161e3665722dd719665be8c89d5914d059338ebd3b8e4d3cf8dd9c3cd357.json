{"ast":null,"code":"// Simple singleton scanner manager to run scans independent of React component lifecycle.\nconst scannerManager = (() => {\n  let running = false;\n  let currentSymbol = null;\n  let progress = {\n    done: 0,\n    total: 0\n  };\n  // load persisted results from localStorage when available so navigation doesn't lose matches\n  let results = [];\n  try {\n    if (typeof window !== 'undefined' && window.localStorage) {\n      const raw = window.localStorage.getItem('scannerResults');\n      if (raw) results = JSON.parse(raw) || [];\n    }\n  } catch (e) {\n    results = [];\n  }\n  let cancel = false;\n  // track multiple abort controllers when running requests in parallel\n  let currentAbortControllers = new Set();\n  let listeners = new Set();\n  let getSymbolsFn = null;\n  function notify() {\n    const state = {\n      running,\n      currentSymbol,\n      progress: {\n        ...progress\n      },\n      results: results.slice()\n    };\n    for (const cb of listeners) {\n      try {\n        cb(state);\n      } catch (e) {}\n    }\n    // persist results after notifying\n    try {\n      if (typeof window !== 'undefined' && window.localStorage) {\n        window.localStorage.setItem('scannerResults', JSON.stringify(results.slice(0, 200)));\n      }\n    } catch (e) {}\n  }\n  function onUpdate(cb) {\n    listeners.add(cb);\n    return () => listeners.delete(cb);\n  }\n  function setGetSymbols(fn) {\n    getSymbolsFn = fn;\n  }\n  function sleep(ms) {\n    return new Promise(r => setTimeout(r, ms));\n  }\n\n  // same EMA helper as used in ScannerPage\n  function calculateEma(values, period) {\n    if (!Array.isArray(values) || values.length === 0) return [];\n    const k = 2 / (period + 1);\n    const out = [];\n    let ema = null;\n    for (let i = 0; i < values.length; i++) {\n      const v = Number(values[i]);\n      if (isNaN(v)) {\n        out.push(null);\n        continue;\n      }\n      if (ema === null) {\n        if (i + 1 >= period) {\n          const slice = values.slice(i + 1 - period, i + 1).map(Number);\n          const s = slice.reduce((a, b) => a + b, 0) / period;\n          ema = s;\n          out.push(ema);\n        } else {\n          out.push(null);\n        }\n      } else {\n        ema = v * k + ema * (1 - k);\n        out.push(ema);\n      }\n    }\n    return out;\n  }\n  async function start(type, opts = {}) {\n    if (running) return;\n    if (typeof getSymbolsFn !== 'function') throw new Error('scannerManager: getSymbolsFn not set');\n    running = true;\n    cancel = false;\n    results = [];\n    progress = {\n      done: 0,\n      total: 0\n    };\n    currentSymbol = null;\n    notify();\n    const list = (await Promise.resolve(getSymbolsFn())) || [];\n    // accept options: interval (e.g., '5m' or number of minutes), emaShort, emaLong\n    let interval = opts && typeof opts.interval !== 'undefined' ? opts.interval : '5m';\n    if (typeof interval === 'number' || typeof interval === 'string' && /^\\d+$/.test(interval)) interval = `${interval}m`;\n    const emaShort = opts && typeof opts.emaShort !== 'undefined' ? parseInt(opts.emaShort, 10) : 26;\n    const emaLong = opts && typeof opts.emaLong !== 'undefined' ? parseInt(opts.emaLong, 10) : 200;\n    const filtered = Array.isArray(list) ? list.filter(s => typeof s === 'string' && /USDT$/i.test(s)) : [];\n    progress.total = filtered.length;\n    notify();\n    const endpointBase = 'https://fapi.binance.com/fapi/v1/klines';\n\n    // concurrency controls: default to a more conservative parallelism to avoid rate limits\n    const concurrency = opts && typeof opts.concurrency === 'number' ? Math.max(1, opts.concurrency) : 2;\n    const batchDelay = opts && typeof opts.batchDelay === 'number' ? Math.max(0, opts.batchDelay) : 1000; // ms between batches (default slower)\n\n    // helper to process one symbol; catches errors and always resolves\n    const processSymbol = async sym => {\n      if (cancel) return;\n      currentSymbol = sym;\n      notify();\n      const url = `${endpointBase}?symbol=${encodeURIComponent(sym)}&interval=${encodeURIComponent(interval)}&limit=1000`;\n      let localAbort = null;\n      try {\n        try {\n          localAbort = new AbortController();\n        } catch (e) {\n          localAbort = null;\n        }\n        if (localAbort) currentAbortControllers.add(localAbort);\n        const r = await fetch(url, localAbort ? {\n          signal: localAbort.signal\n        } : undefined);\n        if (!r.ok) {\n          if (r.status === 429) await sleep(2000);\n          return;\n        }\n        const data = await r.json();\n        const closes = Array.isArray(data) ? data.map(d => parseFloat(d[4])) : [];\n        const needed = Math.max(emaShort, emaLong) + 10;\n        if (!Array.isArray(closes) || closes.length < needed) {\n          return;\n        }\n        const emaShortArr = calculateEma(closes, emaShort);\n        const emaLongArr = calculateEma(closes, emaLong);\n        const lastIdx = closes.length - 1;\n        const prevIdx = lastIdx - 1;\n        const prevShort = emaShortArr[prevIdx];\n        const prevLong = emaLongArr[prevIdx];\n        const lastShort = emaShortArr[lastIdx];\n        const lastLong = emaLongArr[lastIdx];\n        let matched = false;\n        if (typeof prevShort === 'number' && typeof prevLong === 'number' && typeof lastShort === 'number' && typeof lastLong === 'number') {\n          if (type === 'golden') {\n            if (prevShort <= prevLong && lastShort > lastLong) matched = true;\n          } else if (type === 'dead') {\n            if (prevShort >= prevLong && lastShort < lastLong) matched = true;\n          }\n        }\n        if (matched) {\n          const ev = {\n            id: `${sym}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,\n            symbol: sym,\n            lastShort,\n            lastLong,\n            time: new Date().toLocaleString(),\n            interval,\n            emaShort,\n            emaLong\n          };\n          results.unshift(ev);\n          // cap stored results to reasonable size (avoid unbounded growth)\n          if (results.length > 500) results = results.slice(0, 500);\n          notify();\n        }\n      } catch (e) {\n        if (e && e.name === 'AbortError') {\n          // expected when stopping\n        } else {\n          // ignore other fetch errors\n        }\n      } finally {\n        // cleanup local abort controller\n        if (localAbort) currentAbortControllers.delete(localAbort);\n        progress.done += 1;\n        notify();\n      }\n    };\n\n    // run in batches with limited concurrency\n    for (let i = 0; i < filtered.length; i += concurrency) {\n      if (cancel) break;\n      const batch = filtered.slice(i, i + concurrency);\n      // start batch in parallel, ensure errors don't reject Promise.all\n      await Promise.all(batch.map(sym => processSymbol(sym)));\n      if (cancel) break;\n      // small delay between batches to reduce chance of triggering rate limits\n      if (i + concurrency < filtered.length) await sleep(batchDelay);\n    }\n    // cleanup any remaining abort controllers\n    try {\n      for (const c of currentAbortControllers) {\n        try {\n          c.abort();\n        } catch (e) {}\n      }\n    } catch (e) {}\n    currentAbortControllers.clear();\n    running = false;\n    currentSymbol = null;\n    cancel = false;\n    notify();\n  }\n  function stop() {\n    // signal cancellation and abort any in-flight fetch\n    cancel = true;\n    try {\n      // abort any tracked controllers\n      for (const c of currentAbortControllers) {\n        try {\n          if (c && typeof c.abort === 'function') c.abort();\n        } catch (e) {}\n      }\n      currentAbortControllers.clear();\n    } catch (e) {}\n    running = false;\n    currentSymbol = null;\n    notify();\n  }\n  function getState() {\n    return {\n      running,\n      currentSymbol,\n      progress: {\n        ...progress\n      },\n      results: results.slice()\n    };\n  }\n  function removeResult(id) {\n    if (!id) return;\n    results = results.filter(r => r.id !== id);\n    notify();\n  }\n  function clearResults() {\n    results = [];\n    notify();\n  }\n  return {\n    onUpdate,\n    setGetSymbols,\n    start,\n    stop,\n    getState,\n    removeResult,\n    clearResults\n  };\n})();\nexport default scannerManager;","map":{"version":3,"names":["scannerManager","running","currentSymbol","progress","done","total","results","window","localStorage","raw","getItem","JSON","parse","e","cancel","currentAbortControllers","Set","listeners","getSymbolsFn","notify","state","slice","cb","setItem","stringify","onUpdate","add","delete","setGetSymbols","fn","sleep","ms","Promise","r","setTimeout","calculateEma","values","period","Array","isArray","length","k","out","ema","i","v","Number","isNaN","push","map","s","reduce","a","b","start","type","opts","Error","list","resolve","interval","test","emaShort","parseInt","emaLong","filtered","filter","endpointBase","concurrency","Math","max","batchDelay","processSymbol","sym","url","encodeURIComponent","localAbort","AbortController","fetch","signal","undefined","ok","status","data","json","closes","d","parseFloat","needed","emaShortArr","emaLongArr","lastIdx","prevIdx","prevShort","prevLong","lastShort","lastLong","matched","ev","id","Date","now","random","toString","symbol","time","toLocaleString","unshift","name","batch","all","c","abort","clear","stop","getState","removeResult","clearResults"],"sources":["C:/Users/e1it3/Desktop/program/binance_alert/src/lib/scannerManager.js"],"sourcesContent":["// Simple singleton scanner manager to run scans independent of React component lifecycle.\r\nconst scannerManager = (() => {\r\n  let running = false;\r\n  let currentSymbol = null;\r\n  let progress = { done: 0, total: 0 };\r\n  // load persisted results from localStorage when available so navigation doesn't lose matches\r\n  let results = [];\r\n  try {\r\n    if (typeof window !== 'undefined' && window.localStorage) {\r\n      const raw = window.localStorage.getItem('scannerResults');\r\n      if (raw) results = JSON.parse(raw) || [];\r\n    }\r\n  } catch (e) {\r\n    results = [];\r\n  }\r\n  let cancel = false;\r\n  // track multiple abort controllers when running requests in parallel\r\n  let currentAbortControllers = new Set();\r\n  let listeners = new Set();\r\n  let getSymbolsFn = null;\r\n\r\n  function notify() {\r\n    const state = { running, currentSymbol, progress: { ...progress }, results: results.slice() };\r\n    for (const cb of listeners) {\r\n      try { cb(state); } catch (e) {}\r\n    }\r\n    // persist results after notifying\r\n    try {\r\n      if (typeof window !== 'undefined' && window.localStorage) {\r\n        window.localStorage.setItem('scannerResults', JSON.stringify(results.slice(0, 200)));\r\n      }\r\n    } catch (e) {}\r\n  }\r\n\r\n  function onUpdate(cb) { listeners.add(cb); return () => listeners.delete(cb); }\r\n\r\n  function setGetSymbols(fn) { getSymbolsFn = fn; }\r\n\r\n  function sleep(ms) { return new Promise((r) => setTimeout(r, ms)); }\r\n\r\n  // same EMA helper as used in ScannerPage\r\n  function calculateEma(values, period) {\r\n    if (!Array.isArray(values) || values.length === 0) return [];\r\n    const k = 2 / (period + 1);\r\n    const out = [];\r\n    let ema = null;\r\n    for (let i = 0; i < values.length; i++) {\r\n      const v = Number(values[i]);\r\n      if (isNaN(v)) { out.push(null); continue; }\r\n      if (ema === null) {\r\n        if (i + 1 >= period) {\r\n          const slice = values.slice(i + 1 - period, i + 1).map(Number);\r\n          const s = slice.reduce((a, b) => a + b, 0) / period;\r\n          ema = s;\r\n          out.push(ema);\r\n        } else { out.push(null); }\r\n      } else {\r\n        ema = v * k + ema * (1 - k);\r\n        out.push(ema);\r\n      }\r\n    }\r\n    return out;\r\n  }\r\n\r\n  async function start(type, opts = {}) {\r\n    if (running) return;\r\n    if (typeof getSymbolsFn !== 'function') throw new Error('scannerManager: getSymbolsFn not set');\r\n    running = true; cancel = false; results = []; progress = { done: 0, total: 0 }; currentSymbol = null; notify();\r\n    const list = (await Promise.resolve(getSymbolsFn())) || [];\r\n    // accept options: interval (e.g., '5m' or number of minutes), emaShort, emaLong\r\n    let interval = (opts && typeof opts.interval !== 'undefined') ? opts.interval : '5m';\r\n    if (typeof interval === 'number' || (typeof interval === 'string' && /^\\d+$/.test(interval))) interval = `${interval}m`;\r\n    const emaShort = (opts && typeof opts.emaShort !== 'undefined') ? parseInt(opts.emaShort, 10) : 26;\r\n    const emaLong = (opts && typeof opts.emaLong !== 'undefined') ? parseInt(opts.emaLong, 10) : 200;\r\n    const filtered = (Array.isArray(list) ? list.filter(s => typeof s === 'string' && /USDT$/i.test(s)) : []);\r\n    progress.total = filtered.length; notify();\r\n    const endpointBase = 'https://fapi.binance.com/fapi/v1/klines';\r\n\r\n  // concurrency controls: default to a more conservative parallelism to avoid rate limits\r\n  const concurrency = (opts && typeof opts.concurrency === 'number') ? Math.max(1, opts.concurrency) : 2;\r\n  const batchDelay = (opts && typeof opts.batchDelay === 'number') ? Math.max(0, opts.batchDelay) : 1000; // ms between batches (default slower)\r\n\r\n    // helper to process one symbol; catches errors and always resolves\r\n    const processSymbol = async (sym) => {\r\n      if (cancel) return;\r\n      currentSymbol = sym; notify();\r\n      const url = `${endpointBase}?symbol=${encodeURIComponent(sym)}&interval=${encodeURIComponent(interval)}&limit=1000`;\r\n      let localAbort = null;\r\n      try {\r\n        try { localAbort = new AbortController(); } catch (e) { localAbort = null; }\r\n        if (localAbort) currentAbortControllers.add(localAbort);\r\n        const r = await fetch(url, localAbort ? { signal: localAbort.signal } : undefined);\r\n        if (!r.ok) {\r\n          if (r.status === 429) await sleep(2000);\r\n          return;\r\n        }\r\n        const data = await r.json();\r\n        const closes = (Array.isArray(data) ? data.map(d => parseFloat(d[4])) : []);\r\n        const needed = Math.max(emaShort, emaLong) + 10;\r\n        if (!Array.isArray(closes) || closes.length < needed) { return; }\r\n        const emaShortArr = calculateEma(closes, emaShort);\r\n        const emaLongArr = calculateEma(closes, emaLong);\r\n        const lastIdx = closes.length - 1;\r\n        const prevIdx = lastIdx - 1;\r\n        const prevShort = emaShortArr[prevIdx];\r\n        const prevLong = emaLongArr[prevIdx];\r\n        const lastShort = emaShortArr[lastIdx];\r\n        const lastLong = emaLongArr[lastIdx];\r\n        let matched = false;\r\n        if (typeof prevShort === 'number' && typeof prevLong === 'number' && typeof lastShort === 'number' && typeof lastLong === 'number') {\r\n          if (type === 'golden') { if (prevShort <= prevLong && lastShort > lastLong) matched = true; }\r\n          else if (type === 'dead') { if (prevShort >= prevLong && lastShort < lastLong) matched = true; }\r\n        }\r\n        if (matched) {\r\n          const ev = { id: `${sym}-${Date.now()}-${Math.random().toString(36).slice(2,8)}`, symbol: sym, lastShort, lastLong, time: new Date().toLocaleString(), interval, emaShort, emaLong };\r\n          results.unshift(ev);\r\n          // cap stored results to reasonable size (avoid unbounded growth)\r\n          if (results.length > 500) results = results.slice(0, 500);\r\n          notify();\r\n        }\r\n      } catch (e) {\r\n        if (e && e.name === 'AbortError') {\r\n          // expected when stopping\r\n        } else {\r\n          // ignore other fetch errors\r\n        }\r\n      } finally {\r\n        // cleanup local abort controller\r\n        if (localAbort) currentAbortControllers.delete(localAbort);\r\n        progress.done += 1; notify();\r\n      }\r\n    };\r\n\r\n    // run in batches with limited concurrency\r\n    for (let i = 0; i < filtered.length; i += concurrency) {\r\n      if (cancel) break;\r\n      const batch = filtered.slice(i, i + concurrency);\r\n      // start batch in parallel, ensure errors don't reject Promise.all\r\n      await Promise.all(batch.map(sym => processSymbol(sym)));\r\n      if (cancel) break;\r\n      // small delay between batches to reduce chance of triggering rate limits\r\n      if (i + concurrency < filtered.length) await sleep(batchDelay);\r\n    }\r\n  // cleanup any remaining abort controllers\r\n  try { for (const c of currentAbortControllers) { try { c.abort(); } catch (e) {} } } catch (e) {}\r\n  currentAbortControllers.clear();\r\n  running = false; currentSymbol = null; cancel = false; notify();\r\n  }\r\n\r\n  function stop() {\r\n    // signal cancellation and abort any in-flight fetch\r\n    cancel = true;\r\n    try {\r\n      // abort any tracked controllers\r\n      for (const c of currentAbortControllers) {\r\n        try { if (c && typeof c.abort === 'function') c.abort(); } catch (e) {}\r\n      }\r\n      currentAbortControllers.clear();\r\n    } catch (e) {}\r\n    running = false; currentSymbol = null; notify();\r\n  }\r\n\r\n  function getState() { return { running, currentSymbol, progress: { ...progress }, results: results.slice() }; }\r\n\r\n  function removeResult(id) {\r\n    if (!id) return;\r\n    results = results.filter(r => r.id !== id);\r\n    notify();\r\n  }\r\n\r\n  function clearResults() {\r\n    results = [];\r\n    notify();\r\n  }\r\n\r\n  return { onUpdate, setGetSymbols, start, stop, getState, removeResult, clearResults };\r\n})();\r\n\r\nexport default scannerManager;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}