{"ast":null,"code":"// Optimized singleton scanner manager to run scans independent of React component lifecycle.\nconst scannerManager = (() => {\n  let running = false;\n  let currentSymbol = null;\n  let scanType = null;\n  let progress = {\n    done: 0,\n    total: 0\n  };\n  let results = [];\n  // activeMatches: map of symbol -> active match info for real-time monitoring\n  let activeMatches = {};\n  try {\n    if (typeof window !== 'undefined' && window.localStorage) {\n      const raw = window.localStorage.getItem('scannerResults');\n      if (raw) results = JSON.parse(raw) || [];\n    }\n  } catch (e) {\n    results = [];\n  }\n  let cancel = false;\n  let scanStartTime = null;\n  let currentAbortControllers = new Set();\n  let listeners = new Set();\n  let getSymbolsFn = null;\n  let workerInstance = null;\n  // throttle notifications to reduce render overhead\n  let lastNotifyTs = 0;\n  let pendingNotify = false;\n  function stateSnapshot() {\n    return {\n      running,\n      currentSymbol,\n      scanType,\n      progress: {\n        ...progress\n      },\n      results: results.slice(),\n      active: Object.values(activeMatches),\n      scanStartTime\n    };\n  }\n  function notifyNow() {\n    const s = stateSnapshot();\n    for (const cb of listeners) {\n      try {\n        cb(s);\n      } catch (e) {}\n    }\n    try {\n      if (typeof window !== 'undefined' && window.localStorage) {\n        window.localStorage.setItem('scannerResults', JSON.stringify(results.slice(0, 200)));\n      }\n    } catch (e) {}\n  }\n  function notifyThrottled(force = false) {\n    try {\n      const now = Date.now();\n      // If the page is hidden (background tab), don't rely on setTimeout-based throttling\n      // which browsers may clamp heavily; instead deliver notifications synchronously so\n      // the React state held by listeners stays up-to-date when the tab becomes visible.\n      const isHidden = typeof document !== 'undefined' && document.hidden;\n      if (isHidden) {\n        lastNotifyTs = now;\n        pendingNotify = false;\n        notifyNow();\n        return;\n      }\n      if (force || now - lastNotifyTs >= 100) {\n        lastNotifyTs = now;\n        pendingNotify = false;\n        notifyNow();\n        return;\n      }\n      if (!pendingNotify) {\n        pendingNotify = true;\n        const wait = Math.max(0, 100 - (now - lastNotifyTs));\n        setTimeout(() => {\n          lastNotifyTs = Date.now();\n          pendingNotify = false;\n          notifyNow();\n        }, wait);\n      }\n    } catch (e) {\n      try {\n        notifyNow();\n      } catch (e2) {}\n    }\n  }\n  function onUpdate(cb) {\n    listeners.add(cb);\n    return () => listeners.delete(cb);\n  }\n  function setGetSymbols(fn) {\n    getSymbolsFn = fn;\n  }\n  const sleep = ms => new Promise(r => setTimeout(r, ms));\n  function calculateEma(values, period) {\n    if (!Array.isArray(values) || values.length === 0) return [];\n    const k = 2 / (period + 1);\n    const out = [];\n    let ema = null;\n    for (let i = 0; i < values.length; i++) {\n      const v = Number(values[i]);\n      if (isNaN(v)) {\n        out.push(null);\n        continue;\n      }\n      if (ema === null) {\n        if (i + 1 >= period) {\n          const slice = values.slice(i + 1 - period, i + 1).map(Number);\n          ema = slice.reduce((a, b) => a + b, 0) / period;\n          out.push(ema);\n        } else {\n          out.push(null);\n        }\n      } else {\n        ema = v * k + ema * (1 - k);\n        out.push(ema);\n      }\n    }\n    return out;\n  }\n  async function start(type, opts = {}) {\n    if (running) return;\n    try {\n      console.log('[scannerManager] start called', {\n        type,\n        opts\n      });\n    } catch (e) {}\n    if (typeof getSymbolsFn !== 'function') throw new Error('scannerManager: getSymbolsFn not set');\n    running = true;\n    cancel = false;\n    results = [];\n    progress = {\n      done: 0,\n      total: 0\n    };\n    currentSymbol = null;\n    scanType = type || null;\n    scanStartTime = Date.now();\n    notifyThrottled(true);\n    const list = (await Promise.resolve(getSymbolsFn())) || [];\n    let interval = opts && typeof opts.interval !== 'undefined' ? opts.interval : '5m';\n    if (typeof interval === 'number' || typeof interval === 'string' && /^\\d+$/.test(String(interval))) interval = `${interval}m`;\n    const emaShort = opts && typeof opts.emaShort !== 'undefined' ? parseInt(opts.emaShort, 10) : 26;\n    const emaLong = opts && typeof opts.emaLong !== 'undefined' ? parseInt(opts.emaLong, 10) : 200;\n    // Normalize / sanitize incoming symbol list to reduce typos like 'BTCSTUSDT'\n    const sanitizeSymbol = raw => {\n      if (!raw) return '';\n      try {\n        let s = String(raw).toUpperCase();\n        // strip any non-alphanumeric chars\n        s = s.replace(/[^A-Z0-9]/g, '');\n        // collapse repeated USDT occurrences (e.g. 'BTCUSDTUSDT' -> 'BTCUSDT')\n        s = s.replace(/(USDT)+$/g, 'USDT');\n        s = s.replace(/USDTUSDT/g, 'USDT');\n        // If the result doesn't end with USDT it's not a futures symbol we care about\n        if (!/USDT$/.test(s)) return '';\n        // Basic sanity: symbol length should be reasonable\n        if (s.length < 6 || s.length > 12) return '';\n        return s;\n      } catch (e) {\n        return '';\n      }\n    };\n\n    // Build a unique, normalized filtered list to use for API calls.\n    const normalized = [];\n    if (Array.isArray(list)) {\n      const seen = new Set();\n      for (const it of list) {\n        const n = sanitizeSymbol(it);\n        if (!n) continue;\n        if (seen.has(n)) continue;\n        seen.add(n);\n        normalized.push(n);\n      }\n    }\n    const filtered = normalized;\n    // Validate symbols against Binance exchangeInfo to avoid scanning invalid/typo symbols\n    progress.total = filtered.length;\n    notifyThrottled(true);\n    try {\n      const infoUrl = 'https://fapi.binance.com/fapi/v1/exchangeInfo';\n      const infoResp = await fetch(infoUrl, {\n        cf: {\n          cacheTtl: 600\n        }\n      });\n      if (infoResp && infoResp.ok) {\n        const info = await infoResp.json().catch(() => null);\n        if (info && Array.isArray(info.symbols)) {\n          const validSet = new Set(info.symbols.map(s => String(s.symbol).toUpperCase()));\n          const before = filtered.length;\n          const cleaned = filtered.map(s => String(s).toUpperCase()).filter(s => validSet.has(s));\n          if (cleaned.length !== before) {\n            try {\n              console.log('[scannerManager] removed invalid symbols', {\n                before,\n                after: cleaned.length\n              });\n            } catch (e) {}\n          }\n          // use cleaned list (preserve case as original list may vary)\n          const cleanedMap = new Map();\n          filtered.forEach(s => cleanedMap.set(String(s).toUpperCase(), s));\n          const finalList = cleaned.map(su => cleanedMap.get(su) || su);\n          // replace filtered variable\n          // eslint-disable-next-line no-param-reassign\n          filtered.length = 0;\n          Array.prototype.push.apply(filtered, finalList);\n          progress.total = filtered.length;\n          notifyThrottled(true);\n        }\n      }\n    } catch (e) {\n      try {\n        console.warn('[scannerManager] exchangeInfo fetch failed', e && e.message ? e.message : e);\n      } catch (e2) {}\n    }\n    const endpointBase = 'https://fapi.binance.com/fapi/v1/klines';\n\n    // Try to delegate scanning to dedicated worker (served at /worker-scanner.js)\n    const symbolsArray = Array.isArray(list) ? list : [];\n    // Only delegate to the dedicated worker for single-run scans.\n    // For continuous monitoring (`opts.monitor`), run inline loop to allow repeated passes.\n    try {\n      console.log('[scannerManager] monitorMode?', !!(opts && opts.monitor));\n    } catch (e) {}\n    if (!opts.monitor && typeof Worker !== 'undefined' && typeof window !== 'undefined') {\n      try {\n        workerInstance = new Worker('/worker-scanner.js');\n        let workerReady = false;\n        const onMsg = ev => {\n          const m = ev.data || {};\n          if (m.type === 'started') {\n            workerReady = true;\n            progress.total = m.total || progress.total;\n            notifyThrottled(true);\n          } else if (m.type === 'progress') {\n            workerReady = true;\n            progress.done = m.done || progress.done;\n            currentSymbol = m.currentSymbol || currentSymbol;\n            notifyThrottled();\n          } else if (m.type === 'match' && m.ev) {\n            workerReady = true;\n            results.unshift(m.ev);\n            if (results.length > 500) results = results.slice(0, 500);\n            notifyThrottled();\n          } else if (m.type === 'done') {\n            // worker finished its task\n            try {\n              workerInstance.terminate();\n            } catch (e) {}\n            workerInstance = null;\n            running = false;\n            currentSymbol = null;\n            cancel = false;\n            scanStartTime = null;\n            notifyThrottled(true);\n          } else if (m.type === 'stopped') {\n            try {\n              workerInstance.terminate();\n            } catch (e) {}\n            workerInstance = null;\n            running = false;\n            currentSymbol = null;\n            cancel = false;\n            scanStartTime = null;\n            notifyThrottled(true);\n          }\n        };\n        workerInstance.addEventListener('message', onMsg);\n        workerInstance.addEventListener('error', err => {\n          try {\n            console.warn('scanner worker error', err);\n          } catch (e) {}\n        });\n        // send start command with symbols and options\n        try {\n          workerInstance.postMessage({\n            cmd: 'start',\n            symbols: symbolsArray,\n            opts,\n            scanType: type\n          });\n        } catch (e) {/* ignore */}\n\n        // Wait briefly for the worker to acknowledge (avoid stuck 'Scanning: ...' if worker asset missing or blocked)\n        const waitMs = 2000;\n        await new Promise(resolve => {\n          const to = setTimeout(() => {\n            if (!workerReady) {\n              try {\n                workerInstance.removeEventListener('message', onMsg);\n              } catch (e) {}\n              try {\n                workerInstance.terminate();\n              } catch (e) {}\n              workerInstance = null;\n            }\n            resolve();\n          }, waitMs);\n          // if worker signals readiness before timeout, resolve early\n          const early = () => {\n            clearTimeout(to);\n            resolve();\n          };\n          const checkInterval = setInterval(() => {\n            if (workerReady) {\n              clearInterval(checkInterval);\n              early();\n            }\n          }, 50);\n        });\n\n        // If worker started and is handling the scan, return early\n        if (workerInstance) {\n          // worker is active and will manage scanning\n          return;\n        }\n        // else fallthrough to inline scanner\n      } catch (e) {\n        try {\n          if (workerInstance) {\n            workerInstance.terminate();\n            workerInstance = null;\n          }\n        } catch (e2) {}\n        // fallthrough to inline scanner\n      }\n    }\n    const concurrencyDefault = opts && typeof opts.concurrency === 'number' ? Math.max(1, opts.concurrency) : 8;\n    const batchDelayBase = opts && typeof opts.batchDelay === 'number' ? Math.max(0, opts.batchDelay) : 120;\n    let concurrencyCurrent = concurrencyDefault;\n    let batchDelayCurrent = batchDelayBase;\n    const maxConcurrency = opts && typeof opts.maxConcurrency === 'number' ? Math.max(1, opts.maxConcurrency) : 12;\n    let backoffCount = 0;\n    let consecutiveSuccesses = 0;\n    const successThreshold = opts && typeof opts.rampSuccessThreshold === 'number' ? Math.max(1, opts.rampSuccessThreshold) : 3;\n    const minBatchDelay = opts && typeof opts.minBatchDelay === 'number' ? Math.max(50, opts.minBatchDelay) : 60;\n    const neededCandles = Math.max(emaShort, emaLong) + 10;\n    // Allow caller to request a specific kline limit (e.g., 200). If not provided,\n    // fall back to previous heuristic which ensured at least ~120 candles.\n    const klineLimitOpt = opts && typeof opts.klineLimit === 'number' ? Math.max(0, parseInt(opts.klineLimit, 10)) : null;\n    const candleLimit = Number.isFinite(klineLimitOpt) && klineLimitOpt > 0 ? Math.min(1000, Math.max(klineLimitOpt, neededCandles + 1)) : Math.min(1000, Math.max(neededCandles + 10, 120));\n    const processSymbol = async sym => {\n      if (cancel) return;\n      currentSymbol = sym;\n      notifyThrottled();\n      const url = `${endpointBase}?symbol=${encodeURIComponent(sym)}&interval=${encodeURIComponent(interval)}&limit=${candleLimit}`;\n      let localAbort = null;\n      try {\n        localAbort = new AbortController();\n        currentAbortControllers.add(localAbort);\n      } catch (e) {}\n      try {\n        const r = await fetch(url, localAbort ? {\n          signal: localAbort.signal\n        } : undefined);\n        if (!r.ok) {\n          // Too many requests -> backoff and retry later\n          if (r.status === 429) {\n            backoffCount += 1;\n            consecutiveSuccesses = 0;\n            concurrencyCurrent = Math.max(1, Math.floor(concurrencyCurrent * 0.6));\n            batchDelayCurrent = Math.min(30000, Math.floor(batchDelayCurrent * 1.6));\n            const backoffMs = Math.min(30000, 1000 * Math.pow(2, Math.min(backoffCount, 6)) + Math.floor(Math.random() * 1000));\n            await sleep(backoffMs);\n            return;\n          }\n          // Bad request often means an invalid symbol (typo or delisted). Remove it to avoid repeated 400s.\n          if (r.status === 400) {\n            try {\n              console.warn('[scannerManager] removing invalid symbol due to 400', sym);\n            } catch (e) {}\n            try {\n              const idx = filtered.indexOf(sym);\n              if (idx !== -1) {\n                filtered.splice(idx, 1);\n                progress.total = filtered.length;\n                notifyThrottled(true);\n              }\n            } catch (e) {}\n            return;\n          }\n          return;\n        }\n        const data = await r.json();\n        backoffCount = Math.max(0, backoffCount - 1);\n        consecutiveSuccesses += 1;\n        if (consecutiveSuccesses >= successThreshold) {\n          consecutiveSuccesses = 0;\n          if (concurrencyCurrent < maxConcurrency) concurrencyCurrent += 1;\n          batchDelayCurrent = Math.max(minBatchDelay, Math.floor(batchDelayCurrent * 0.85));\n        }\n        const closes = Array.isArray(data) ? data.map(d => parseFloat(d[4])) : [];\n        // require one extra candle so we can use the last closed candle (avoid counting the live/open candle)\n        if (!Array.isArray(closes) || closes.length < neededCandles + 1) return;\n        const emaShortArr = calculateEma(closes, emaShort);\n        const emaLongArr = calculateEma(closes, emaLong);\n        const lastClosedIdx = closes.length - 2;\n        const prevIdx = lastClosedIdx - 1;\n        const prevShort = emaShortArr[prevIdx];\n        const prevLong = emaLongArr[prevIdx];\n        const lastShort = emaShortArr[lastClosedIdx];\n        const lastLong = emaLongArr[lastClosedIdx];\n        let matched = false;\n        if (typeof prevShort === 'number' && typeof prevLong === 'number' && typeof lastShort === 'number' && typeof lastLong === 'number') {\n          if (scanType === 'golden') matched = prevShort <= prevLong && lastShort > lastLong;else if (scanType === 'dead') matched = prevShort >= prevLong && lastShort < lastLong;\n        }\n        const lastVolume = Array.isArray(data) && data[lastClosedIdx] && data[lastClosedIdx][5] != null ? parseFloat(data[lastClosedIdx][5]) : 0;\n        // Real-time monitoring behavior: maintain activeMatches map. When a symbol becomes matched, add it; when it stops matching, remove it.\n        if (matched) {\n          try {\n            console.log('[scannerManager] match detected', sym, {\n              scanType,\n              emaShort,\n              emaLong\n            });\n          } catch (e) {}\n          if (!activeMatches[sym]) {\n            const ev = {\n              id: `${sym}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,\n              symbol: sym,\n              prevShort,\n              prevLong,\n              lastShort,\n              lastLong,\n              time: new Date().toLocaleString(),\n              interval,\n              emaShort,\n              emaLong,\n              type: scanType,\n              volume: lastVolume\n            };\n            activeMatches[sym] = ev;\n            // also keep history results for reference\n            results.unshift(ev);\n            if (results.length > 500) results = results.slice(0, 500);\n            notifyThrottled();\n            try {\n              console.log('[scannerManager] active add', sym);\n            } catch (e) {}\n          } else {\n            // update existing active entry with latest values\n            activeMatches[sym] = {\n              ...activeMatches[sym],\n              prevShort,\n              prevLong,\n              lastShort,\n              lastLong,\n              time: new Date().toLocaleString(),\n              volume: lastVolume\n            };\n            try {\n              console.log('[scannerManager] active update', sym);\n            } catch (e) {}\n          }\n        } else {\n          if (activeMatches[sym]) {\n            try {\n              console.log('[scannerManager] match cleared', sym);\n            } catch (e) {}\n            delete activeMatches[sym];\n            notifyThrottled();\n          }\n        }\n      } catch (e) {/* ignore */} finally {\n        if (localAbort) currentAbortControllers.delete(localAbort);\n        progress.done += 1;\n        notifyThrottled();\n      }\n    };\n\n    // support continuous monitoring mode: if opts.monitor=true, repeat full passes until stopped\n    const monitorMode = !!(opts && opts.monitor);\n    const pollIntervalMs = opts && typeof opts.pollIntervalMs === 'number' ? Math.max(1000, opts.pollIntervalMs) : null;\n    async function runFullPass() {\n      let i = 0;\n      try {\n        console.log('[scannerManager] runFullPass start', {\n          scanType,\n          interval,\n          total: filtered.length,\n          time: new Date().toISOString()\n        });\n      } catch (e) {}\n      while (i < filtered.length) {\n        if (cancel) break;\n        const currentConcurrency = Math.max(1, Math.floor(concurrencyCurrent));\n        const batch = filtered.slice(i, i + currentConcurrency);\n        if (!batch.length) break;\n        await Promise.all(batch.map(sym => processSymbol(sym)));\n        if (cancel) break;\n        i += batch.length;\n        if (i < filtered.length) {\n          // When the page is hidden, browser timers may be clamped and make the scanner\n          // appear to 'stop'. In that case, keep scans going but be conservative: reduce\n          // concurrency to 1 and use a very small yield to avoid relying on long setTimeouts.\n          try {\n            const isHidden = typeof document !== 'undefined' && document.hidden;\n            if (isHidden) {\n              // small yield so we don't spin the event loop too hard, but avoid long sleeps\n              await sleep(20);\n            } else {\n              const jitter = Math.floor(Math.random() * Math.min(120, Math.max(10, Math.floor(batchDelayCurrent * 0.5))));\n              const delay = Math.max(0, batchDelayCurrent + jitter);\n              await sleep(delay);\n            }\n          } catch (e) {/* ignore */}\n        }\n      }\n      try {\n        console.log('[scannerManager] runFullPass done', {\n          processed: i,\n          time: new Date().toISOString()\n        });\n      } catch (e) {}\n    }\n    try {\n      let passCount = 0;\n      do {\n        passCount += 1;\n        try {\n          console.log('[scannerManager] monitoring pass start', {\n            passCount,\n            monitorMode,\n            time: new Date().toISOString()\n          });\n        } catch (e) {}\n        // reset progress for this pass\n        progress.done = 0;\n        progress.total = filtered.length;\n        notifyThrottled(true);\n        await runFullPass();\n        if (cancel) break;\n        // if not monitoring, break after one pass\n        if (!monitorMode) break;\n        // wait for poll interval (default to interval minutes + 5 seconds if not provided)\n        let waitMs = pollIntervalMs;\n        if (!waitMs) {\n          // try to derive from interval string like '5m'\n          const m = String(interval || '').match(/^(\\d+)m$/);\n          if (m) {\n            waitMs = parseInt(m[1], 10) * 60 * 1000 + 5000;\n          } else {\n            waitMs = 30000;\n          }\n        }\n        const step = 1000;\n        let slept = 0;\n        try {\n          console.log('[scannerManager] waiting between passes', {\n            waitMs\n          });\n        } catch (e) {}\n        while (slept < waitMs && !cancel) {\n          const to = Math.min(step, waitMs - slept);\n          await sleep(to);\n          slept += to;\n        }\n        try {\n          console.log('[scannerManager] waiting complete', {\n            passCount,\n            time: new Date().toISOString()\n          });\n        } catch (e) {}\n      } while (!cancel);\n    } catch (err) {\n      try {\n        console.error('scannerManager.start error', err && err.message ? err.message : err);\n      } catch (e) {}\n    } finally {\n      try {\n        for (const c of currentAbortControllers) {\n          try {\n            c.abort();\n          } catch (e) {}\n        }\n      } catch (e) {}\n      currentAbortControllers.clear();\n      running = false;\n      currentSymbol = null;\n      cancel = false;\n      scanStartTime = null;\n      scanType = null;\n      notifyThrottled(true);\n    }\n  }\n  function stop() {\n    cancel = true;\n    try {\n      for (const c of currentAbortControllers) {\n        try {\n          c.abort();\n        } catch (e) {}\n      }\n      currentAbortControllers.clear();\n    } catch (e) {}\n    // If a worker is running, tell it to stop and terminate it\n    try {\n      if (workerInstance) {\n        try {\n          workerInstance.postMessage({\n            cmd: 'stop'\n          });\n        } catch (e) {}\n        try {\n          workerInstance.terminate();\n        } catch (e) {}\n        workerInstance = null;\n      }\n    } catch (e) {}\n    running = false;\n    currentSymbol = null;\n    scanStartTime = null;\n    scanType = null;\n    notifyThrottled(true);\n  }\n  function getState() {\n    return stateSnapshot();\n  }\n  function removeResult(id) {\n    if (!id) return;\n    results = results.filter(r => r.id !== id);\n    notifyThrottled();\n  }\n  function clearResults() {\n    results = [];\n    notifyThrottled(true);\n  }\n  function removeActive(symbol) {\n    if (!symbol) return;\n    if (activeMatches[symbol]) {\n      delete activeMatches[symbol];\n      notifyThrottled(true);\n    }\n  }\n  return {\n    onUpdate,\n    setGetSymbols,\n    start,\n    stop,\n    getState,\n    removeResult,\n    clearResults,\n    removeActive\n  };\n})();\nexport default scannerManager;","map":{"version":3,"names":["scannerManager","running","currentSymbol","scanType","progress","done","total","results","activeMatches","window","localStorage","raw","getItem","JSON","parse","e","cancel","scanStartTime","currentAbortControllers","Set","listeners","getSymbolsFn","workerInstance","lastNotifyTs","pendingNotify","stateSnapshot","slice","active","Object","values","notifyNow","s","cb","setItem","stringify","notifyThrottled","force","now","Date","isHidden","document","hidden","wait","Math","max","setTimeout","e2","onUpdate","add","delete","setGetSymbols","fn","sleep","ms","Promise","r","calculateEma","period","Array","isArray","length","k","out","ema","i","v","Number","isNaN","push","map","reduce","a","b","start","type","opts","console","log","Error","list","resolve","interval","test","String","emaShort","parseInt","emaLong","sanitizeSymbol","toUpperCase","replace","normalized","seen","it","n","has","filtered","infoUrl","infoResp","fetch","cf","cacheTtl","ok","info","json","catch","symbols","validSet","symbol","before","cleaned","filter","after","cleanedMap","Map","forEach","set","finalList","su","get","prototype","apply","warn","message","endpointBase","symbolsArray","monitor","Worker","workerReady","onMsg","ev","m","data","unshift","terminate","addEventListener","err","postMessage","cmd","waitMs","to","removeEventListener","early","clearTimeout","checkInterval","setInterval","clearInterval","concurrencyDefault","concurrency","batchDelayBase","batchDelay","concurrencyCurrent","batchDelayCurrent","maxConcurrency","backoffCount","consecutiveSuccesses","successThreshold","rampSuccessThreshold","minBatchDelay","neededCandles","klineLimitOpt","klineLimit","candleLimit","isFinite","min","processSymbol","sym","url","encodeURIComponent","localAbort","AbortController","signal","undefined","status","floor","backoffMs","pow","random","idx","indexOf","splice","closes","d","parseFloat","emaShortArr","emaLongArr","lastClosedIdx","prevIdx","prevShort","prevLong","lastShort","lastLong","matched","lastVolume","id","toString","time","toLocaleString","volume","monitorMode","pollIntervalMs","runFullPass","toISOString","currentConcurrency","batch","all","jitter","delay","processed","passCount","match","step","slept","error","c","abort","clear","stop","getState","removeResult","clearResults","removeActive"],"sources":["C:/Users/e1it3/Desktop/program/binance_alert/src/lib/scannerManager.js"],"sourcesContent":["// Optimized singleton scanner manager to run scans independent of React component lifecycle.\r\nconst scannerManager = (() => {\r\n  let running = false;\r\n  let currentSymbol = null;\r\n  let scanType = null;\r\n  let progress = { done: 0, total: 0 };\r\n  let results = [];\r\n  // activeMatches: map of symbol -> active match info for real-time monitoring\r\n  let activeMatches = {};\r\n  try { if (typeof window !== 'undefined' && window.localStorage) { const raw = window.localStorage.getItem('scannerResults'); if (raw) results = JSON.parse(raw) || []; } } catch (e) { results = []; }\r\n  let cancel = false;\r\n  let scanStartTime = null;\r\n  let currentAbortControllers = new Set();\r\n  let listeners = new Set();\r\n  let getSymbolsFn = null;\r\n  let workerInstance = null;\r\n  // throttle notifications to reduce render overhead\r\n  let lastNotifyTs = 0; let pendingNotify = false;\r\n\r\n  function stateSnapshot() { return { running, currentSymbol, scanType, progress: { ...progress }, results: results.slice(), active: Object.values(activeMatches), scanStartTime }; }\r\n  function notifyNow() {\r\n    const s = stateSnapshot();\r\n    for (const cb of listeners) { try { cb(s); } catch (e) {} }\r\n    try { if (typeof window !== 'undefined' && window.localStorage) { window.localStorage.setItem('scannerResults', JSON.stringify(results.slice(0, 200))); } } catch (e) {}\r\n  }\r\n  function notifyThrottled(force = false) {\r\n    try {\r\n      const now = Date.now();\r\n      // If the page is hidden (background tab), don't rely on setTimeout-based throttling\r\n      // which browsers may clamp heavily; instead deliver notifications synchronously so\r\n      // the React state held by listeners stays up-to-date when the tab becomes visible.\r\n      const isHidden = (typeof document !== 'undefined' && document.hidden);\r\n      if (isHidden) {\r\n        lastNotifyTs = now; pendingNotify = false; notifyNow(); return;\r\n      }\r\n      if (force || now - lastNotifyTs >= 100) { lastNotifyTs = now; pendingNotify = false; notifyNow(); return; }\r\n      if (!pendingNotify) { pendingNotify = true; const wait = Math.max(0, 100 - (now - lastNotifyTs)); setTimeout(() => { lastNotifyTs = Date.now(); pendingNotify = false; notifyNow(); }, wait); }\r\n    } catch (e) { try { notifyNow(); } catch (e2) {} }\r\n  }\r\n\r\n  function onUpdate(cb) { listeners.add(cb); return () => listeners.delete(cb); }\r\n  function setGetSymbols(fn) { getSymbolsFn = fn; }\r\n  const sleep = (ms) => new Promise(r => setTimeout(r, ms));\r\n\r\n  function calculateEma(values, period) {\r\n    if (!Array.isArray(values) || values.length === 0) return [];\r\n    const k = 2 / (period + 1); const out = []; let ema = null;\r\n    for (let i = 0; i < values.length; i++) {\r\n      const v = Number(values[i]); if (isNaN(v)) { out.push(null); continue; }\r\n      if (ema === null) { if (i + 1 >= period) { const slice = values.slice(i + 1 - period, i + 1).map(Number); ema = slice.reduce((a,b)=>a+b,0)/period; out.push(ema); } else { out.push(null); } }\r\n      else { ema = v * k + ema * (1 - k); out.push(ema); }\r\n    }\r\n    return out;\r\n  }\r\n\r\n  async function start(type, opts = {}) {\r\n    if (running) return;\r\n    try { console.log('[scannerManager] start called', { type, opts }); } catch (e) {}\r\n    if (typeof getSymbolsFn !== 'function') throw new Error('scannerManager: getSymbolsFn not set');\r\n    running = true; cancel = false; results = []; progress = { done: 0, total: 0 }; currentSymbol = null; scanType = type || null; scanStartTime = Date.now();\r\n    notifyThrottled(true);\r\n    const list = (await Promise.resolve(getSymbolsFn())) || [];\r\n    let interval = (opts && typeof opts.interval !== 'undefined') ? opts.interval : '5m';\r\n    if (typeof interval === 'number' || (typeof interval === 'string' && /^\\d+$/.test(String(interval)))) interval = `${interval}m`;\r\n    const emaShort = (opts && typeof opts.emaShort !== 'undefined') ? parseInt(opts.emaShort, 10) : 26;\r\n    const emaLong = (opts && typeof opts.emaLong !== 'undefined') ? parseInt(opts.emaLong, 10) : 200;\r\n    // Normalize / sanitize incoming symbol list to reduce typos like 'BTCSTUSDT'\r\n    const sanitizeSymbol = (raw) => {\r\n      if (!raw) return '';\r\n      try {\r\n        let s = String(raw).toUpperCase();\r\n        // strip any non-alphanumeric chars\r\n        s = s.replace(/[^A-Z0-9]/g, '');\r\n        // collapse repeated USDT occurrences (e.g. 'BTCUSDTUSDT' -> 'BTCUSDT')\r\n        s = s.replace(/(USDT)+$/g, 'USDT');\r\n        s = s.replace(/USDTUSDT/g, 'USDT');\r\n        // If the result doesn't end with USDT it's not a futures symbol we care about\r\n        if (!/USDT$/.test(s)) return '';\r\n        // Basic sanity: symbol length should be reasonable\r\n        if (s.length < 6 || s.length > 12) return '';\r\n        return s;\r\n      } catch (e) { return ''; }\r\n    };\r\n\r\n    // Build a unique, normalized filtered list to use for API calls.\r\n    const normalized = [];\r\n    if (Array.isArray(list)) {\r\n      const seen = new Set();\r\n      for (const it of list) {\r\n        const n = sanitizeSymbol(it);\r\n        if (!n) continue;\r\n        if (seen.has(n)) continue;\r\n        seen.add(n);\r\n        normalized.push(n);\r\n      }\r\n    }\r\n    const filtered = normalized;\r\n    // Validate symbols against Binance exchangeInfo to avoid scanning invalid/typo symbols\r\n    progress.total = filtered.length; notifyThrottled(true);\r\n    try {\r\n      const infoUrl = 'https://fapi.binance.com/fapi/v1/exchangeInfo';\r\n      const infoResp = await fetch(infoUrl, { cf: { cacheTtl: 600 } });\r\n      if (infoResp && infoResp.ok) {\r\n        const info = await infoResp.json().catch(() => null);\r\n        if (info && Array.isArray(info.symbols)) {\r\n          const validSet = new Set(info.symbols.map(s => String(s.symbol).toUpperCase()));\r\n          const before = filtered.length;\r\n          const cleaned = filtered.map(s => String(s).toUpperCase()).filter(s => validSet.has(s));\r\n          if (cleaned.length !== before) {\r\n            try { console.log('[scannerManager] removed invalid symbols', { before, after: cleaned.length }); } catch (e) {}\r\n          }\r\n          // use cleaned list (preserve case as original list may vary)\r\n          const cleanedMap = new Map(); filtered.forEach(s => cleanedMap.set(String(s).toUpperCase(), s));\r\n          const finalList = cleaned.map(su => cleanedMap.get(su) || su);\r\n          // replace filtered variable\r\n          // eslint-disable-next-line no-param-reassign\r\n          filtered.length = 0; Array.prototype.push.apply(filtered, finalList);\r\n          progress.total = filtered.length; notifyThrottled(true);\r\n        }\r\n      }\r\n    } catch (e) { try { console.warn('[scannerManager] exchangeInfo fetch failed', e && e.message ? e.message : e); } catch (e2) {} }\r\n    const endpointBase = 'https://fapi.binance.com/fapi/v1/klines';\r\n\r\n    // Try to delegate scanning to dedicated worker (served at /worker-scanner.js)\r\n    const symbolsArray = Array.isArray(list) ? list : [];\r\n    // Only delegate to the dedicated worker for single-run scans.\r\n    // For continuous monitoring (`opts.monitor`), run inline loop to allow repeated passes.\r\n    try { console.log('[scannerManager] monitorMode?', !!(opts && opts.monitor)); } catch (e) {}\r\n    if (!opts.monitor && typeof Worker !== 'undefined' && typeof window !== 'undefined') {\r\n      try {\r\n        workerInstance = new Worker('/worker-scanner.js');\r\n        let workerReady = false;\r\n        const onMsg = (ev) => {\r\n          const m = ev.data || {};\r\n          if (m.type === 'started') {\r\n            workerReady = true; progress.total = m.total || progress.total; notifyThrottled(true);\r\n          } else if (m.type === 'progress') {\r\n            workerReady = true; progress.done = m.done || progress.done; currentSymbol = m.currentSymbol || currentSymbol; notifyThrottled();\r\n          } else if (m.type === 'match' && m.ev) {\r\n            workerReady = true; results.unshift(m.ev); if (results.length > 500) results = results.slice(0, 500); notifyThrottled();\r\n          } else if (m.type === 'done') {\r\n            // worker finished its task\r\n            try { workerInstance.terminate(); } catch (e) {}\r\n            workerInstance = null; running = false; currentSymbol = null; cancel = false; scanStartTime = null; notifyThrottled(true);\r\n          } else if (m.type === 'stopped') {\r\n            try { workerInstance.terminate(); } catch (e) {}\r\n            workerInstance = null; running = false; currentSymbol = null; cancel = false; scanStartTime = null; notifyThrottled(true);\r\n          }\r\n        };\r\n        workerInstance.addEventListener('message', onMsg);\r\n        workerInstance.addEventListener('error', (err) => {\r\n          try { console.warn('scanner worker error', err); } catch (e) {}\r\n        });\r\n        // send start command with symbols and options\r\n        try { workerInstance.postMessage({ cmd: 'start', symbols: symbolsArray, opts, scanType: type }); } catch (e) { /* ignore */ }\r\n\r\n        // Wait briefly for the worker to acknowledge (avoid stuck 'Scanning: ...' if worker asset missing or blocked)\r\n        const waitMs = 2000;\r\n        await new Promise((resolve) => {\r\n          const to = setTimeout(() => {\r\n            if (!workerReady) {\r\n              try { workerInstance.removeEventListener('message', onMsg); } catch (e) {}\r\n              try { workerInstance.terminate(); } catch (e) {}\r\n              workerInstance = null;\r\n            }\r\n            resolve();\r\n          }, waitMs);\r\n          // if worker signals readiness before timeout, resolve early\r\n          const early = () => { clearTimeout(to); resolve(); };\r\n          const checkInterval = setInterval(() => { if (workerReady) { clearInterval(checkInterval); early(); } }, 50);\r\n        });\r\n\r\n        // If worker started and is handling the scan, return early\r\n        if (workerInstance) {\r\n          // worker is active and will manage scanning\r\n          return;\r\n        }\r\n        // else fallthrough to inline scanner\r\n      } catch (e) {\r\n        try { if (workerInstance) { workerInstance.terminate(); workerInstance = null; } } catch (e2) {}\r\n        // fallthrough to inline scanner\r\n      }\r\n    }\r\n\r\n    const concurrencyDefault = (opts && typeof opts.concurrency === 'number') ? Math.max(1, opts.concurrency) : 8;\r\n    const batchDelayBase = (opts && typeof opts.batchDelay === 'number') ? Math.max(0, opts.batchDelay) : 120;\r\n    let concurrencyCurrent = concurrencyDefault; let batchDelayCurrent = batchDelayBase;\r\n    const maxConcurrency = (opts && typeof opts.maxConcurrency === 'number') ? Math.max(1, opts.maxConcurrency) : 12;\r\n    let backoffCount = 0; let consecutiveSuccesses = 0;\r\n    const successThreshold = (opts && typeof opts.rampSuccessThreshold === 'number') ? Math.max(1, opts.rampSuccessThreshold) : 3;\r\n    const minBatchDelay = (opts && typeof opts.minBatchDelay === 'number') ? Math.max(50, opts.minBatchDelay) : 60;\r\n    const neededCandles = Math.max(emaShort, emaLong) + 10;\r\n    // Allow caller to request a specific kline limit (e.g., 200). If not provided,\r\n    // fall back to previous heuristic which ensured at least ~120 candles.\r\n    const klineLimitOpt = (opts && typeof opts.klineLimit === 'number') ? Math.max(0, parseInt(opts.klineLimit, 10)) : null;\r\n    const candleLimit = (Number.isFinite(klineLimitOpt) && klineLimitOpt > 0)\r\n      ? Math.min(1000, Math.max(klineLimitOpt, neededCandles + 1))\r\n      : Math.min(1000, Math.max(neededCandles + 10, 120));\r\n\r\n    const processSymbol = async (sym) => {\r\n      if (cancel) return;\r\n      currentSymbol = sym; notifyThrottled();\r\n      const url = `${endpointBase}?symbol=${encodeURIComponent(sym)}&interval=${encodeURIComponent(interval)}&limit=${candleLimit}`;\r\n      let localAbort = null; try { localAbort = new AbortController(); currentAbortControllers.add(localAbort); } catch (e) {}\r\n      try {\r\n        const r = await fetch(url, localAbort ? { signal: localAbort.signal } : undefined);\r\n        if (!r.ok) {\r\n          // Too many requests -> backoff and retry later\r\n          if (r.status === 429) {\r\n            backoffCount += 1; consecutiveSuccesses = 0; concurrencyCurrent = Math.max(1, Math.floor(concurrencyCurrent * 0.6)); batchDelayCurrent = Math.min(30000, Math.floor(batchDelayCurrent * 1.6));\r\n            const backoffMs = Math.min(30000, 1000 * Math.pow(2, Math.min(backoffCount, 6)) + Math.floor(Math.random() * 1000));\r\n            await sleep(backoffMs);\r\n            return;\r\n          }\r\n          // Bad request often means an invalid symbol (typo or delisted). Remove it to avoid repeated 400s.\r\n          if (r.status === 400) {\r\n            try { console.warn('[scannerManager] removing invalid symbol due to 400', sym); } catch (e) {}\r\n            try {\r\n              const idx = filtered.indexOf(sym);\r\n              if (idx !== -1) {\r\n                filtered.splice(idx, 1);\r\n                progress.total = filtered.length;\r\n                notifyThrottled(true);\r\n              }\r\n            } catch (e) {}\r\n            return;\r\n          }\r\n          return;\r\n        }\r\n        const data = await r.json();\r\n        backoffCount = Math.max(0, backoffCount - 1); consecutiveSuccesses += 1;\r\n        if (consecutiveSuccesses >= successThreshold) { consecutiveSuccesses = 0; if (concurrencyCurrent < maxConcurrency) concurrencyCurrent += 1; batchDelayCurrent = Math.max(minBatchDelay, Math.floor(batchDelayCurrent * 0.85)); }\r\n        const closes = Array.isArray(data) ? data.map(d => parseFloat(d[4])) : [];\r\n          // require one extra candle so we can use the last closed candle (avoid counting the live/open candle)\r\n          if (!Array.isArray(closes) || closes.length < neededCandles + 1) return;\r\n        const emaShortArr = calculateEma(closes, emaShort); const emaLongArr = calculateEma(closes, emaLong);\r\n          const lastClosedIdx = closes.length - 2; const prevIdx = lastClosedIdx - 1;\r\n          const prevShort = emaShortArr[prevIdx]; const prevLong = emaLongArr[prevIdx];\r\n          const lastShort = emaShortArr[lastClosedIdx]; const lastLong = emaLongArr[lastClosedIdx];\r\n        let matched = false;\r\n        if (typeof prevShort === 'number' && typeof prevLong === 'number' && typeof lastShort === 'number' && typeof lastLong === 'number') {\r\n          if (scanType === 'golden') matched = (prevShort <= prevLong && lastShort > lastLong);\r\n          else if (scanType === 'dead') matched = (prevShort >= prevLong && lastShort < lastLong);\r\n        }\r\n        const lastVolume = (Array.isArray(data) && data[lastClosedIdx] && data[lastClosedIdx][5] != null) ? parseFloat(data[lastClosedIdx][5]) : 0;\r\n        // Real-time monitoring behavior: maintain activeMatches map. When a symbol becomes matched, add it; when it stops matching, remove it.\r\n        if (matched) {\r\n          try { console.log('[scannerManager] match detected', sym, { scanType, emaShort, emaLong }); } catch (e) {}\r\n          if (!activeMatches[sym]) {\r\n            const ev = { id: `${sym}-${Date.now()}-${Math.random().toString(36).slice(2,8)}`, symbol: sym, prevShort, prevLong, lastShort, lastLong, time: new Date().toLocaleString(), interval, emaShort, emaLong, type: scanType, volume: lastVolume };\r\n            activeMatches[sym] = ev;\r\n            // also keep history results for reference\r\n            results.unshift(ev); if (results.length > 500) results = results.slice(0, 500);\r\n            notifyThrottled();\r\n            try { console.log('[scannerManager] active add', sym); } catch (e) {}\r\n          } else {\r\n            // update existing active entry with latest values\r\n            activeMatches[sym] = { ...activeMatches[sym], prevShort, prevLong, lastShort, lastLong, time: new Date().toLocaleString(), volume: lastVolume };\r\n            try { console.log('[scannerManager] active update', sym); } catch (e) {}\r\n          }\r\n        } else {\r\n          if (activeMatches[sym]) {\r\n            try { console.log('[scannerManager] match cleared', sym); } catch (e) {}\r\n            delete activeMatches[sym];\r\n            notifyThrottled();\r\n          }\r\n        }\r\n      } catch (e) { /* ignore */ }\r\n      finally { if (localAbort) currentAbortControllers.delete(localAbort); progress.done += 1; notifyThrottled(); }\r\n    };\r\n\r\n    // support continuous monitoring mode: if opts.monitor=true, repeat full passes until stopped\r\n    const monitorMode = !!(opts && opts.monitor);\r\n    const pollIntervalMs = (opts && typeof opts.pollIntervalMs === 'number') ? Math.max(1000, opts.pollIntervalMs) : null;\r\n    async function runFullPass() {\r\n      let i = 0;\r\n      try { console.log('[scannerManager] runFullPass start', { scanType, interval, total: filtered.length, time: new Date().toISOString() }); } catch (e) {}\r\n      while (i < filtered.length) {\r\n        if (cancel) break;\r\n        const currentConcurrency = Math.max(1, Math.floor(concurrencyCurrent));\r\n        const batch = filtered.slice(i, i + currentConcurrency); if (!batch.length) break;\r\n        await Promise.all(batch.map(sym => processSymbol(sym)));\r\n        if (cancel) break; i += batch.length;\r\n        if (i < filtered.length) {\r\n          // When the page is hidden, browser timers may be clamped and make the scanner\r\n          // appear to 'stop'. In that case, keep scans going but be conservative: reduce\r\n          // concurrency to 1 and use a very small yield to avoid relying on long setTimeouts.\r\n          try {\r\n            const isHidden = (typeof document !== 'undefined' && document.hidden);\r\n            if (isHidden) {\r\n              // small yield so we don't spin the event loop too hard, but avoid long sleeps\r\n              await sleep(20);\r\n            } else {\r\n              const jitter = Math.floor(Math.random() * Math.min(120, Math.max(10, Math.floor(batchDelayCurrent * 0.5))));\r\n              const delay = Math.max(0, batchDelayCurrent + jitter);\r\n              await sleep(delay);\r\n            }\r\n          } catch (e) { /* ignore */ }\r\n        }\r\n      }\r\n      try { console.log('[scannerManager] runFullPass done', { processed: i, time: new Date().toISOString() }); } catch (e) {}\r\n    }\r\n    try {\r\n      let passCount = 0;\r\n      do {\r\n        passCount += 1;\r\n        try { console.log('[scannerManager] monitoring pass start', { passCount, monitorMode, time: new Date().toISOString() }); } catch (e) {}\r\n        // reset progress for this pass\r\n        progress.done = 0; progress.total = filtered.length; notifyThrottled(true);\r\n        await runFullPass();\r\n        if (cancel) break;\r\n        // if not monitoring, break after one pass\r\n        if (!monitorMode) break;\r\n        // wait for poll interval (default to interval minutes + 5 seconds if not provided)\r\n        let waitMs = pollIntervalMs;\r\n        if (!waitMs) {\r\n          // try to derive from interval string like '5m'\r\n          const m = String(interval || '').match(/^(\\d+)m$/);\r\n          if (m) { waitMs = parseInt(m[1], 10) * 60 * 1000 + 5000; } else { waitMs = 30000; }\r\n        }\r\n        const step = 1000;\r\n        let slept = 0;\r\n        try { console.log('[scannerManager] waiting between passes', { waitMs }); } catch (e) {}\r\n        while (slept < waitMs && !cancel) { const to = Math.min(step, waitMs - slept); await sleep(to); slept += to; }\r\n        try { console.log('[scannerManager] waiting complete', { passCount, time: new Date().toISOString() }); } catch (e) {}\r\n      } while (!cancel);\r\n    } catch (err) { try { console.error('scannerManager.start error', err && err.message ? err.message : err); } catch (e) {} }\r\n    finally { try { for (const c of currentAbortControllers) { try { c.abort(); } catch (e) {} } } catch (e) {} currentAbortControllers.clear(); running = false; currentSymbol = null; cancel = false; scanStartTime = null; scanType = null; notifyThrottled(true); }\r\n  }\r\n\r\n  function stop() {\r\n    cancel = true;\r\n    try { for (const c of currentAbortControllers) { try { c.abort(); } catch (e) {} } currentAbortControllers.clear(); } catch (e) {}\r\n    // If a worker is running, tell it to stop and terminate it\r\n    try {\r\n      if (workerInstance) {\r\n        try { workerInstance.postMessage({ cmd: 'stop' }); } catch (e) {}\r\n        try { workerInstance.terminate(); } catch (e) {}\r\n        workerInstance = null;\r\n      }\r\n    } catch (e) {}\r\n    running = false; currentSymbol = null; scanStartTime = null; scanType = null; notifyThrottled(true);\r\n  }\r\n  function getState() { return stateSnapshot(); }\r\n  function removeResult(id) { if (!id) return; results = results.filter(r => r.id !== id); notifyThrottled(); }\r\n  function clearResults() { results = []; notifyThrottled(true); }\r\n  function removeActive(symbol) { if (!symbol) return; if (activeMatches[symbol]) { delete activeMatches[symbol]; notifyThrottled(true); } }\r\n\r\n  return { onUpdate, setGetSymbols, start, stop, getState, removeResult, clearResults, removeActive };\r\n})();\r\n\r\nexport default scannerManager;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}