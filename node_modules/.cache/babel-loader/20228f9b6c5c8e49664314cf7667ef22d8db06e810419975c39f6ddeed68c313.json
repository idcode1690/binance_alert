{"ast":null,"code":"// Simple singleton scanner manager to run scans independent of React component lifecycle.\nconst scannerManager = (() => {\n  let running = false;\n  let currentSymbol = null;\n  let progress = {\n    done: 0,\n    total: 0\n  };\n  // load persisted results from localStorage when available so navigation doesn't lose matches\n  let results = [];\n  try {\n    if (typeof window !== 'undefined' && window.localStorage) {\n      const raw = window.localStorage.getItem('scannerResults');\n      if (raw) results = JSON.parse(raw) || [];\n    }\n  } catch (e) {\n    results = [];\n  }\n  let cancel = false;\n  // timestamp when the current scan started (ms since epoch) - persists so UI can show elapsed across pages\n  let scanStartTime = null;\n  // track multiple abort controllers when running requests in parallel\n  let currentAbortControllers = new Set();\n  let listeners = new Set();\n  let getSymbolsFn = null;\n  function notify() {\n    const state = {\n      running,\n      currentSymbol,\n      progress: {\n        ...progress\n      },\n      results: results.slice(),\n      scanStartTime\n    };\n    for (const cb of listeners) {\n      try {\n        cb(state);\n      } catch (e) {}\n    }\n    // persist results after notifying\n    try {\n      if (typeof window !== 'undefined' && window.localStorage) {\n        window.localStorage.setItem('scannerResults', JSON.stringify(results.slice(0, 200)));\n      }\n    } catch (e) {}\n  }\n  function onUpdate(cb) {\n    listeners.add(cb);\n    return () => listeners.delete(cb);\n  }\n  function setGetSymbols(fn) {\n    getSymbolsFn = fn;\n  }\n  function sleep(ms) {\n    return new Promise(r => setTimeout(r, ms));\n  }\n\n  // same EMA helper as used in ScannerPage\n  function calculateEma(values, period) {\n    if (!Array.isArray(values) || values.length === 0) return [];\n    const k = 2 / (period + 1);\n    const out = [];\n    let ema = null;\n    for (let i = 0; i < values.length; i++) {\n      const v = Number(values[i]);\n      if (isNaN(v)) {\n        out.push(null);\n        continue;\n      }\n      if (ema === null) {\n        if (i + 1 >= period) {\n          const slice = values.slice(i + 1 - period, i + 1).map(Number);\n          const s = slice.reduce((a, b) => a + b, 0) / period;\n          ema = s;\n          out.push(ema);\n        } else {\n          out.push(null);\n        }\n      } else {\n        ema = v * k + ema * (1 - k);\n        out.push(ema);\n      }\n    }\n    return out;\n  }\n  async function start(type, opts = {}) {\n    if (running) return;\n    if (typeof getSymbolsFn !== 'function') throw new Error('scannerManager: getSymbolsFn not set');\n    running = true;\n    cancel = false;\n    results = [];\n    progress = {\n      done: 0,\n      total: 0\n    };\n    currentSymbol = null;\n    scanStartTime = Date.now();\n    notify();\n    const list = (await Promise.resolve(getSymbolsFn())) || [];\n    // accept options: interval (e.g., '5m' or number of minutes), emaShort, emaLong\n    let interval = opts && typeof opts.interval !== 'undefined' ? opts.interval : '5m';\n    if (typeof interval === 'number' || typeof interval === 'string' && /^\\d+$/.test(interval)) interval = `${interval}m`;\n    const emaShort = opts && typeof opts.emaShort !== 'undefined' ? parseInt(opts.emaShort, 10) : 26;\n    const emaLong = opts && typeof opts.emaLong !== 'undefined' ? parseInt(opts.emaLong, 10) : 200;\n    const filtered = Array.isArray(list) ? list.filter(s => typeof s === 'string' && /USDT$/i.test(s)) : [];\n    progress.total = filtered.length;\n    notify();\n    const endpointBase = 'https://fapi.binance.com/fapi/v1/klines';\n\n    // concurrency controls: default to a faster parallelism for quicker scans\n    // These defaults can be overridden via opts when calling start()\n    const concurrencyDefault = opts && typeof opts.concurrency === 'number' ? Math.max(1, opts.concurrency) : 6;\n    const batchDelayBase = opts && typeof opts.batchDelay === 'number' ? Math.max(0, opts.batchDelay) : 200; // ms between batches (default faster)\n    // mutable runtime controls (auto-tuner will adjust these)\n    let concurrencyCurrent = concurrencyDefault;\n    let batchDelayCurrent = batchDelayBase;\n    const maxConcurrency = Math.min(16, Math.max(2, opts && typeof opts.maxConcurrency === 'number' ? opts.maxConcurrency : 12));\n    // backoff/ramp state\n    let backoffCount = 0;\n    let consecutiveSuccesses = 0;\n    const successThreshold = opts && typeof opts.rampSuccessThreshold === 'number' ? Math.max(1, opts.rampSuccessThreshold) : 3;\n    const minBatchDelay = opts && typeof opts.minBatchDelay === 'number' ? Math.max(50, opts.minBatchDelay) : 80;\n\n    // helper to process one symbol; catches errors and always resolves\n    const processSymbol = async sym => {\n      if (cancel) return;\n      currentSymbol = sym;\n      notify();\n      const url = `${endpointBase}?symbol=${encodeURIComponent(sym)}&interval=${encodeURIComponent(interval)}&limit=1000`;\n      let localAbort = null;\n      try {\n        try {\n          localAbort = new AbortController();\n        } catch (e) {\n          localAbort = null;\n        }\n        if (localAbort) currentAbortControllers.add(localAbort);\n        const r = await fetch(url, localAbort ? {\n          signal: localAbort.signal\n        } : undefined);\n        if (!r.ok) {\n          if (r.status === 429) {\n            // increase backoff pressure and reduce concurrency\n            backoffCount += 1;\n            consecutiveSuccesses = 0;\n            concurrencyCurrent = Math.max(1, Math.floor(concurrencyCurrent * 0.6));\n            batchDelayCurrent = Math.min(30000, Math.floor(batchDelayCurrent * 1.6));\n            const base = 1000;\n            const backoffMs = Math.min(30000, Math.floor(base * Math.pow(2, Math.min(backoffCount, 6))) + Math.floor(Math.random() * 1000));\n            try {\n              await sleep(backoffMs);\n            } catch (e) {}\n          }\n          return;\n        }\n        const data = await r.json();\n        // success: reduce backoff pressure and allow gentle ramp-up\n        backoffCount = Math.max(0, backoffCount - 1);\n        consecutiveSuccesses += 1;\n        if (consecutiveSuccesses >= successThreshold) {\n          consecutiveSuccesses = 0;\n          if (concurrencyCurrent < maxConcurrency) {\n            concurrencyCurrent = concurrencyCurrent + 1;\n          }\n          batchDelayCurrent = Math.max(minBatchDelay, Math.floor(batchDelayCurrent * 0.85));\n        }\n        const closes = Array.isArray(data) ? data.map(d => parseFloat(d[4])) : [];\n        const needed = Math.max(emaShort, emaLong) + 10;\n        if (!Array.isArray(closes) || closes.length < needed) {\n          return;\n        }\n        const emaShortArr = calculateEma(closes, emaShort);\n        const emaLongArr = calculateEma(closes, emaLong);\n        const lastIdx = closes.length - 1;\n        const prevIdx = lastIdx - 1;\n        const prevShort = emaShortArr[prevIdx];\n        const prevLong = emaLongArr[prevIdx];\n        const lastShort = emaShortArr[lastIdx];\n        const lastLong = emaLongArr[lastIdx];\n        let matched = false;\n        if (typeof prevShort === 'number' && typeof prevLong === 'number' && typeof lastShort === 'number' && typeof lastLong === 'number') {\n          if (type === 'golden') {\n            if (prevShort <= prevLong && lastShort > lastLong) matched = true;\n          } else if (type === 'dead') {\n            if (prevShort >= prevLong && lastShort < lastLong) matched = true;\n          }\n        }\n        if (matched) {\n          const ev = {\n            id: `${sym}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,\n            symbol: sym,\n            lastShort,\n            lastLong,\n            time: new Date().toLocaleString(),\n            interval,\n            emaShort,\n            emaLong\n          };\n          results.unshift(ev);\n          // cap stored results to reasonable size (avoid unbounded growth)\n          if (results.length > 500) results = results.slice(0, 500);\n          notify();\n        }\n      } catch (e) {\n        if (e && e.name === 'AbortError') {\n          // expected when stopping\n        } else {\n          // ignore other fetch errors\n        }\n      } finally {\n        // cleanup local abort controller\n        if (localAbort) currentAbortControllers.delete(localAbort);\n        progress.done += 1;\n        notify();\n      }\n    };\n\n    // run in batches with a mutable concurrency controlled by the auto-tuner\n    let i = 0;\n    while (i < filtered.length) {\n      if (cancel) break;\n      const currentConcurrency = Math.max(1, Math.floor(concurrencyCurrent));\n      const batch = filtered.slice(i, i + currentConcurrency);\n      if (!batch || batch.length === 0) break;\n      await Promise.all(batch.map(sym => processSymbol(sym)));\n      if (cancel) break;\n      i += batch.length;\n      if (i < filtered.length) {\n        const jitter = Math.floor(Math.random() * Math.min(300, Math.max(20, Math.floor(batchDelayCurrent * 0.5))));\n        const delay = Math.max(0, batchDelayCurrent + jitter);\n        await sleep(delay);\n      }\n    }\n    // cleanup any remaining abort controllers\n    try {\n      for (const c of currentAbortControllers) {\n        try {\n          c.abort();\n        } catch (e) {}\n      }\n    } catch (e) {}\n    currentAbortControllers.clear();\n    running = false;\n    currentSymbol = null;\n    cancel = false;\n    scanStartTime = null;\n    notify();\n  }\n  function stop() {\n    // signal cancellation and abort any in-flight fetch\n    cancel = true;\n    try {\n      // abort any tracked controllers\n      for (const c of currentAbortControllers) {\n        try {\n          if (c && typeof c.abort === 'function') c.abort();\n        } catch (e) {}\n      }\n      currentAbortControllers.clear();\n    } catch (e) {}\n    running = false;\n    currentSymbol = null;\n    notify();\n  }\n  function getState() {\n    return {\n      running,\n      currentSymbol,\n      progress: {\n        ...progress\n      },\n      results: results.slice()\n    };\n  }\n  function removeResult(id) {\n    if (!id) return;\n    results = results.filter(r => r.id !== id);\n    notify();\n  }\n  function clearResults() {\n    results = [];\n    notify();\n  }\n  return {\n    onUpdate,\n    setGetSymbols,\n    start,\n    stop,\n    getState,\n    removeResult,\n    clearResults\n  };\n})();\nexport default scannerManager;","map":{"version":3,"names":["scannerManager","running","currentSymbol","progress","done","total","results","window","localStorage","raw","getItem","JSON","parse","e","cancel","scanStartTime","currentAbortControllers","Set","listeners","getSymbolsFn","notify","state","slice","cb","setItem","stringify","onUpdate","add","delete","setGetSymbols","fn","sleep","ms","Promise","r","setTimeout","calculateEma","values","period","Array","isArray","length","k","out","ema","i","v","Number","isNaN","push","map","s","reduce","a","b","start","type","opts","Error","Date","now","list","resolve","interval","test","emaShort","parseInt","emaLong","filtered","filter","endpointBase","concurrencyDefault","concurrency","Math","max","batchDelayBase","batchDelay","concurrencyCurrent","batchDelayCurrent","maxConcurrency","min","backoffCount","consecutiveSuccesses","successThreshold","rampSuccessThreshold","minBatchDelay","processSymbol","sym","url","encodeURIComponent","localAbort","AbortController","fetch","signal","undefined","ok","status","floor","base","backoffMs","pow","random","data","json","closes","d","parseFloat","needed","emaShortArr","emaLongArr","lastIdx","prevIdx","prevShort","prevLong","lastShort","lastLong","matched","ev","id","toString","symbol","time","toLocaleString","unshift","name","currentConcurrency","batch","all","jitter","delay","c","abort","clear","stop","getState","removeResult","clearResults"],"sources":["C:/Users/e1it3/Desktop/program/binance_alert/src/lib/scannerManager.js"],"sourcesContent":["// Simple singleton scanner manager to run scans independent of React component lifecycle.\r\nconst scannerManager = (() => {\r\n  let running = false;\r\n  let currentSymbol = null;\r\n  let progress = { done: 0, total: 0 };\r\n  // load persisted results from localStorage when available so navigation doesn't lose matches\r\n  let results = [];\r\n  try {\r\n    if (typeof window !== 'undefined' && window.localStorage) {\r\n      const raw = window.localStorage.getItem('scannerResults');\r\n      if (raw) results = JSON.parse(raw) || [];\r\n    }\r\n  } catch (e) {\r\n    results = [];\r\n  }\r\n  let cancel = false;\r\n  // timestamp when the current scan started (ms since epoch) - persists so UI can show elapsed across pages\r\n  let scanStartTime = null;\r\n  // track multiple abort controllers when running requests in parallel\r\n  let currentAbortControllers = new Set();\r\n  let listeners = new Set();\r\n  let getSymbolsFn = null;\r\n\r\n  function notify() {\r\n    const state = { running, currentSymbol, progress: { ...progress }, results: results.slice(), scanStartTime };\r\n    for (const cb of listeners) {\r\n      try { cb(state); } catch (e) {}\r\n    }\r\n    // persist results after notifying\r\n    try {\r\n      if (typeof window !== 'undefined' && window.localStorage) {\r\n        window.localStorage.setItem('scannerResults', JSON.stringify(results.slice(0, 200)));\r\n      }\r\n    } catch (e) {}\r\n  }\r\n\r\n  function onUpdate(cb) { listeners.add(cb); return () => listeners.delete(cb); }\r\n\r\n  function setGetSymbols(fn) { getSymbolsFn = fn; }\r\n\r\n  function sleep(ms) { return new Promise((r) => setTimeout(r, ms)); }\r\n\r\n  // same EMA helper as used in ScannerPage\r\n  function calculateEma(values, period) {\r\n    if (!Array.isArray(values) || values.length === 0) return [];\r\n    const k = 2 / (period + 1);\r\n    const out = [];\r\n    let ema = null;\r\n    for (let i = 0; i < values.length; i++) {\r\n      const v = Number(values[i]);\r\n      if (isNaN(v)) { out.push(null); continue; }\r\n      if (ema === null) {\r\n        if (i + 1 >= period) {\r\n          const slice = values.slice(i + 1 - period, i + 1).map(Number);\r\n          const s = slice.reduce((a, b) => a + b, 0) / period;\r\n          ema = s;\r\n          out.push(ema);\r\n        } else { out.push(null); }\r\n      } else {\r\n        ema = v * k + ema * (1 - k);\r\n        out.push(ema);\r\n      }\r\n    }\r\n    return out;\r\n  }\r\n\r\n  async function start(type, opts = {}) {\r\n    if (running) return;\r\n    if (typeof getSymbolsFn !== 'function') throw new Error('scannerManager: getSymbolsFn not set');\r\n    running = true; cancel = false; results = []; progress = { done: 0, total: 0 }; currentSymbol = null; scanStartTime = Date.now(); notify();\r\n    const list = (await Promise.resolve(getSymbolsFn())) || [];\r\n    // accept options: interval (e.g., '5m' or number of minutes), emaShort, emaLong\r\n    let interval = (opts && typeof opts.interval !== 'undefined') ? opts.interval : '5m';\r\n    if (typeof interval === 'number' || (typeof interval === 'string' && /^\\d+$/.test(interval))) interval = `${interval}m`;\r\n    const emaShort = (opts && typeof opts.emaShort !== 'undefined') ? parseInt(opts.emaShort, 10) : 26;\r\n    const emaLong = (opts && typeof opts.emaLong !== 'undefined') ? parseInt(opts.emaLong, 10) : 200;\r\n    const filtered = (Array.isArray(list) ? list.filter(s => typeof s === 'string' && /USDT$/i.test(s)) : []);\r\n    progress.total = filtered.length; notify();\r\n    const endpointBase = 'https://fapi.binance.com/fapi/v1/klines';\r\n\r\n  // concurrency controls: default to a faster parallelism for quicker scans\r\n  // These defaults can be overridden via opts when calling start()\r\n  const concurrencyDefault = (opts && typeof opts.concurrency === 'number') ? Math.max(1, opts.concurrency) : 6;\r\n  const batchDelayBase = (opts && typeof opts.batchDelay === 'number') ? Math.max(0, opts.batchDelay) : 200; // ms between batches (default faster)\r\n  // mutable runtime controls (auto-tuner will adjust these)\r\n  let concurrencyCurrent = concurrencyDefault;\r\n  let batchDelayCurrent = batchDelayBase;\r\n  const maxConcurrency = Math.min(16, Math.max(2, (opts && typeof opts.maxConcurrency === 'number') ? opts.maxConcurrency : 12));\r\n  // backoff/ramp state\r\n  let backoffCount = 0;\r\n  let consecutiveSuccesses = 0;\r\n  const successThreshold = (opts && typeof opts.rampSuccessThreshold === 'number') ? Math.max(1, opts.rampSuccessThreshold) : 3;\r\n  const minBatchDelay = (opts && typeof opts.minBatchDelay === 'number') ? Math.max(50, opts.minBatchDelay) : 80;\r\n\r\n    // helper to process one symbol; catches errors and always resolves\r\n    const processSymbol = async (sym) => {\r\n      if (cancel) return;\r\n      currentSymbol = sym; notify();\r\n      const url = `${endpointBase}?symbol=${encodeURIComponent(sym)}&interval=${encodeURIComponent(interval)}&limit=1000`;\r\n      let localAbort = null;\r\n      try {\r\n        try { localAbort = new AbortController(); } catch (e) { localAbort = null; }\r\n        if (localAbort) currentAbortControllers.add(localAbort);\r\n        const r = await fetch(url, localAbort ? { signal: localAbort.signal } : undefined);\r\n        if (!r.ok) {\r\n          if (r.status === 429) {\r\n            // increase backoff pressure and reduce concurrency\r\n            backoffCount += 1;\r\n            consecutiveSuccesses = 0;\r\n            concurrencyCurrent = Math.max(1, Math.floor(concurrencyCurrent * 0.6));\r\n            batchDelayCurrent = Math.min(30000, Math.floor(batchDelayCurrent * 1.6));\r\n            const base = 1000;\r\n            const backoffMs = Math.min(30000, Math.floor(base * Math.pow(2, Math.min(backoffCount, 6))) + Math.floor(Math.random() * 1000));\r\n            try { await sleep(backoffMs); } catch (e) {}\r\n          }\r\n          return;\r\n        }\r\n        const data = await r.json();\r\n        // success: reduce backoff pressure and allow gentle ramp-up\r\n        backoffCount = Math.max(0, backoffCount - 1);\r\n        consecutiveSuccesses += 1;\r\n        if (consecutiveSuccesses >= successThreshold) {\r\n          consecutiveSuccesses = 0;\r\n          if (concurrencyCurrent < maxConcurrency) {\r\n            concurrencyCurrent = concurrencyCurrent + 1;\r\n          }\r\n          batchDelayCurrent = Math.max(minBatchDelay, Math.floor(batchDelayCurrent * 0.85));\r\n        }\r\n        const closes = (Array.isArray(data) ? data.map(d => parseFloat(d[4])) : []);\r\n        const needed = Math.max(emaShort, emaLong) + 10;\r\n        if (!Array.isArray(closes) || closes.length < needed) { return; }\r\n        const emaShortArr = calculateEma(closes, emaShort);\r\n        const emaLongArr = calculateEma(closes, emaLong);\r\n        const lastIdx = closes.length - 1;\r\n        const prevIdx = lastIdx - 1;\r\n        const prevShort = emaShortArr[prevIdx];\r\n        const prevLong = emaLongArr[prevIdx];\r\n        const lastShort = emaShortArr[lastIdx];\r\n        const lastLong = emaLongArr[lastIdx];\r\n        let matched = false;\r\n        if (typeof prevShort === 'number' && typeof prevLong === 'number' && typeof lastShort === 'number' && typeof lastLong === 'number') {\r\n          if (type === 'golden') { if (prevShort <= prevLong && lastShort > lastLong) matched = true; }\r\n          else if (type === 'dead') { if (prevShort >= prevLong && lastShort < lastLong) matched = true; }\r\n        }\r\n        if (matched) {\r\n          const ev = { id: `${sym}-${Date.now()}-${Math.random().toString(36).slice(2,8)}`, symbol: sym, lastShort, lastLong, time: new Date().toLocaleString(), interval, emaShort, emaLong };\r\n          results.unshift(ev);\r\n          // cap stored results to reasonable size (avoid unbounded growth)\r\n          if (results.length > 500) results = results.slice(0, 500);\r\n          notify();\r\n        }\r\n      } catch (e) {\r\n        if (e && e.name === 'AbortError') {\r\n          // expected when stopping\r\n        } else {\r\n          // ignore other fetch errors\r\n        }\r\n      } finally {\r\n        // cleanup local abort controller\r\n        if (localAbort) currentAbortControllers.delete(localAbort);\r\n        progress.done += 1; notify();\r\n      }\r\n    };\r\n\r\n    // run in batches with a mutable concurrency controlled by the auto-tuner\r\n    let i = 0;\r\n    while (i < filtered.length) {\r\n      if (cancel) break;\r\n      const currentConcurrency = Math.max(1, Math.floor(concurrencyCurrent));\r\n      const batch = filtered.slice(i, i + currentConcurrency);\r\n      if (!batch || batch.length === 0) break;\r\n      await Promise.all(batch.map(sym => processSymbol(sym)));\r\n      if (cancel) break;\r\n      i += batch.length;\r\n      if (i < filtered.length) {\r\n        const jitter = Math.floor(Math.random() * Math.min(300, Math.max(20, Math.floor(batchDelayCurrent * 0.5))));\r\n        const delay = Math.max(0, batchDelayCurrent + jitter);\r\n        await sleep(delay);\r\n      }\r\n    }\r\n  // cleanup any remaining abort controllers\r\n  try { for (const c of currentAbortControllers) { try { c.abort(); } catch (e) {} } } catch (e) {}\r\n  currentAbortControllers.clear();\r\n  running = false; currentSymbol = null; cancel = false; scanStartTime = null; notify();\r\n  }\r\n\r\n  function stop() {\r\n    // signal cancellation and abort any in-flight fetch\r\n    cancel = true;\r\n    try {\r\n      // abort any tracked controllers\r\n      for (const c of currentAbortControllers) {\r\n        try { if (c && typeof c.abort === 'function') c.abort(); } catch (e) {}\r\n      }\r\n      currentAbortControllers.clear();\r\n    } catch (e) {}\r\n    running = false; currentSymbol = null; notify();\r\n  }\r\n\r\n  function getState() { return { running, currentSymbol, progress: { ...progress }, results: results.slice() }; }\r\n\r\n  function removeResult(id) {\r\n    if (!id) return;\r\n    results = results.filter(r => r.id !== id);\r\n    notify();\r\n  }\r\n\r\n  function clearResults() {\r\n    results = [];\r\n    notify();\r\n  }\r\n\r\n  return { onUpdate, setGetSymbols, start, stop, getState, removeResult, clearResults };\r\n})();\r\n\r\nexport default scannerManager;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}