{"ast":null,"code":"// Simple singleton scanner manager to run scans independent of React component lifecycle.\nconst scannerManager = (() => {\n  let running = false;\n  let currentSymbol = null;\n  let progress = {\n    done: 0,\n    total: 0\n  };\n  let results = [];\n  let cancel = false;\n  let currentAbortController = null;\n  let listeners = new Set();\n  let getSymbolsFn = null;\n  function notify() {\n    const state = {\n      running,\n      currentSymbol,\n      progress: {\n        ...progress\n      },\n      results: results.slice()\n    };\n    for (const cb of listeners) {\n      try {\n        cb(state);\n      } catch (e) {}\n    }\n  }\n  function onUpdate(cb) {\n    listeners.add(cb);\n    return () => listeners.delete(cb);\n  }\n  function setGetSymbols(fn) {\n    getSymbolsFn = fn;\n  }\n  function sleep(ms) {\n    return new Promise(r => setTimeout(r, ms));\n  }\n\n  // same EMA helper as used in ScannerPage\n  function calculateEma(values, period) {\n    if (!Array.isArray(values) || values.length === 0) return [];\n    const k = 2 / (period + 1);\n    const out = [];\n    let ema = null;\n    for (let i = 0; i < values.length; i++) {\n      const v = Number(values[i]);\n      if (isNaN(v)) {\n        out.push(null);\n        continue;\n      }\n      if (ema === null) {\n        if (i + 1 >= period) {\n          const slice = values.slice(i + 1 - period, i + 1).map(Number);\n          const s = slice.reduce((a, b) => a + b, 0) / period;\n          ema = s;\n          out.push(ema);\n        } else {\n          out.push(null);\n        }\n      } else {\n        ema = v * k + ema * (1 - k);\n        out.push(ema);\n      }\n    }\n    return out;\n  }\n  async function start(type, opts = {}) {\n    if (running) return;\n    if (typeof getSymbolsFn !== 'function') throw new Error('scannerManager: getSymbolsFn not set');\n    running = true;\n    cancel = false;\n    results = [];\n    progress = {\n      done: 0,\n      total: 0\n    };\n    currentSymbol = null;\n    notify();\n    const list = (await Promise.resolve(getSymbolsFn())) || [];\n    // accept options: interval (e.g., '5m' or number of minutes), emaShort, emaLong\n    let interval = opts && typeof opts.interval !== 'undefined' ? opts.interval : '5m';\n    if (typeof interval === 'number' || typeof interval === 'string' && /^\\d+$/.test(interval)) interval = `${interval}m`;\n    const emaShort = opts && typeof opts.emaShort !== 'undefined' ? parseInt(opts.emaShort, 10) : 26;\n    const emaLong = opts && typeof opts.emaLong !== 'undefined' ? parseInt(opts.emaLong, 10) : 200;\n    const filtered = Array.isArray(list) ? list.filter(s => typeof s === 'string' && /USDT$/i.test(s)) : [];\n    progress.total = filtered.length;\n    notify();\n    const endpointBase = 'https://fapi.binance.com/fapi/v1/klines';\n    for (let i = 0; i < filtered.length; i++) {\n      if (cancel) break;\n      const sym = filtered[i];\n      currentSymbol = sym;\n      notify();\n      try {\n        const url = `${endpointBase}?symbol=${encodeURIComponent(sym)}&interval=${encodeURIComponent(interval)}&limit=1000`;\n        // create an AbortController so we can cancel an in-flight fetch when stop() is called\n        try {\n          currentAbortController = new AbortController();\n        } catch (e) {\n          currentAbortController = null;\n        }\n        const r = await fetch(url, currentAbortController ? {\n          signal: currentAbortController.signal\n        } : undefined);\n        if (!r.ok) {\n          if (r.status === 429) await sleep(2000);\n          progress.done += 1;\n          notify();\n          await sleep(1000);\n          continue;\n        }\n        const data = await r.json();\n        const closes = Array.isArray(data) ? data.map(d => parseFloat(d[4])) : [];\n        const needed = Math.max(emaShort, emaLong) + 10;\n        if (!Array.isArray(closes) || closes.length < needed) {\n          progress.done += 1;\n          notify();\n          await sleep(1000);\n          continue;\n        }\n        const emaShortArr = calculateEma(closes, emaShort);\n        const emaLongArr = calculateEma(closes, emaLong);\n        const lastIdx = closes.length - 1;\n        const prevIdx = lastIdx - 1;\n        const prevShort = emaShortArr[prevIdx];\n        const prevLong = emaLongArr[prevIdx];\n        const lastShort = emaShortArr[lastIdx];\n        const lastLong = emaLongArr[lastIdx];\n        let matched = false;\n        if (typeof prevShort === 'number' && typeof prevLong === 'number' && typeof lastShort === 'number' && typeof lastLong === 'number') {\n          if (type === 'golden') {\n            if (prevShort <= prevLong && lastShort > lastLong) matched = true;\n          } else if (type === 'dead') {\n            if (prevShort >= prevLong && lastShort < lastLong) matched = true;\n          }\n        }\n        if (matched) {\n          const ev = {\n            symbol: sym,\n            lastShort,\n            lastLong,\n            time: new Date().toLocaleString(),\n            interval,\n            emaShort,\n            emaLong\n          };\n          results.unshift(ev);\n          notify();\n        }\n      } catch (e) {\n        // if the fetch was aborted, treat as cancelled; otherwise ignore errors\n        // (fetch throws a DOMException with name 'AbortError' when aborted)\n        if (e && e.name === 'AbortError') {\n          // no-op: expected when stopping scan\n        } else {\n          // ignore other errors\n        }\n      } finally {\n        // clear abort controller for this iteration\n        currentAbortController = null;\n      }\n      progress.done += 1;\n      notify();\n      await sleep(1000);\n    }\n    running = false;\n    currentSymbol = null;\n    cancel = false;\n    currentAbortController = null;\n    notify();\n  }\n  function stop() {\n    // signal cancellation and abort any in-flight fetch\n    cancel = true;\n    try {\n      if (currentAbortController && typeof currentAbortController.abort === 'function') {\n        currentAbortController.abort();\n      }\n    } catch (e) {}\n    running = false;\n    currentSymbol = null;\n    notify();\n  }\n  function getState() {\n    return {\n      running,\n      currentSymbol,\n      progress: {\n        ...progress\n      },\n      results: results.slice()\n    };\n  }\n  return {\n    onUpdate,\n    setGetSymbols,\n    start,\n    stop,\n    getState\n  };\n})();\nexport default scannerManager;","map":{"version":3,"names":["scannerManager","running","currentSymbol","progress","done","total","results","cancel","currentAbortController","listeners","Set","getSymbolsFn","notify","state","slice","cb","e","onUpdate","add","delete","setGetSymbols","fn","sleep","ms","Promise","r","setTimeout","calculateEma","values","period","Array","isArray","length","k","out","ema","i","v","Number","isNaN","push","map","s","reduce","a","b","start","type","opts","Error","list","resolve","interval","test","emaShort","parseInt","emaLong","filtered","filter","endpointBase","sym","url","encodeURIComponent","AbortController","fetch","signal","undefined","ok","status","data","json","closes","d","parseFloat","needed","Math","max","emaShortArr","emaLongArr","lastIdx","prevIdx","prevShort","prevLong","lastShort","lastLong","matched","ev","symbol","time","Date","toLocaleString","unshift","name","stop","abort","getState"],"sources":["C:/Users/e1it3/Desktop/program/binance_alert/src/lib/scannerManager.js"],"sourcesContent":["// Simple singleton scanner manager to run scans independent of React component lifecycle.\r\nconst scannerManager = (() => {\r\n  let running = false;\r\n  let currentSymbol = null;\r\n  let progress = { done: 0, total: 0 };\r\n  let results = [];\r\n  let cancel = false;\r\n  let currentAbortController = null;\r\n  let listeners = new Set();\r\n  let getSymbolsFn = null;\r\n\r\n  function notify() {\r\n    const state = { running, currentSymbol, progress: { ...progress }, results: results.slice() };\r\n    for (const cb of listeners) {\r\n      try { cb(state); } catch (e) {}\r\n    }\r\n  }\r\n\r\n  function onUpdate(cb) { listeners.add(cb); return () => listeners.delete(cb); }\r\n\r\n  function setGetSymbols(fn) { getSymbolsFn = fn; }\r\n\r\n  function sleep(ms) { return new Promise((r) => setTimeout(r, ms)); }\r\n\r\n  // same EMA helper as used in ScannerPage\r\n  function calculateEma(values, period) {\r\n    if (!Array.isArray(values) || values.length === 0) return [];\r\n    const k = 2 / (period + 1);\r\n    const out = [];\r\n    let ema = null;\r\n    for (let i = 0; i < values.length; i++) {\r\n      const v = Number(values[i]);\r\n      if (isNaN(v)) { out.push(null); continue; }\r\n      if (ema === null) {\r\n        if (i + 1 >= period) {\r\n          const slice = values.slice(i + 1 - period, i + 1).map(Number);\r\n          const s = slice.reduce((a, b) => a + b, 0) / period;\r\n          ema = s;\r\n          out.push(ema);\r\n        } else { out.push(null); }\r\n      } else {\r\n        ema = v * k + ema * (1 - k);\r\n        out.push(ema);\r\n      }\r\n    }\r\n    return out;\r\n  }\r\n\r\n  async function start(type, opts = {}) {\r\n    if (running) return;\r\n    if (typeof getSymbolsFn !== 'function') throw new Error('scannerManager: getSymbolsFn not set');\r\n    running = true; cancel = false; results = []; progress = { done: 0, total: 0 }; currentSymbol = null; notify();\r\n    const list = (await Promise.resolve(getSymbolsFn())) || [];\r\n    // accept options: interval (e.g., '5m' or number of minutes), emaShort, emaLong\r\n    let interval = (opts && typeof opts.interval !== 'undefined') ? opts.interval : '5m';\r\n    if (typeof interval === 'number' || (typeof interval === 'string' && /^\\d+$/.test(interval))) interval = `${interval}m`;\r\n    const emaShort = (opts && typeof opts.emaShort !== 'undefined') ? parseInt(opts.emaShort, 10) : 26;\r\n    const emaLong = (opts && typeof opts.emaLong !== 'undefined') ? parseInt(opts.emaLong, 10) : 200;\r\n    const filtered = (Array.isArray(list) ? list.filter(s => typeof s === 'string' && /USDT$/i.test(s)) : []);\r\n    progress.total = filtered.length; notify();\r\n    const endpointBase = 'https://fapi.binance.com/fapi/v1/klines';\r\n    for (let i = 0; i < filtered.length; i++) {\r\n      if (cancel) break;\r\n      const sym = filtered[i];\r\n      currentSymbol = sym; notify();\r\n      try {\r\n  const url = `${endpointBase}?symbol=${encodeURIComponent(sym)}&interval=${encodeURIComponent(interval)}&limit=1000`;\r\n        // create an AbortController so we can cancel an in-flight fetch when stop() is called\r\n        try { currentAbortController = new AbortController(); } catch (e) { currentAbortController = null; }\r\n        const r = await fetch(url, currentAbortController ? { signal: currentAbortController.signal } : undefined);\r\n        if (!r.ok) {\r\n          if (r.status === 429) await sleep(2000);\r\n          progress.done += 1; notify(); await sleep(1000); continue;\r\n        }\r\n        const data = await r.json();\r\n        const closes = (Array.isArray(data) ? data.map(d => parseFloat(d[4])) : []);\r\n        const needed = Math.max(emaShort, emaLong) + 10;\r\n        if (!Array.isArray(closes) || closes.length < needed) { progress.done += 1; notify(); await sleep(1000); continue; }\r\n        const emaShortArr = calculateEma(closes, emaShort);\r\n        const emaLongArr = calculateEma(closes, emaLong);\r\n        const lastIdx = closes.length - 1;\r\n        const prevIdx = lastIdx - 1;\r\n        const prevShort = emaShortArr[prevIdx];\r\n        const prevLong = emaLongArr[prevIdx];\r\n        const lastShort = emaShortArr[lastIdx];\r\n        const lastLong = emaLongArr[lastIdx];\r\n        let matched = false;\r\n        if (typeof prevShort === 'number' && typeof prevLong === 'number' && typeof lastShort === 'number' && typeof lastLong === 'number') {\r\n          if (type === 'golden') { if (prevShort <= prevLong && lastShort > lastLong) matched = true; }\r\n          else if (type === 'dead') { if (prevShort >= prevLong && lastShort < lastLong) matched = true; }\r\n        }\r\n        if (matched) {\r\n          const ev = { symbol: sym, lastShort, lastLong, time: new Date().toLocaleString(), interval, emaShort, emaLong };\r\n          results.unshift(ev);\r\n          notify();\r\n        }\r\n      } catch (e) {\r\n        // if the fetch was aborted, treat as cancelled; otherwise ignore errors\r\n        // (fetch throws a DOMException with name 'AbortError' when aborted)\r\n        if (e && e.name === 'AbortError') {\r\n          // no-op: expected when stopping scan\r\n        } else {\r\n          // ignore other errors\r\n        }\r\n      }\r\n      finally {\r\n        // clear abort controller for this iteration\r\n        currentAbortController = null;\r\n      }\r\n      progress.done += 1; notify();\r\n      await sleep(1000);\r\n    }\r\n    running = false; currentSymbol = null; cancel = false; currentAbortController = null; notify();\r\n  }\r\n\r\n  function stop() {\r\n    // signal cancellation and abort any in-flight fetch\r\n    cancel = true;\r\n    try {\r\n      if (currentAbortController && typeof currentAbortController.abort === 'function') {\r\n        currentAbortController.abort();\r\n      }\r\n    } catch (e) {}\r\n    running = false; currentSymbol = null; notify();\r\n  }\r\n\r\n  function getState() { return { running, currentSymbol, progress: { ...progress }, results: results.slice() }; }\r\n\r\n  return { onUpdate, setGetSymbols, start, stop, getState };\r\n})();\r\n\r\nexport default scannerManager;\r\n"],"mappings":"AAAA;AACA,MAAMA,cAAc,GAAG,CAAC,MAAM;EAC5B,IAAIC,OAAO,GAAG,KAAK;EACnB,IAAIC,aAAa,GAAG,IAAI;EACxB,IAAIC,QAAQ,GAAG;IAAEC,IAAI,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAE,CAAC;EACpC,IAAIC,OAAO,GAAG,EAAE;EAChB,IAAIC,MAAM,GAAG,KAAK;EAClB,IAAIC,sBAAsB,GAAG,IAAI;EACjC,IAAIC,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;EACzB,IAAIC,YAAY,GAAG,IAAI;EAEvB,SAASC,MAAMA,CAAA,EAAG;IAChB,MAAMC,KAAK,GAAG;MAAEZ,OAAO;MAAEC,aAAa;MAAEC,QAAQ,EAAE;QAAE,GAAGA;MAAS,CAAC;MAAEG,OAAO,EAAEA,OAAO,CAACQ,KAAK,CAAC;IAAE,CAAC;IAC7F,KAAK,MAAMC,EAAE,IAAIN,SAAS,EAAE;MAC1B,IAAI;QAAEM,EAAE,CAACF,KAAK,CAAC;MAAE,CAAC,CAAC,OAAOG,CAAC,EAAE,CAAC;IAChC;EACF;EAEA,SAASC,QAAQA,CAACF,EAAE,EAAE;IAAEN,SAAS,CAACS,GAAG,CAACH,EAAE,CAAC;IAAE,OAAO,MAAMN,SAAS,CAACU,MAAM,CAACJ,EAAE,CAAC;EAAE;EAE9E,SAASK,aAAaA,CAACC,EAAE,EAAE;IAAEV,YAAY,GAAGU,EAAE;EAAE;EAEhD,SAASC,KAAKA,CAACC,EAAE,EAAE;IAAE,OAAO,IAAIC,OAAO,CAAEC,CAAC,IAAKC,UAAU,CAACD,CAAC,EAAEF,EAAE,CAAC,CAAC;EAAE;;EAEnE;EACA,SAASI,YAAYA,CAACC,MAAM,EAAEC,MAAM,EAAE;IACpC,IAAI,CAACC,KAAK,CAACC,OAAO,CAACH,MAAM,CAAC,IAAIA,MAAM,CAACI,MAAM,KAAK,CAAC,EAAE,OAAO,EAAE;IAC5D,MAAMC,CAAC,GAAG,CAAC,IAAIJ,MAAM,GAAG,CAAC,CAAC;IAC1B,MAAMK,GAAG,GAAG,EAAE;IACd,IAAIC,GAAG,GAAG,IAAI;IACd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,MAAM,CAACI,MAAM,EAAEI,CAAC,EAAE,EAAE;MACtC,MAAMC,CAAC,GAAGC,MAAM,CAACV,MAAM,CAACQ,CAAC,CAAC,CAAC;MAC3B,IAAIG,KAAK,CAACF,CAAC,CAAC,EAAE;QAAEH,GAAG,CAACM,IAAI,CAAC,IAAI,CAAC;QAAE;MAAU;MAC1C,IAAIL,GAAG,KAAK,IAAI,EAAE;QAChB,IAAIC,CAAC,GAAG,CAAC,IAAIP,MAAM,EAAE;UACnB,MAAMf,KAAK,GAAGc,MAAM,CAACd,KAAK,CAACsB,CAAC,GAAG,CAAC,GAAGP,MAAM,EAAEO,CAAC,GAAG,CAAC,CAAC,CAACK,GAAG,CAACH,MAAM,CAAC;UAC7D,MAAMI,CAAC,GAAG5B,KAAK,CAAC6B,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,EAAE,CAAC,CAAC,GAAGhB,MAAM;UACnDM,GAAG,GAAGO,CAAC;UACPR,GAAG,CAACM,IAAI,CAACL,GAAG,CAAC;QACf,CAAC,MAAM;UAAED,GAAG,CAACM,IAAI,CAAC,IAAI,CAAC;QAAE;MAC3B,CAAC,MAAM;QACLL,GAAG,GAAGE,CAAC,GAAGJ,CAAC,GAAGE,GAAG,IAAI,CAAC,GAAGF,CAAC,CAAC;QAC3BC,GAAG,CAACM,IAAI,CAACL,GAAG,CAAC;MACf;IACF;IACA,OAAOD,GAAG;EACZ;EAEA,eAAeY,KAAKA,CAACC,IAAI,EAAEC,IAAI,GAAG,CAAC,CAAC,EAAE;IACpC,IAAI/C,OAAO,EAAE;IACb,IAAI,OAAOU,YAAY,KAAK,UAAU,EAAE,MAAM,IAAIsC,KAAK,CAAC,sCAAsC,CAAC;IAC/FhD,OAAO,GAAG,IAAI;IAAEM,MAAM,GAAG,KAAK;IAAED,OAAO,GAAG,EAAE;IAAEH,QAAQ,GAAG;MAAEC,IAAI,EAAE,CAAC;MAAEC,KAAK,EAAE;IAAE,CAAC;IAAEH,aAAa,GAAG,IAAI;IAAEU,MAAM,CAAC,CAAC;IAC9G,MAAMsC,IAAI,GAAG,CAAC,MAAM1B,OAAO,CAAC2B,OAAO,CAACxC,YAAY,CAAC,CAAC,CAAC,KAAK,EAAE;IAC1D;IACA,IAAIyC,QAAQ,GAAIJ,IAAI,IAAI,OAAOA,IAAI,CAACI,QAAQ,KAAK,WAAW,GAAIJ,IAAI,CAACI,QAAQ,GAAG,IAAI;IACpF,IAAI,OAAOA,QAAQ,KAAK,QAAQ,IAAK,OAAOA,QAAQ,KAAK,QAAQ,IAAI,OAAO,CAACC,IAAI,CAACD,QAAQ,CAAE,EAAEA,QAAQ,GAAG,GAAGA,QAAQ,GAAG;IACvH,MAAME,QAAQ,GAAIN,IAAI,IAAI,OAAOA,IAAI,CAACM,QAAQ,KAAK,WAAW,GAAIC,QAAQ,CAACP,IAAI,CAACM,QAAQ,EAAE,EAAE,CAAC,GAAG,EAAE;IAClG,MAAME,OAAO,GAAIR,IAAI,IAAI,OAAOA,IAAI,CAACQ,OAAO,KAAK,WAAW,GAAID,QAAQ,CAACP,IAAI,CAACQ,OAAO,EAAE,EAAE,CAAC,GAAG,GAAG;IAChG,MAAMC,QAAQ,GAAI3B,KAAK,CAACC,OAAO,CAACmB,IAAI,CAAC,GAAGA,IAAI,CAACQ,MAAM,CAAChB,CAAC,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAI,QAAQ,CAACW,IAAI,CAACX,CAAC,CAAC,CAAC,GAAG,EAAG;IACzGvC,QAAQ,CAACE,KAAK,GAAGoD,QAAQ,CAACzB,MAAM;IAAEpB,MAAM,CAAC,CAAC;IAC1C,MAAM+C,YAAY,GAAG,yCAAyC;IAC9D,KAAK,IAAIvB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqB,QAAQ,CAACzB,MAAM,EAAEI,CAAC,EAAE,EAAE;MACxC,IAAI7B,MAAM,EAAE;MACZ,MAAMqD,GAAG,GAAGH,QAAQ,CAACrB,CAAC,CAAC;MACvBlC,aAAa,GAAG0D,GAAG;MAAEhD,MAAM,CAAC,CAAC;MAC7B,IAAI;QACR,MAAMiD,GAAG,GAAG,GAAGF,YAAY,WAAWG,kBAAkB,CAACF,GAAG,CAAC,aAAaE,kBAAkB,CAACV,QAAQ,CAAC,aAAa;QAC7G;QACA,IAAI;UAAE5C,sBAAsB,GAAG,IAAIuD,eAAe,CAAC,CAAC;QAAE,CAAC,CAAC,OAAO/C,CAAC,EAAE;UAAER,sBAAsB,GAAG,IAAI;QAAE;QACnG,MAAMiB,CAAC,GAAG,MAAMuC,KAAK,CAACH,GAAG,EAAErD,sBAAsB,GAAG;UAAEyD,MAAM,EAAEzD,sBAAsB,CAACyD;QAAO,CAAC,GAAGC,SAAS,CAAC;QAC1G,IAAI,CAACzC,CAAC,CAAC0C,EAAE,EAAE;UACT,IAAI1C,CAAC,CAAC2C,MAAM,KAAK,GAAG,EAAE,MAAM9C,KAAK,CAAC,IAAI,CAAC;UACvCnB,QAAQ,CAACC,IAAI,IAAI,CAAC;UAAEQ,MAAM,CAAC,CAAC;UAAE,MAAMU,KAAK,CAAC,IAAI,CAAC;UAAE;QACnD;QACA,MAAM+C,IAAI,GAAG,MAAM5C,CAAC,CAAC6C,IAAI,CAAC,CAAC;QAC3B,MAAMC,MAAM,GAAIzC,KAAK,CAACC,OAAO,CAACsC,IAAI,CAAC,GAAGA,IAAI,CAAC5B,GAAG,CAAC+B,CAAC,IAAIC,UAAU,CAACD,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,EAAG;QAC3E,MAAME,MAAM,GAAGC,IAAI,CAACC,GAAG,CAACtB,QAAQ,EAAEE,OAAO,CAAC,GAAG,EAAE;QAC/C,IAAI,CAAC1B,KAAK,CAACC,OAAO,CAACwC,MAAM,CAAC,IAAIA,MAAM,CAACvC,MAAM,GAAG0C,MAAM,EAAE;UAAEvE,QAAQ,CAACC,IAAI,IAAI,CAAC;UAAEQ,MAAM,CAAC,CAAC;UAAE,MAAMU,KAAK,CAAC,IAAI,CAAC;UAAE;QAAU;QACnH,MAAMuD,WAAW,GAAGlD,YAAY,CAAC4C,MAAM,EAAEjB,QAAQ,CAAC;QAClD,MAAMwB,UAAU,GAAGnD,YAAY,CAAC4C,MAAM,EAAEf,OAAO,CAAC;QAChD,MAAMuB,OAAO,GAAGR,MAAM,CAACvC,MAAM,GAAG,CAAC;QACjC,MAAMgD,OAAO,GAAGD,OAAO,GAAG,CAAC;QAC3B,MAAME,SAAS,GAAGJ,WAAW,CAACG,OAAO,CAAC;QACtC,MAAME,QAAQ,GAAGJ,UAAU,CAACE,OAAO,CAAC;QACpC,MAAMG,SAAS,GAAGN,WAAW,CAACE,OAAO,CAAC;QACtC,MAAMK,QAAQ,GAAGN,UAAU,CAACC,OAAO,CAAC;QACpC,IAAIM,OAAO,GAAG,KAAK;QACnB,IAAI,OAAOJ,SAAS,KAAK,QAAQ,IAAI,OAAOC,QAAQ,KAAK,QAAQ,IAAI,OAAOC,SAAS,KAAK,QAAQ,IAAI,OAAOC,QAAQ,KAAK,QAAQ,EAAE;UAClI,IAAIrC,IAAI,KAAK,QAAQ,EAAE;YAAE,IAAIkC,SAAS,IAAIC,QAAQ,IAAIC,SAAS,GAAGC,QAAQ,EAAEC,OAAO,GAAG,IAAI;UAAE,CAAC,MACxF,IAAItC,IAAI,KAAK,MAAM,EAAE;YAAE,IAAIkC,SAAS,IAAIC,QAAQ,IAAIC,SAAS,GAAGC,QAAQ,EAAEC,OAAO,GAAG,IAAI;UAAE;QACjG;QACA,IAAIA,OAAO,EAAE;UACX,MAAMC,EAAE,GAAG;YAAEC,MAAM,EAAE3B,GAAG;YAAEuB,SAAS;YAAEC,QAAQ;YAAEI,IAAI,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,cAAc,CAAC,CAAC;YAAEtC,QAAQ;YAAEE,QAAQ;YAAEE;UAAQ,CAAC;UAC/GlD,OAAO,CAACqF,OAAO,CAACL,EAAE,CAAC;UACnB1E,MAAM,CAAC,CAAC;QACV;MACF,CAAC,CAAC,OAAOI,CAAC,EAAE;QACV;QACA;QACA,IAAIA,CAAC,IAAIA,CAAC,CAAC4E,IAAI,KAAK,YAAY,EAAE;UAChC;QAAA,CACD,MAAM;UACL;QAAA;MAEJ,CAAC,SACO;QACN;QACApF,sBAAsB,GAAG,IAAI;MAC/B;MACAL,QAAQ,CAACC,IAAI,IAAI,CAAC;MAAEQ,MAAM,CAAC,CAAC;MAC5B,MAAMU,KAAK,CAAC,IAAI,CAAC;IACnB;IACArB,OAAO,GAAG,KAAK;IAAEC,aAAa,GAAG,IAAI;IAAEK,MAAM,GAAG,KAAK;IAAEC,sBAAsB,GAAG,IAAI;IAAEI,MAAM,CAAC,CAAC;EAChG;EAEA,SAASiF,IAAIA,CAAA,EAAG;IACd;IACAtF,MAAM,GAAG,IAAI;IACb,IAAI;MACF,IAAIC,sBAAsB,IAAI,OAAOA,sBAAsB,CAACsF,KAAK,KAAK,UAAU,EAAE;QAChFtF,sBAAsB,CAACsF,KAAK,CAAC,CAAC;MAChC;IACF,CAAC,CAAC,OAAO9E,CAAC,EAAE,CAAC;IACbf,OAAO,GAAG,KAAK;IAAEC,aAAa,GAAG,IAAI;IAAEU,MAAM,CAAC,CAAC;EACjD;EAEA,SAASmF,QAAQA,CAAA,EAAG;IAAE,OAAO;MAAE9F,OAAO;MAAEC,aAAa;MAAEC,QAAQ,EAAE;QAAE,GAAGA;MAAS,CAAC;MAAEG,OAAO,EAAEA,OAAO,CAACQ,KAAK,CAAC;IAAE,CAAC;EAAE;EAE9G,OAAO;IAAEG,QAAQ;IAAEG,aAAa;IAAE0B,KAAK;IAAE+C,IAAI;IAAEE;EAAS,CAAC;AAC3D,CAAC,EAAE,CAAC;AAEJ,eAAe/F,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}